
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  username: string
  email: string
  status: UserStatus
}

/**
 * Model Character
 * 
 */
export type Character = {
  id: number
  esiId: bigint
  createdAt: Date
  updatedAt: Date
  accessToken: string
  refreshToken: string
  tokenExpiresAt: number
  allianceId: number | null
  ancestryId: number | null
  birthday: Date
  bloodlineId: number
  corporationId: number
  description: string | null
  factionId: number | null
  gender: string
  name: string
  raceId: number
  scopes: string
  securityStatus: Prisma.Decimal | null
  title: string | null
  totalSp: bigint | null
  ownerId: number
}

/**
 * Model Alliance
 * 
 */
export type Alliance = {
  id: number
  creatorCorporationId: number
  creatorId: number
  name: string
  dateFounded: Date
  executorCorporationId: number | null
  factionId: number | null
  ticker: string
}

/**
 * Model Corporation
 * 
 */
export type Corporation = {
  id: number
  allianceId: number | null
  ceoId: number
  creatorId: number
  dateFounded: Date | null
  description: string | null
  factionId: number | null
  homeStationId: number | null
  memberCount: number
  name: string
  shares: number | null
  taxRate: Prisma.Decimal
  ticker: string
  url: string | null
  warEligible: boolean
}

/**
 * Model agtAgentTypes
 * 
 */
export type agtAgentTypes = {
  agentTypeID: number
  agentType: string | null
}

/**
 * Model agtAgents
 * 
 */
export type agtAgents = {
  agentID: number
  divisionID: number | null
  corporationID: number | null
  locationID: number | null
  level: number | null
  quality: number | null
  agentTypeID: number | null
  isLocator: boolean | null
}

/**
 * Model agtAgentsInSpace
 * 
 */
export type agtAgentsInSpace = {
  agentID: number
  dungeonID: number | null
  solarSystemID: number | null
  spawnPointID: number | null
  typeID: number | null
}

/**
 * Model agtResearchAgents
 * 
 */
export type agtResearchAgents = {
  agentID: number
  typeID: number
}

/**
 * Model certCerts
 * 
 */
export type certCerts = {
  certID: number
  description: string | null
  groupID: number | null
  name: string | null
}

/**
 * Model chrAncestries
 * 
 */
export type chrAncestries = {
  ancestryID: number
  ancestryName: string | null
  bloodlineID: number | null
  description: string | null
  perception: number | null
  willpower: number | null
  charisma: number | null
  memory: number | null
  intelligence: number | null
  iconID: number | null
  shortDescription: string | null
}

/**
 * Model chrAttributes
 * 
 */
export type chrAttributes = {
  attributeID: number
  attributeName: string | null
  description: string | null
  iconID: number | null
  shortDescription: string | null
  notes: string | null
}

/**
 * Model chrBloodlines
 * 
 */
export type chrBloodlines = {
  bloodlineID: number
  bloodlineName: string | null
  raceID: number | null
  description: string | null
  maleDescription: string | null
  femaleDescription: string | null
  shipTypeID: number | null
  corporationID: number | null
  perception: number | null
  willpower: number | null
  charisma: number | null
  memory: number | null
  intelligence: number | null
  iconID: number | null
  shortDescription: string | null
  shortMaleDescription: string | null
  shortFemaleDescription: string | null
}

/**
 * Model chrFactions
 * 
 */
export type chrFactions = {
  factionID: number
  factionName: string | null
  description: string | null
  raceIDs: number | null
  solarSystemID: number | null
  corporationID: number | null
  sizeFactor: number | null
  stationCount: number | null
  stationSystemCount: number | null
  militiaCorporationID: number | null
  iconID: number | null
}

/**
 * Model chrRaces
 * 
 */
export type chrRaces = {
  raceID: number
  raceName: string | null
  description: string | null
  iconID: number | null
  shortDescription: string | null
}

/**
 * Model crpActivities
 * 
 */
export type crpActivities = {
  activityID: number
  activityName: string | null
  description: string | null
}

/**
 * Model crpNPCCorporationDivisions
 * 
 */
export type crpNPCCorporationDivisions = {
  corporationID: number
  divisionID: number
  size: number | null
}

/**
 * Model crpNPCCorporationResearchFields
 * 
 */
export type crpNPCCorporationResearchFields = {
  skillID: number
  corporationID: number
}

/**
 * Model crpNPCCorporationTrades
 * 
 */
export type crpNPCCorporationTrades = {
  corporationID: number
  typeID: number
}

/**
 * Model crpNPCCorporations
 * 
 */
export type crpNPCCorporations = {
  corporationID: number
  size: string | null
  extent: string | null
  solarSystemID: number | null
  investorID1: number | null
  investorShares1: number | null
  investorID2: number | null
  investorShares2: number | null
  investorID3: number | null
  investorShares3: number | null
  investorID4: number | null
  investorShares4: number | null
  friendID: number | null
  enemyID: number | null
  publicShares: number | null
  initialPrice: number | null
  minSecurity: number | null
  scattered: boolean | null
  fringe: number | null
  corridor: number | null
  hub: number | null
  border: number | null
  factionID: number | null
  sizeFactor: number | null
  stationCount: number | null
  stationSystemCount: number | null
  description: string | null
  iconID: number | null
}

/**
 * Model crpNPCDivisions
 * 
 */
export type crpNPCDivisions = {
  divisionID: number
  divisionName: string | null
  description: string | null
  leaderType: string | null
}

/**
 * Model dgmAttributeCategories
 * 
 */
export type dgmAttributeCategories = {
  categoryID: number
  categoryName: string | null
  categoryDescription: string | null
}

/**
 * Model dgmAttributeTypes
 * 
 */
export type dgmAttributeTypes = {
  attributeID: number
  attributeName: string | null
  description: string | null
  iconID: number | null
  defaultValue: number | null
  published: boolean | null
  displayName: string | null
  unitID: number | null
  stackable: boolean | null
  highIsGood: boolean | null
  categoryID: number | null
}

/**
 * Model dgmEffects
 * 
 */
export type dgmEffects = {
  effectID: number
  effectName: string | null
  effectCategory: number | null
  preExpression: number | null
  postExpression: number | null
  description: string | null
  guid: string | null
  iconID: number | null
  isOffensive: boolean | null
  isAssistance: boolean | null
  durationAttributeID: number | null
  trackingSpeedAttributeID: number | null
  dischargeAttributeID: number | null
  rangeAttributeID: number | null
  falloffAttributeID: number | null
  disallowAutoRepeat: boolean | null
  published: boolean | null
  displayName: string | null
  isWarpSafe: boolean | null
  rangeChance: boolean | null
  electronicChance: boolean | null
  propulsionChance: boolean | null
  distribution: number | null
  sfxName: string | null
  npcUsageChanceAttributeID: number | null
  npcActivationChanceAttributeID: number | null
  fittingUsageChanceAttributeID: number | null
  modifierInfo: string | null
}

/**
 * Model dgmExpressions
 * 
 */
export type dgmExpressions = {
  expressionID: number
  operandID: number | null
  arg1: number | null
  arg2: number | null
  expressionValue: string | null
  description: string | null
  expressionName: string | null
  expressionTypeID: number | null
  expressionGroupID: number | null
  expressionAttributeID: number | null
}

/**
 * Model dgmTypeAttributes
 * 
 */
export type dgmTypeAttributes = {
  typeID: number
  attributeID: number
  valueInt: number | null
  valueFloat: number | null
}

/**
 * Model dgmTypeEffects
 * 
 */
export type dgmTypeEffects = {
  typeID: number
  effectID: number
  isDefault: boolean | null
}

/**
 * Model eveGraphics
 * 
 */
export type eveGraphics = {
  graphicID: number
  sofFactionName: string | null
  graphicFile: string | null
  sofHullName: string | null
  sofRaceName: string | null
  description: string | null
}

/**
 * Model eveIcons
 * 
 */
export type eveIcons = {
  iconID: number
  iconFile: string | null
  description: string | null
}

/**
 * Model eveUnits
 * 
 */
export type eveUnits = {
  unitID: number
  unitName: string | null
  displayName: string | null
  description: string | null
}

/**
 * Model industryActivity
 * 
 */
export type industryActivity = {
  typeID: number
  activityID: number
  time: number | null
}

/**
 * Model industryBlueprints
 * 
 */
export type industryBlueprints = {
  typeID: number
  maxProductionLimit: number | null
}

/**
 * Model invCategories
 * 
 */
export type invCategories = {
  categoryID: number
  categoryName: string | null
  iconID: number | null
  published: boolean | null
}

/**
 * Model invContrabandTypes
 * 
 */
export type invContrabandTypes = {
  factionID: number
  typeID: number
  standingLoss: number | null
  confiscateMinSec: number | null
  fineByValue: number | null
  attackMinSec: number | null
}

/**
 * Model invControlTowerResourcePurposes
 * 
 */
export type invControlTowerResourcePurposes = {
  purpose: number
  purposeText: string | null
}

/**
 * Model invControlTowerResources
 * 
 */
export type invControlTowerResources = {
  controlTowerTypeID: number
  resourceTypeID: number
  purpose: number | null
  quantity: number | null
  minSecurityLevel: number | null
  factionID: number | null
}

/**
 * Model invFlags
 * 
 */
export type invFlags = {
  flagID: number
  flagName: string | null
  flagText: string | null
  orderID: number | null
}

/**
 * Model invGroups
 * 
 */
export type invGroups = {
  groupID: number
  categoryID: number | null
  groupName: string | null
  iconID: number | null
  useBasePrice: boolean | null
  anchored: boolean | null
  anchorable: boolean | null
  fittableNonSingleton: boolean | null
  published: boolean | null
}

/**
 * Model invItems
 * 
 */
export type invItems = {
  itemID: number
  typeID: number
  ownerID: number
  locationID: number
  flagID: number
  quantity: number
}

/**
 * Model invMarketGroups
 * 
 */
export type invMarketGroups = {
  marketGroupID: number
  parentGroupID: number | null
  marketGroupName: string | null
  description: string | null
  iconID: number | null
  hasTypes: boolean | null
}

/**
 * Model invMetaGroups
 * 
 */
export type invMetaGroups = {
  metaGroupID: number
  metaGroupName: string | null
  description: string | null
  iconID: number | null
}

/**
 * Model invMetaTypes
 * 
 */
export type invMetaTypes = {
  typeID: number
  parentTypeID: number | null
  metaGroupID: number | null
}

/**
 * Model invNames
 * 
 */
export type invNames = {
  itemID: number
  itemName: string
}

/**
 * Model invPositions
 * 
 */
export type invPositions = {
  itemID: number
  x: number
  y: number
  z: number
  yaw: number | null
  pitch: number | null
  roll: number | null
}

/**
 * Model invTraits
 * 
 */
export type invTraits = {
  traitID: number
  typeID: number | null
  skillID: number | null
  bonus: number | null
  bonusText: string | null
  unitID: number | null
}

/**
 * Model invTypeMaterials
 * 
 */
export type invTypeMaterials = {
  typeID: number
  materialTypeID: number
  quantity: number
}

/**
 * Model invTypeReactions
 * 
 */
export type invTypeReactions = {
  reactionTypeID: number
  input: boolean
  typeID: number
  quantity: number | null
}

/**
 * Model invTypes
 * 
 */
export type invTypes = {
  typeID: number
  groupID: number | null
  typeName: string | null
  description: string | null
  mass: number | null
  volume: number | null
  capacity: number | null
  portionSize: number | null
  raceID: number | null
  basePrice: Prisma.Decimal | null
  published: boolean | null
  marketGroupID: number | null
  iconID: number | null
  soundID: number | null
  graphicID: number | null
}

/**
 * Model invUniqueNames
 * 
 */
export type invUniqueNames = {
  itemID: number
  itemName: string
  groupID: number | null
}

/**
 * Model invVolumes
 * 
 */
export type invVolumes = {
  typeID: number
  volume: number | null
}

/**
 * Model mapCelestialGraphics
 * 
 */
export type mapCelestialGraphics = {
  celestialID: number
  heightMap1: number | null
  heightMap2: number | null
  shaderPreset: number | null
  population: boolean | null
}

/**
 * Model mapCelestialStatistics
 * 
 */
export type mapCelestialStatistics = {
  celestialID: number
  temperature: number | null
  spectralClass: string | null
  luminosity: number | null
  age: number | null
  life: number | null
  orbitRadius: number | null
  eccentricity: number | null
  massDust: number | null
  massGas: number | null
  fragmented: boolean | null
  density: number | null
  surfaceGravity: number | null
  escapeVelocity: number | null
  orbitPeriod: number | null
  rotationRate: number | null
  locked: boolean | null
  pressure: number | null
  radius: number | null
  mass: number | null
}

/**
 * Model mapConstellationJumps
 * 
 */
export type mapConstellationJumps = {
  fromRegionID: number | null
  fromConstellationID: number
  toConstellationID: number
  toRegionID: number | null
}

/**
 * Model mapConstellations
 * 
 */
export type mapConstellations = {
  regionID: number | null
  constellationID: number
  constellationName: string | null
  x: number | null
  y: number | null
  z: number | null
  xMin: number | null
  xMax: number | null
  yMin: number | null
  yMax: number | null
  zMin: number | null
  zMax: number | null
  factionID: number | null
  radius: number | null
}

/**
 * Model mapDenormalize
 * 
 */
export type mapDenormalize = {
  itemID: number
  typeID: number | null
  groupID: number | null
  solarSystemID: number | null
  constellationID: number | null
  regionID: number | null
  orbitID: number | null
  x: number | null
  y: number | null
  z: number | null
  radius: number | null
  itemName: string | null
  security: number | null
  celestialIndex: number | null
  orbitIndex: number | null
}

/**
 * Model mapJumps
 * 
 */
export type mapJumps = {
  stargateID: number
  destinationID: number | null
}

/**
 * Model mapLandmarks
 * 
 */
export type mapLandmarks = {
  landmarkID: number
  landmarkName: string | null
  description: string | null
  locationID: number | null
  x: number | null
  y: number | null
  z: number | null
  iconID: number | null
}

/**
 * Model mapLocationScenes
 * 
 */
export type mapLocationScenes = {
  locationID: number
  graphicID: number | null
}

/**
 * Model mapLocationWormholeClasses
 * 
 */
export type mapLocationWormholeClasses = {
  locationID: number
  wormholeClassID: number | null
}

/**
 * Model mapRegionJumps
 * 
 */
export type mapRegionJumps = {
  fromRegionID: number
  toRegionID: number
}

/**
 * Model mapRegions
 * 
 */
export type mapRegions = {
  regionID: number
  regionName: string | null
  x: number | null
  y: number | null
  z: number | null
  xMin: number | null
  xMax: number | null
  yMin: number | null
  yMax: number | null
  zMin: number | null
  zMax: number | null
  factionID: number | null
  nebula: number | null
  radius: number | null
}

/**
 * Model mapSolarSystemJumps
 * 
 */
export type mapSolarSystemJumps = {
  fromRegionID: number | null
  fromConstellationID: number | null
  fromSolarSystemID: number
  toSolarSystemID: number
  toConstellationID: number | null
  toRegionID: number | null
}

/**
 * Model mapSolarSystems
 * 
 */
export type mapSolarSystems = {
  regionID: number | null
  constellationID: number | null
  solarSystemID: number
  solarSystemName: string | null
  x: number | null
  y: number | null
  z: number | null
  xMin: number | null
  xMax: number | null
  yMin: number | null
  yMax: number | null
  zMin: number | null
  zMax: number | null
  luminosity: number | null
  border: boolean | null
  fringe: boolean | null
  corridor: boolean | null
  hub: boolean | null
  international: boolean | null
  regional: boolean | null
  constellation: boolean | null
  security: number | null
  factionID: number | null
  radius: number | null
  sunTypeID: number | null
  securityClass: string | null
}

/**
 * Model mapUniverse
 * 
 */
export type mapUniverse = {
  universeID: number
  universeName: string | null
  x: number | null
  y: number | null
  z: number | null
  xMin: number | null
  xMax: number | null
  yMin: number | null
  yMax: number | null
  zMin: number | null
  zMax: number | null
  radius: number | null
}

/**
 * Model planetSchematics
 * 
 */
export type planetSchematics = {
  schematicID: number
  schematicName: string | null
  cycleTime: number | null
}

/**
 * Model planetSchematicsPinMap
 * 
 */
export type planetSchematicsPinMap = {
  schematicID: number
  pinTypeID: number
}

/**
 * Model planetSchematicsTypeMap
 * 
 */
export type planetSchematicsTypeMap = {
  schematicID: number
  typeID: number
  quantity: number | null
  isInput: boolean | null
}

/**
 * Model ramActivities
 * 
 */
export type ramActivities = {
  activityID: number
  activityName: string | null
  iconNo: string | null
  description: string | null
  published: boolean | null
}

/**
 * Model ramAssemblyLineStations
 * 
 */
export type ramAssemblyLineStations = {
  stationID: number
  assemblyLineTypeID: number
  quantity: number | null
  stationTypeID: number | null
  ownerID: number | null
  solarSystemID: number | null
  regionID: number | null
}

/**
 * Model ramAssemblyLineTypeDetailPerCategory
 * 
 */
export type ramAssemblyLineTypeDetailPerCategory = {
  assemblyLineTypeID: number
  categoryID: number
  timeMultiplier: number | null
  materialMultiplier: number | null
  costMultiplier: number | null
}

/**
 * Model ramAssemblyLineTypeDetailPerGroup
 * 
 */
export type ramAssemblyLineTypeDetailPerGroup = {
  assemblyLineTypeID: number
  groupID: number
  timeMultiplier: number | null
  materialMultiplier: number | null
  costMultiplier: number | null
}

/**
 * Model ramAssemblyLineTypes
 * 
 */
export type ramAssemblyLineTypes = {
  assemblyLineTypeID: number
  assemblyLineTypeName: string | null
  description: string | null
  baseTimeMultiplier: number | null
  baseMaterialMultiplier: number | null
  baseCostMultiplier: number | null
  volume: number | null
  activityID: number | null
  minCostPerHour: number | null
}

/**
 * Model ramInstallationTypeContents
 * 
 */
export type ramInstallationTypeContents = {
  installationTypeID: number
  assemblyLineTypeID: number
  quantity: number | null
}

/**
 * Model skinLicense
 * 
 */
export type skinLicense = {
  licenseTypeID: number
  duration: number | null
  skinID: number | null
}

/**
 * Model skinMaterials
 * 
 */
export type skinMaterials = {
  skinMaterialID: number
  displayNameID: number | null
  materialSetID: number | null
}

/**
 * Model skins
 * 
 */
export type skins = {
  skinID: number
  internalName: string | null
  skinMaterialID: number | null
}

/**
 * Model staOperationServices
 * 
 */
export type staOperationServices = {
  operationID: number
  serviceID: number
}

/**
 * Model staOperations
 * 
 */
export type staOperations = {
  activityID: number | null
  operationID: number
  operationName: string | null
  description: string | null
  fringe: number | null
  corridor: number | null
  hub: number | null
  border: number | null
  ratio: number | null
  caldariStationTypeID: number | null
  minmatarStationTypeID: number | null
  amarrStationTypeID: number | null
  gallenteStationTypeID: number | null
  joveStationTypeID: number | null
}

/**
 * Model staServices
 * 
 */
export type staServices = {
  serviceID: number
  serviceName: string | null
  description: string | null
}

/**
 * Model staStationTypes
 * 
 */
export type staStationTypes = {
  stationTypeID: number
  dockEntryX: number | null
  dockEntryY: number | null
  dockEntryZ: number | null
  dockOrientationX: number | null
  dockOrientationY: number | null
  dockOrientationZ: number | null
  operationID: number | null
  officeSlots: number | null
  reprocessingEfficiency: number | null
  conquerable: boolean | null
}

/**
 * Model staStations
 * 
 */
export type staStations = {
  stationID: bigint
  security: number | null
  dockingCostPerVolume: number | null
  maxShipVolumeDockable: number | null
  officeRentalCost: number | null
  operationID: number | null
  stationTypeID: number | null
  corporationID: number | null
  solarSystemID: number | null
  constellationID: number | null
  regionID: number | null
  stationName: string | null
  x: number | null
  y: number | null
  z: number | null
  reprocessingEfficiency: number | null
  reprocessingStationsTake: number | null
  reprocessingHangarFlag: number | null
}

/**
 * Model translationTables
 * 
 */
export type translationTables = {
  sourceTable: string
  destinationTable: string | null
  translatedKey: string
  tcGroupID: number | null
  tcID: number | null
}

/**
 * Model trnTranslationColumns
 * 
 */
export type trnTranslationColumns = {
  tcGroupID: number | null
  tcID: number
  tableName: string
  columnName: string
  masterID: string | null
}

/**
 * Model trnTranslationLanguages
 * 
 */
export type trnTranslationLanguages = {
  numericLanguageID: number
  languageID: string | null
  languageName: string | null
}

/**
 * Model trnTranslations
 * 
 */
export type trnTranslations = {
  tcID: number
  keyID: number
  languageID: string
  text: string
}

/**
 * Model warCombatZoneSystems
 * 
 */
export type warCombatZoneSystems = {
  solarSystemID: number
  combatZoneID: number | null
}

/**
 * Model warCombatZones
 * 
 */
export type warCombatZones = {
  combatZoneID: number
  combatZoneName: string | null
  factionID: number | null
  centerSystemID: number | null
  description: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<GlobalReject>;

  /**
   * `prisma.alliance`: Exposes CRUD operations for the **Alliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alliances
    * const alliances = await prisma.alliance.findMany()
    * ```
    */
  get alliance(): Prisma.AllianceDelegate<GlobalReject>;

  /**
   * `prisma.corporation`: Exposes CRUD operations for the **Corporation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Corporations
    * const corporations = await prisma.corporation.findMany()
    * ```
    */
  get corporation(): Prisma.CorporationDelegate<GlobalReject>;

  /**
   * `prisma.agtAgentTypes`: Exposes CRUD operations for the **agtAgentTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgentTypes
    * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
    * ```
    */
  get agtAgentTypes(): Prisma.agtAgentTypesDelegate<GlobalReject>;

  /**
   * `prisma.agtAgents`: Exposes CRUD operations for the **agtAgents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgents
    * const agtAgents = await prisma.agtAgents.findMany()
    * ```
    */
  get agtAgents(): Prisma.agtAgentsDelegate<GlobalReject>;

  /**
   * `prisma.agtAgentsInSpace`: Exposes CRUD operations for the **agtAgentsInSpace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgentsInSpaces
    * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany()
    * ```
    */
  get agtAgentsInSpace(): Prisma.agtAgentsInSpaceDelegate<GlobalReject>;

  /**
   * `prisma.agtResearchAgents`: Exposes CRUD operations for the **agtResearchAgents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtResearchAgents
    * const agtResearchAgents = await prisma.agtResearchAgents.findMany()
    * ```
    */
  get agtResearchAgents(): Prisma.agtResearchAgentsDelegate<GlobalReject>;

  /**
   * `prisma.certCerts`: Exposes CRUD operations for the **certCerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertCerts
    * const certCerts = await prisma.certCerts.findMany()
    * ```
    */
  get certCerts(): Prisma.certCertsDelegate<GlobalReject>;

  /**
   * `prisma.chrAncestries`: Exposes CRUD operations for the **chrAncestries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrAncestries
    * const chrAncestries = await prisma.chrAncestries.findMany()
    * ```
    */
  get chrAncestries(): Prisma.chrAncestriesDelegate<GlobalReject>;

  /**
   * `prisma.chrAttributes`: Exposes CRUD operations for the **chrAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrAttributes
    * const chrAttributes = await prisma.chrAttributes.findMany()
    * ```
    */
  get chrAttributes(): Prisma.chrAttributesDelegate<GlobalReject>;

  /**
   * `prisma.chrBloodlines`: Exposes CRUD operations for the **chrBloodlines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrBloodlines
    * const chrBloodlines = await prisma.chrBloodlines.findMany()
    * ```
    */
  get chrBloodlines(): Prisma.chrBloodlinesDelegate<GlobalReject>;

  /**
   * `prisma.chrFactions`: Exposes CRUD operations for the **chrFactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrFactions
    * const chrFactions = await prisma.chrFactions.findMany()
    * ```
    */
  get chrFactions(): Prisma.chrFactionsDelegate<GlobalReject>;

  /**
   * `prisma.chrRaces`: Exposes CRUD operations for the **chrRaces** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrRaces
    * const chrRaces = await prisma.chrRaces.findMany()
    * ```
    */
  get chrRaces(): Prisma.chrRacesDelegate<GlobalReject>;

  /**
   * `prisma.crpActivities`: Exposes CRUD operations for the **crpActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpActivities
    * const crpActivities = await prisma.crpActivities.findMany()
    * ```
    */
  get crpActivities(): Prisma.crpActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.crpNPCCorporationDivisions`: Exposes CRUD operations for the **crpNPCCorporationDivisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationDivisions
    * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany()
    * ```
    */
  get crpNPCCorporationDivisions(): Prisma.crpNPCCorporationDivisionsDelegate<GlobalReject>;

  /**
   * `prisma.crpNPCCorporationResearchFields`: Exposes CRUD operations for the **crpNPCCorporationResearchFields** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationResearchFields
    * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany()
    * ```
    */
  get crpNPCCorporationResearchFields(): Prisma.crpNPCCorporationResearchFieldsDelegate<GlobalReject>;

  /**
   * `prisma.crpNPCCorporationTrades`: Exposes CRUD operations for the **crpNPCCorporationTrades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationTrades
    * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany()
    * ```
    */
  get crpNPCCorporationTrades(): Prisma.crpNPCCorporationTradesDelegate<GlobalReject>;

  /**
   * `prisma.crpNPCCorporations`: Exposes CRUD operations for the **crpNPCCorporations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporations
    * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany()
    * ```
    */
  get crpNPCCorporations(): Prisma.crpNPCCorporationsDelegate<GlobalReject>;

  /**
   * `prisma.crpNPCDivisions`: Exposes CRUD operations for the **crpNPCDivisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCDivisions
    * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany()
    * ```
    */
  get crpNPCDivisions(): Prisma.crpNPCDivisionsDelegate<GlobalReject>;

  /**
   * `prisma.dgmAttributeCategories`: Exposes CRUD operations for the **dgmAttributeCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmAttributeCategories
    * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany()
    * ```
    */
  get dgmAttributeCategories(): Prisma.dgmAttributeCategoriesDelegate<GlobalReject>;

  /**
   * `prisma.dgmAttributeTypes`: Exposes CRUD operations for the **dgmAttributeTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmAttributeTypes
    * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany()
    * ```
    */
  get dgmAttributeTypes(): Prisma.dgmAttributeTypesDelegate<GlobalReject>;

  /**
   * `prisma.dgmEffects`: Exposes CRUD operations for the **dgmEffects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmEffects
    * const dgmEffects = await prisma.dgmEffects.findMany()
    * ```
    */
  get dgmEffects(): Prisma.dgmEffectsDelegate<GlobalReject>;

  /**
   * `prisma.dgmExpressions`: Exposes CRUD operations for the **dgmExpressions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmExpressions
    * const dgmExpressions = await prisma.dgmExpressions.findMany()
    * ```
    */
  get dgmExpressions(): Prisma.dgmExpressionsDelegate<GlobalReject>;

  /**
   * `prisma.dgmTypeAttributes`: Exposes CRUD operations for the **dgmTypeAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmTypeAttributes
    * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany()
    * ```
    */
  get dgmTypeAttributes(): Prisma.dgmTypeAttributesDelegate<GlobalReject>;

  /**
   * `prisma.dgmTypeEffects`: Exposes CRUD operations for the **dgmTypeEffects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmTypeEffects
    * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany()
    * ```
    */
  get dgmTypeEffects(): Prisma.dgmTypeEffectsDelegate<GlobalReject>;

  /**
   * `prisma.eveGraphics`: Exposes CRUD operations for the **eveGraphics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveGraphics
    * const eveGraphics = await prisma.eveGraphics.findMany()
    * ```
    */
  get eveGraphics(): Prisma.eveGraphicsDelegate<GlobalReject>;

  /**
   * `prisma.eveIcons`: Exposes CRUD operations for the **eveIcons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveIcons
    * const eveIcons = await prisma.eveIcons.findMany()
    * ```
    */
  get eveIcons(): Prisma.eveIconsDelegate<GlobalReject>;

  /**
   * `prisma.eveUnits`: Exposes CRUD operations for the **eveUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveUnits
    * const eveUnits = await prisma.eveUnits.findMany()
    * ```
    */
  get eveUnits(): Prisma.eveUnitsDelegate<GlobalReject>;

  /**
   * `prisma.industryActivity`: Exposes CRUD operations for the **industryActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndustryActivities
    * const industryActivities = await prisma.industryActivity.findMany()
    * ```
    */
  get industryActivity(): Prisma.industryActivityDelegate<GlobalReject>;

  /**
   * `prisma.industryBlueprints`: Exposes CRUD operations for the **industryBlueprints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndustryBlueprints
    * const industryBlueprints = await prisma.industryBlueprints.findMany()
    * ```
    */
  get industryBlueprints(): Prisma.industryBlueprintsDelegate<GlobalReject>;

  /**
   * `prisma.invCategories`: Exposes CRUD operations for the **invCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvCategories
    * const invCategories = await prisma.invCategories.findMany()
    * ```
    */
  get invCategories(): Prisma.invCategoriesDelegate<GlobalReject>;

  /**
   * `prisma.invContrabandTypes`: Exposes CRUD operations for the **invContrabandTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvContrabandTypes
    * const invContrabandTypes = await prisma.invContrabandTypes.findMany()
    * ```
    */
  get invContrabandTypes(): Prisma.invContrabandTypesDelegate<GlobalReject>;

  /**
   * `prisma.invControlTowerResourcePurposes`: Exposes CRUD operations for the **invControlTowerResourcePurposes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvControlTowerResourcePurposes
    * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany()
    * ```
    */
  get invControlTowerResourcePurposes(): Prisma.invControlTowerResourcePurposesDelegate<GlobalReject>;

  /**
   * `prisma.invControlTowerResources`: Exposes CRUD operations for the **invControlTowerResources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvControlTowerResources
    * const invControlTowerResources = await prisma.invControlTowerResources.findMany()
    * ```
    */
  get invControlTowerResources(): Prisma.invControlTowerResourcesDelegate<GlobalReject>;

  /**
   * `prisma.invFlags`: Exposes CRUD operations for the **invFlags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvFlags
    * const invFlags = await prisma.invFlags.findMany()
    * ```
    */
  get invFlags(): Prisma.invFlagsDelegate<GlobalReject>;

  /**
   * `prisma.invGroups`: Exposes CRUD operations for the **invGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvGroups
    * const invGroups = await prisma.invGroups.findMany()
    * ```
    */
  get invGroups(): Prisma.invGroupsDelegate<GlobalReject>;

  /**
   * `prisma.invItems`: Exposes CRUD operations for the **invItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvItems
    * const invItems = await prisma.invItems.findMany()
    * ```
    */
  get invItems(): Prisma.invItemsDelegate<GlobalReject>;

  /**
   * `prisma.invMarketGroups`: Exposes CRUD operations for the **invMarketGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMarketGroups
    * const invMarketGroups = await prisma.invMarketGroups.findMany()
    * ```
    */
  get invMarketGroups(): Prisma.invMarketGroupsDelegate<GlobalReject>;

  /**
   * `prisma.invMetaGroups`: Exposes CRUD operations for the **invMetaGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMetaGroups
    * const invMetaGroups = await prisma.invMetaGroups.findMany()
    * ```
    */
  get invMetaGroups(): Prisma.invMetaGroupsDelegate<GlobalReject>;

  /**
   * `prisma.invMetaTypes`: Exposes CRUD operations for the **invMetaTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMetaTypes
    * const invMetaTypes = await prisma.invMetaTypes.findMany()
    * ```
    */
  get invMetaTypes(): Prisma.invMetaTypesDelegate<GlobalReject>;

  /**
   * `prisma.invNames`: Exposes CRUD operations for the **invNames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvNames
    * const invNames = await prisma.invNames.findMany()
    * ```
    */
  get invNames(): Prisma.invNamesDelegate<GlobalReject>;

  /**
   * `prisma.invPositions`: Exposes CRUD operations for the **invPositions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvPositions
    * const invPositions = await prisma.invPositions.findMany()
    * ```
    */
  get invPositions(): Prisma.invPositionsDelegate<GlobalReject>;

  /**
   * `prisma.invTraits`: Exposes CRUD operations for the **invTraits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTraits
    * const invTraits = await prisma.invTraits.findMany()
    * ```
    */
  get invTraits(): Prisma.invTraitsDelegate<GlobalReject>;

  /**
   * `prisma.invTypeMaterials`: Exposes CRUD operations for the **invTypeMaterials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypeMaterials
    * const invTypeMaterials = await prisma.invTypeMaterials.findMany()
    * ```
    */
  get invTypeMaterials(): Prisma.invTypeMaterialsDelegate<GlobalReject>;

  /**
   * `prisma.invTypeReactions`: Exposes CRUD operations for the **invTypeReactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypeReactions
    * const invTypeReactions = await prisma.invTypeReactions.findMany()
    * ```
    */
  get invTypeReactions(): Prisma.invTypeReactionsDelegate<GlobalReject>;

  /**
   * `prisma.invTypes`: Exposes CRUD operations for the **invTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypes
    * const invTypes = await prisma.invTypes.findMany()
    * ```
    */
  get invTypes(): Prisma.invTypesDelegate<GlobalReject>;

  /**
   * `prisma.invUniqueNames`: Exposes CRUD operations for the **invUniqueNames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvUniqueNames
    * const invUniqueNames = await prisma.invUniqueNames.findMany()
    * ```
    */
  get invUniqueNames(): Prisma.invUniqueNamesDelegate<GlobalReject>;

  /**
   * `prisma.invVolumes`: Exposes CRUD operations for the **invVolumes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvVolumes
    * const invVolumes = await prisma.invVolumes.findMany()
    * ```
    */
  get invVolumes(): Prisma.invVolumesDelegate<GlobalReject>;

  /**
   * `prisma.mapCelestialGraphics`: Exposes CRUD operations for the **mapCelestialGraphics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapCelestialGraphics
    * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany()
    * ```
    */
  get mapCelestialGraphics(): Prisma.mapCelestialGraphicsDelegate<GlobalReject>;

  /**
   * `prisma.mapCelestialStatistics`: Exposes CRUD operations for the **mapCelestialStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapCelestialStatistics
    * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany()
    * ```
    */
  get mapCelestialStatistics(): Prisma.mapCelestialStatisticsDelegate<GlobalReject>;

  /**
   * `prisma.mapConstellationJumps`: Exposes CRUD operations for the **mapConstellationJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapConstellationJumps
    * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany()
    * ```
    */
  get mapConstellationJumps(): Prisma.mapConstellationJumpsDelegate<GlobalReject>;

  /**
   * `prisma.mapConstellations`: Exposes CRUD operations for the **mapConstellations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapConstellations
    * const mapConstellations = await prisma.mapConstellations.findMany()
    * ```
    */
  get mapConstellations(): Prisma.mapConstellationsDelegate<GlobalReject>;

  /**
   * `prisma.mapDenormalize`: Exposes CRUD operations for the **mapDenormalize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapDenormalizes
    * const mapDenormalizes = await prisma.mapDenormalize.findMany()
    * ```
    */
  get mapDenormalize(): Prisma.mapDenormalizeDelegate<GlobalReject>;

  /**
   * `prisma.mapJumps`: Exposes CRUD operations for the **mapJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapJumps
    * const mapJumps = await prisma.mapJumps.findMany()
    * ```
    */
  get mapJumps(): Prisma.mapJumpsDelegate<GlobalReject>;

  /**
   * `prisma.mapLandmarks`: Exposes CRUD operations for the **mapLandmarks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLandmarks
    * const mapLandmarks = await prisma.mapLandmarks.findMany()
    * ```
    */
  get mapLandmarks(): Prisma.mapLandmarksDelegate<GlobalReject>;

  /**
   * `prisma.mapLocationScenes`: Exposes CRUD operations for the **mapLocationScenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLocationScenes
    * const mapLocationScenes = await prisma.mapLocationScenes.findMany()
    * ```
    */
  get mapLocationScenes(): Prisma.mapLocationScenesDelegate<GlobalReject>;

  /**
   * `prisma.mapLocationWormholeClasses`: Exposes CRUD operations for the **mapLocationWormholeClasses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLocationWormholeClasses
    * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany()
    * ```
    */
  get mapLocationWormholeClasses(): Prisma.mapLocationWormholeClassesDelegate<GlobalReject>;

  /**
   * `prisma.mapRegionJumps`: Exposes CRUD operations for the **mapRegionJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapRegionJumps
    * const mapRegionJumps = await prisma.mapRegionJumps.findMany()
    * ```
    */
  get mapRegionJumps(): Prisma.mapRegionJumpsDelegate<GlobalReject>;

  /**
   * `prisma.mapRegions`: Exposes CRUD operations for the **mapRegions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapRegions
    * const mapRegions = await prisma.mapRegions.findMany()
    * ```
    */
  get mapRegions(): Prisma.mapRegionsDelegate<GlobalReject>;

  /**
   * `prisma.mapSolarSystemJumps`: Exposes CRUD operations for the **mapSolarSystemJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSolarSystemJumps
    * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany()
    * ```
    */
  get mapSolarSystemJumps(): Prisma.mapSolarSystemJumpsDelegate<GlobalReject>;

  /**
   * `prisma.mapSolarSystems`: Exposes CRUD operations for the **mapSolarSystems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSolarSystems
    * const mapSolarSystems = await prisma.mapSolarSystems.findMany()
    * ```
    */
  get mapSolarSystems(): Prisma.mapSolarSystemsDelegate<GlobalReject>;

  /**
   * `prisma.mapUniverse`: Exposes CRUD operations for the **mapUniverse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapUniverses
    * const mapUniverses = await prisma.mapUniverse.findMany()
    * ```
    */
  get mapUniverse(): Prisma.mapUniverseDelegate<GlobalReject>;

  /**
   * `prisma.planetSchematics`: Exposes CRUD operations for the **planetSchematics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematics
    * const planetSchematics = await prisma.planetSchematics.findMany()
    * ```
    */
  get planetSchematics(): Prisma.planetSchematicsDelegate<GlobalReject>;

  /**
   * `prisma.planetSchematicsPinMap`: Exposes CRUD operations for the **planetSchematicsPinMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematicsPinMaps
    * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany()
    * ```
    */
  get planetSchematicsPinMap(): Prisma.planetSchematicsPinMapDelegate<GlobalReject>;

  /**
   * `prisma.planetSchematicsTypeMap`: Exposes CRUD operations for the **planetSchematicsTypeMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematicsTypeMaps
    * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany()
    * ```
    */
  get planetSchematicsTypeMap(): Prisma.planetSchematicsTypeMapDelegate<GlobalReject>;

  /**
   * `prisma.ramActivities`: Exposes CRUD operations for the **ramActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamActivities
    * const ramActivities = await prisma.ramActivities.findMany()
    * ```
    */
  get ramActivities(): Prisma.ramActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.ramAssemblyLineStations`: Exposes CRUD operations for the **ramAssemblyLineStations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineStations
    * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany()
    * ```
    */
  get ramAssemblyLineStations(): Prisma.ramAssemblyLineStationsDelegate<GlobalReject>;

  /**
   * `prisma.ramAssemblyLineTypeDetailPerCategory`: Exposes CRUD operations for the **ramAssemblyLineTypeDetailPerCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypeDetailPerCategories
    * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany()
    * ```
    */
  get ramAssemblyLineTypeDetailPerCategory(): Prisma.ramAssemblyLineTypeDetailPerCategoryDelegate<GlobalReject>;

  /**
   * `prisma.ramAssemblyLineTypeDetailPerGroup`: Exposes CRUD operations for the **ramAssemblyLineTypeDetailPerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypeDetailPerGroups
    * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany()
    * ```
    */
  get ramAssemblyLineTypeDetailPerGroup(): Prisma.ramAssemblyLineTypeDetailPerGroupDelegate<GlobalReject>;

  /**
   * `prisma.ramAssemblyLineTypes`: Exposes CRUD operations for the **ramAssemblyLineTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypes
    * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany()
    * ```
    */
  get ramAssemblyLineTypes(): Prisma.ramAssemblyLineTypesDelegate<GlobalReject>;

  /**
   * `prisma.ramInstallationTypeContents`: Exposes CRUD operations for the **ramInstallationTypeContents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamInstallationTypeContents
    * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany()
    * ```
    */
  get ramInstallationTypeContents(): Prisma.ramInstallationTypeContentsDelegate<GlobalReject>;

  /**
   * `prisma.skinLicense`: Exposes CRUD operations for the **skinLicense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkinLicenses
    * const skinLicenses = await prisma.skinLicense.findMany()
    * ```
    */
  get skinLicense(): Prisma.skinLicenseDelegate<GlobalReject>;

  /**
   * `prisma.skinMaterials`: Exposes CRUD operations for the **skinMaterials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkinMaterials
    * const skinMaterials = await prisma.skinMaterials.findMany()
    * ```
    */
  get skinMaterials(): Prisma.skinMaterialsDelegate<GlobalReject>;

  /**
   * `prisma.skins`: Exposes CRUD operations for the **skins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skins
    * const skins = await prisma.skins.findMany()
    * ```
    */
  get skins(): Prisma.skinsDelegate<GlobalReject>;

  /**
   * `prisma.staOperationServices`: Exposes CRUD operations for the **staOperationServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaOperationServices
    * const staOperationServices = await prisma.staOperationServices.findMany()
    * ```
    */
  get staOperationServices(): Prisma.staOperationServicesDelegate<GlobalReject>;

  /**
   * `prisma.staOperations`: Exposes CRUD operations for the **staOperations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaOperations
    * const staOperations = await prisma.staOperations.findMany()
    * ```
    */
  get staOperations(): Prisma.staOperationsDelegate<GlobalReject>;

  /**
   * `prisma.staServices`: Exposes CRUD operations for the **staServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaServices
    * const staServices = await prisma.staServices.findMany()
    * ```
    */
  get staServices(): Prisma.staServicesDelegate<GlobalReject>;

  /**
   * `prisma.staStationTypes`: Exposes CRUD operations for the **staStationTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaStationTypes
    * const staStationTypes = await prisma.staStationTypes.findMany()
    * ```
    */
  get staStationTypes(): Prisma.staStationTypesDelegate<GlobalReject>;

  /**
   * `prisma.staStations`: Exposes CRUD operations for the **staStations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaStations
    * const staStations = await prisma.staStations.findMany()
    * ```
    */
  get staStations(): Prisma.staStationsDelegate<GlobalReject>;

  /**
   * `prisma.translationTables`: Exposes CRUD operations for the **translationTables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranslationTables
    * const translationTables = await prisma.translationTables.findMany()
    * ```
    */
  get translationTables(): Prisma.translationTablesDelegate<GlobalReject>;

  /**
   * `prisma.trnTranslationColumns`: Exposes CRUD operations for the **trnTranslationColumns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslationColumns
    * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany()
    * ```
    */
  get trnTranslationColumns(): Prisma.trnTranslationColumnsDelegate<GlobalReject>;

  /**
   * `prisma.trnTranslationLanguages`: Exposes CRUD operations for the **trnTranslationLanguages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslationLanguages
    * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany()
    * ```
    */
  get trnTranslationLanguages(): Prisma.trnTranslationLanguagesDelegate<GlobalReject>;

  /**
   * `prisma.trnTranslations`: Exposes CRUD operations for the **trnTranslations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslations
    * const trnTranslations = await prisma.trnTranslations.findMany()
    * ```
    */
  get trnTranslations(): Prisma.trnTranslationsDelegate<GlobalReject>;

  /**
   * `prisma.warCombatZoneSystems`: Exposes CRUD operations for the **warCombatZoneSystems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarCombatZoneSystems
    * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany()
    * ```
    */
  get warCombatZoneSystems(): Prisma.warCombatZoneSystemsDelegate<GlobalReject>;

  /**
   * `prisma.warCombatZones`: Exposes CRUD operations for the **warCombatZones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarCombatZones
    * const warCombatZones = await prisma.warCombatZones.findMany()
    * ```
    */
  get warCombatZones(): Prisma.warCombatZonesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.6.1
   * Query Engine version: 694eea289a8462c80264df36757e4fdc129b1b32
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Character: 'Character',
    Alliance: 'Alliance',
    Corporation: 'Corporation',
    agtAgentTypes: 'agtAgentTypes',
    agtAgents: 'agtAgents',
    agtAgentsInSpace: 'agtAgentsInSpace',
    agtResearchAgents: 'agtResearchAgents',
    certCerts: 'certCerts',
    chrAncestries: 'chrAncestries',
    chrAttributes: 'chrAttributes',
    chrBloodlines: 'chrBloodlines',
    chrFactions: 'chrFactions',
    chrRaces: 'chrRaces',
    crpActivities: 'crpActivities',
    crpNPCCorporationDivisions: 'crpNPCCorporationDivisions',
    crpNPCCorporationResearchFields: 'crpNPCCorporationResearchFields',
    crpNPCCorporationTrades: 'crpNPCCorporationTrades',
    crpNPCCorporations: 'crpNPCCorporations',
    crpNPCDivisions: 'crpNPCDivisions',
    dgmAttributeCategories: 'dgmAttributeCategories',
    dgmAttributeTypes: 'dgmAttributeTypes',
    dgmEffects: 'dgmEffects',
    dgmExpressions: 'dgmExpressions',
    dgmTypeAttributes: 'dgmTypeAttributes',
    dgmTypeEffects: 'dgmTypeEffects',
    eveGraphics: 'eveGraphics',
    eveIcons: 'eveIcons',
    eveUnits: 'eveUnits',
    industryActivity: 'industryActivity',
    industryBlueprints: 'industryBlueprints',
    invCategories: 'invCategories',
    invContrabandTypes: 'invContrabandTypes',
    invControlTowerResourcePurposes: 'invControlTowerResourcePurposes',
    invControlTowerResources: 'invControlTowerResources',
    invFlags: 'invFlags',
    invGroups: 'invGroups',
    invItems: 'invItems',
    invMarketGroups: 'invMarketGroups',
    invMetaGroups: 'invMetaGroups',
    invMetaTypes: 'invMetaTypes',
    invNames: 'invNames',
    invPositions: 'invPositions',
    invTraits: 'invTraits',
    invTypeMaterials: 'invTypeMaterials',
    invTypeReactions: 'invTypeReactions',
    invTypes: 'invTypes',
    invUniqueNames: 'invUniqueNames',
    invVolumes: 'invVolumes',
    mapCelestialGraphics: 'mapCelestialGraphics',
    mapCelestialStatistics: 'mapCelestialStatistics',
    mapConstellationJumps: 'mapConstellationJumps',
    mapConstellations: 'mapConstellations',
    mapDenormalize: 'mapDenormalize',
    mapJumps: 'mapJumps',
    mapLandmarks: 'mapLandmarks',
    mapLocationScenes: 'mapLocationScenes',
    mapLocationWormholeClasses: 'mapLocationWormholeClasses',
    mapRegionJumps: 'mapRegionJumps',
    mapRegions: 'mapRegions',
    mapSolarSystemJumps: 'mapSolarSystemJumps',
    mapSolarSystems: 'mapSolarSystems',
    mapUniverse: 'mapUniverse',
    planetSchematics: 'planetSchematics',
    planetSchematicsPinMap: 'planetSchematicsPinMap',
    planetSchematicsTypeMap: 'planetSchematicsTypeMap',
    ramActivities: 'ramActivities',
    ramAssemblyLineStations: 'ramAssemblyLineStations',
    ramAssemblyLineTypeDetailPerCategory: 'ramAssemblyLineTypeDetailPerCategory',
    ramAssemblyLineTypeDetailPerGroup: 'ramAssemblyLineTypeDetailPerGroup',
    ramAssemblyLineTypes: 'ramAssemblyLineTypes',
    ramInstallationTypeContents: 'ramInstallationTypeContents',
    skinLicense: 'skinLicense',
    skinMaterials: 'skinMaterials',
    skins: 'skins',
    staOperationServices: 'staOperationServices',
    staOperations: 'staOperations',
    staServices: 'staServices',
    staStationTypes: 'staStationTypes',
    staStations: 'staStations',
    translationTables: 'translationTables',
    trnTranslationColumns: 'trnTranslationColumns',
    trnTranslationLanguages: 'trnTranslationLanguages',
    trnTranslations: 'trnTranslations',
    warCombatZoneSystems: 'warCombatZoneSystems',
    warCombatZones: 'warCombatZones'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    characters: number
  }

  export type UserCountOutputTypeSelect = {
    characters?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type AllianceCountOutputType
   */


  export type AllianceCountOutputType = {
    Corporation: number
    Character: number
  }

  export type AllianceCountOutputTypeSelect = {
    Corporation?: boolean
    Character?: boolean
  }

  export type AllianceCountOutputTypeGetPayload<S extends boolean | null | undefined | AllianceCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AllianceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AllianceCountOutputTypeArgs)
    ? AllianceCountOutputType 
    : S extends { select: any } & (AllianceCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AllianceCountOutputType ? AllianceCountOutputType[P] : never
  } 
      : AllianceCountOutputType




  // Custom InputTypes

  /**
   * AllianceCountOutputType without action
   */
  export type AllianceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AllianceCountOutputType
     * 
    **/
    select?: AllianceCountOutputTypeSelect | null
  }



  /**
   * Count Type CorporationCountOutputType
   */


  export type CorporationCountOutputType = {
    Character: number
  }

  export type CorporationCountOutputTypeSelect = {
    Character?: boolean
  }

  export type CorporationCountOutputTypeGetPayload<S extends boolean | null | undefined | CorporationCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CorporationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CorporationCountOutputTypeArgs)
    ? CorporationCountOutputType 
    : S extends { select: any } & (CorporationCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CorporationCountOutputType ? CorporationCountOutputType[P] : never
  } 
      : CorporationCountOutputType




  // Custom InputTypes

  /**
   * CorporationCountOutputType without action
   */
  export type CorporationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CorporationCountOutputType
     * 
    **/
    select?: CorporationCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    status: UserStatus | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    status: UserStatus | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    status: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    status: UserStatus
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    username?: boolean
    email?: boolean
    status?: boolean
    characters?: boolean | CharacterFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    characters?: boolean | CharacterFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'characters' ? Array < CharacterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'characters' ? Array < CharacterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    characters<T extends CharacterFindManyArgs= {}>(args?: Subset<T, CharacterFindManyArgs>): PrismaPromise<Array<CharacterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Character
   */


  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    id: number | null
    esiId: number | null
    tokenExpiresAt: number | null
    allianceId: number | null
    ancestryId: number | null
    bloodlineId: number | null
    corporationId: number | null
    factionId: number | null
    raceId: number | null
    securityStatus: Decimal | null
    totalSp: number | null
    ownerId: number | null
  }

  export type CharacterSumAggregateOutputType = {
    id: number | null
    esiId: bigint | null
    tokenExpiresAt: number | null
    allianceId: number | null
    ancestryId: number | null
    bloodlineId: number | null
    corporationId: number | null
    factionId: number | null
    raceId: number | null
    securityStatus: Decimal | null
    totalSp: bigint | null
    ownerId: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: number | null
    esiId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: number | null
    allianceId: number | null
    ancestryId: number | null
    birthday: Date | null
    bloodlineId: number | null
    corporationId: number | null
    description: string | null
    factionId: number | null
    gender: string | null
    name: string | null
    raceId: number | null
    scopes: string | null
    securityStatus: Decimal | null
    title: string | null
    totalSp: bigint | null
    ownerId: number | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: number | null
    esiId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: number | null
    allianceId: number | null
    ancestryId: number | null
    birthday: Date | null
    bloodlineId: number | null
    corporationId: number | null
    description: string | null
    factionId: number | null
    gender: string | null
    name: string | null
    raceId: number | null
    scopes: string | null
    securityStatus: Decimal | null
    title: string | null
    totalSp: bigint | null
    ownerId: number | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    esiId: number
    createdAt: number
    updatedAt: number
    accessToken: number
    refreshToken: number
    tokenExpiresAt: number
    allianceId: number
    ancestryId: number
    birthday: number
    bloodlineId: number
    corporationId: number
    description: number
    factionId: number
    gender: number
    name: number
    raceId: number
    scopes: number
    securityStatus: number
    title: number
    totalSp: number
    ownerId: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    id?: true
    esiId?: true
    tokenExpiresAt?: true
    allianceId?: true
    ancestryId?: true
    bloodlineId?: true
    corporationId?: true
    factionId?: true
    raceId?: true
    securityStatus?: true
    totalSp?: true
    ownerId?: true
  }

  export type CharacterSumAggregateInputType = {
    id?: true
    esiId?: true
    tokenExpiresAt?: true
    allianceId?: true
    ancestryId?: true
    bloodlineId?: true
    corporationId?: true
    factionId?: true
    raceId?: true
    securityStatus?: true
    totalSp?: true
    ownerId?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    esiId?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    allianceId?: true
    ancestryId?: true
    birthday?: true
    bloodlineId?: true
    corporationId?: true
    description?: true
    factionId?: true
    gender?: true
    name?: true
    raceId?: true
    scopes?: true
    securityStatus?: true
    title?: true
    totalSp?: true
    ownerId?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    esiId?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    allianceId?: true
    ancestryId?: true
    birthday?: true
    bloodlineId?: true
    corporationId?: true
    description?: true
    factionId?: true
    gender?: true
    name?: true
    raceId?: true
    scopes?: true
    securityStatus?: true
    title?: true
    totalSp?: true
    ownerId?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    esiId?: true
    createdAt?: true
    updatedAt?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    allianceId?: true
    ancestryId?: true
    birthday?: true
    bloodlineId?: true
    corporationId?: true
    description?: true
    factionId?: true
    gender?: true
    name?: true
    raceId?: true
    scopes?: true
    securityStatus?: true
    title?: true
    totalSp?: true
    ownerId?: true
    _all?: true
  }

  export type CharacterAggregateArgs = {
    /**
     * Filter which Character to aggregate.
     * 
    **/
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     * 
    **/
    orderBy?: Enumerable<CharacterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs = {
    where?: CharacterWhereInput
    orderBy?: Enumerable<CharacterOrderByWithAggregationInput>
    by: Array<CharacterScalarFieldEnum>
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }


  export type CharacterGroupByOutputType = {
    id: number
    esiId: bigint
    createdAt: Date
    updatedAt: Date
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId: number | null
    ancestryId: number | null
    birthday: Date
    bloodlineId: number
    corporationId: number
    description: string | null
    factionId: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus: Decimal | null
    title: string | null
    totalSp: bigint | null
    ownerId: number
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect = {
    id?: boolean
    esiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    allianceId?: boolean
    ancestryId?: boolean
    birthday?: boolean
    bloodlineId?: boolean
    corporationId?: boolean
    description?: boolean
    factionId?: boolean
    gender?: boolean
    name?: boolean
    raceId?: boolean
    scopes?: boolean
    securityStatus?: boolean
    title?: boolean
    totalSp?: boolean
    ownerId?: boolean
    owner?: boolean | UserArgs
    corporation?: boolean | CorporationArgs
    alliance?: boolean | AllianceArgs
  }


  export type CharacterInclude = {
    owner?: boolean | UserArgs
    corporation?: boolean | CorporationArgs
    alliance?: boolean | AllianceArgs
  } 

  export type CharacterGetPayload<S extends boolean | null | undefined | CharacterArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Character :
    S extends undefined ? never :
    S extends { include: any } & (CharacterArgs | CharacterFindManyArgs)
    ? Character  & {
    [P in TrueKeys<S['include']>]:
        P extends 'owner' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'corporation' ? CorporationGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'alliance' ? AllianceGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (CharacterArgs | CharacterFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'owner' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'corporation' ? CorporationGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'alliance' ? AllianceGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Character ? Character[P] : never
  } 
      : Character


  type CharacterCountArgs = Merge<
    Omit<CharacterFindManyArgs, 'select' | 'include'> & {
      select?: CharacterCountAggregateInputType | true
    }
  >

  export interface CharacterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CharacterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Character'> extends True ? Prisma__CharacterClient<CharacterGetPayload<T>> : Prisma__CharacterClient<CharacterGetPayload<T> | null, null>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CharacterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Character'> extends True ? Prisma__CharacterClient<CharacterGetPayload<T>> : Prisma__CharacterClient<CharacterGetPayload<T> | null, null>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterFindManyArgs>(
      args?: SelectSubset<T, CharacterFindManyArgs>
    ): PrismaPromise<Array<CharacterGetPayload<T>>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
    **/
    create<T extends CharacterCreateArgs>(
      args: SelectSubset<T, CharacterCreateArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Create many Characters.
     *     @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     *     @example
     *     // Create many Characters
     *     const character = await prisma.character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterCreateManyArgs>(
      args?: SelectSubset<T, CharacterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
    **/
    delete<T extends CharacterDeleteArgs>(
      args: SelectSubset<T, CharacterDeleteArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterUpdateArgs>(
      args: SelectSubset<T, CharacterUpdateArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterDeleteManyArgs>(
      args?: SelectSubset<T, CharacterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterUpdateManyArgs>(
      args: SelectSubset<T, CharacterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterUpsertArgs>(
      args: SelectSubset<T, CharacterUpsertArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Find one Character that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CharacterFindUniqueOrThrowArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Find the first Character that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CharacterFindFirstOrThrowArgs>
    ): Prisma__CharacterClient<CharacterGetPayload<T>>

    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CharacterClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    corporation<T extends CorporationArgs= {}>(args?: Subset<T, CorporationArgs>): Prisma__CorporationClient<CorporationGetPayload<T> | Null>;

    alliance<T extends AllianceArgs= {}>(args?: Subset<T, AllianceArgs>): Prisma__AllianceClient<AllianceGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Character base type for findUnique actions
   */
  export type CharacterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * Filter, which Character to fetch.
     * 
    **/
    where: CharacterWhereUniqueInput
  }

  /**
   * Character: findUnique
   */
  export interface CharacterFindUniqueArgs extends CharacterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Character base type for findFirst actions
   */
  export type CharacterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * Filter, which Character to fetch.
     * 
    **/
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     * 
    **/
    orderBy?: Enumerable<CharacterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     * 
    **/
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     * 
    **/
    distinct?: Enumerable<CharacterScalarFieldEnum>
  }

  /**
   * Character: findFirst
   */
  export interface CharacterFindFirstArgs extends CharacterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * Filter, which Characters to fetch.
     * 
    **/
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     * 
    **/
    orderBy?: Enumerable<CharacterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     * 
    **/
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CharacterScalarFieldEnum>
  }


  /**
   * Character create
   */
  export type CharacterCreateArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * The data needed to create a Character.
     * 
    **/
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }


  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs = {
    /**
     * The data used to create many Characters.
     * 
    **/
    data: Enumerable<CharacterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Character update
   */
  export type CharacterUpdateArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * The data needed to update a Character.
     * 
    **/
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     * 
    **/
    where: CharacterWhereUniqueInput
  }


  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs = {
    /**
     * The data used to update Characters.
     * 
    **/
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     * 
    **/
    where?: CharacterWhereInput
  }


  /**
   * Character upsert
   */
  export type CharacterUpsertArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * The filter to search for the Character to update in case it exists.
     * 
    **/
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     * 
    **/
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }


  /**
   * Character delete
   */
  export type CharacterDeleteArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
    /**
     * Filter which Character to delete.
     * 
    **/
    where: CharacterWhereUniqueInput
  }


  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs = {
    /**
     * Filter which Characters to delete
     * 
    **/
    where?: CharacterWhereInput
  }


  /**
   * Character: findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs = CharacterFindUniqueArgsBase
      

  /**
   * Character: findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs = CharacterFindFirstArgsBase
      

  /**
   * Character without action
   */
  export type CharacterArgs = {
    /**
     * Select specific fields to fetch from the Character
     * 
    **/
    select?: CharacterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CharacterInclude | null
  }



  /**
   * Model Alliance
   */


  export type AggregateAlliance = {
    _count: AllianceCountAggregateOutputType | null
    _avg: AllianceAvgAggregateOutputType | null
    _sum: AllianceSumAggregateOutputType | null
    _min: AllianceMinAggregateOutputType | null
    _max: AllianceMaxAggregateOutputType | null
  }

  export type AllianceAvgAggregateOutputType = {
    id: number | null
    creatorCorporationId: number | null
    creatorId: number | null
    executorCorporationId: number | null
    factionId: number | null
  }

  export type AllianceSumAggregateOutputType = {
    id: number | null
    creatorCorporationId: number | null
    creatorId: number | null
    executorCorporationId: number | null
    factionId: number | null
  }

  export type AllianceMinAggregateOutputType = {
    id: number | null
    creatorCorporationId: number | null
    creatorId: number | null
    name: string | null
    dateFounded: Date | null
    executorCorporationId: number | null
    factionId: number | null
    ticker: string | null
  }

  export type AllianceMaxAggregateOutputType = {
    id: number | null
    creatorCorporationId: number | null
    creatorId: number | null
    name: string | null
    dateFounded: Date | null
    executorCorporationId: number | null
    factionId: number | null
    ticker: string | null
  }

  export type AllianceCountAggregateOutputType = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: number
    dateFounded: number
    executorCorporationId: number
    factionId: number
    ticker: number
    _all: number
  }


  export type AllianceAvgAggregateInputType = {
    id?: true
    creatorCorporationId?: true
    creatorId?: true
    executorCorporationId?: true
    factionId?: true
  }

  export type AllianceSumAggregateInputType = {
    id?: true
    creatorCorporationId?: true
    creatorId?: true
    executorCorporationId?: true
    factionId?: true
  }

  export type AllianceMinAggregateInputType = {
    id?: true
    creatorCorporationId?: true
    creatorId?: true
    name?: true
    dateFounded?: true
    executorCorporationId?: true
    factionId?: true
    ticker?: true
  }

  export type AllianceMaxAggregateInputType = {
    id?: true
    creatorCorporationId?: true
    creatorId?: true
    name?: true
    dateFounded?: true
    executorCorporationId?: true
    factionId?: true
    ticker?: true
  }

  export type AllianceCountAggregateInputType = {
    id?: true
    creatorCorporationId?: true
    creatorId?: true
    name?: true
    dateFounded?: true
    executorCorporationId?: true
    factionId?: true
    ticker?: true
    _all?: true
  }

  export type AllianceAggregateArgs = {
    /**
     * Filter which Alliance to aggregate.
     * 
    **/
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     * 
    **/
    orderBy?: Enumerable<AllianceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alliances
    **/
    _count?: true | AllianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllianceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllianceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllianceMaxAggregateInputType
  }

  export type GetAllianceAggregateType<T extends AllianceAggregateArgs> = {
        [P in keyof T & keyof AggregateAlliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlliance[P]>
      : GetScalarType<T[P], AggregateAlliance[P]>
  }




  export type AllianceGroupByArgs = {
    where?: AllianceWhereInput
    orderBy?: Enumerable<AllianceOrderByWithAggregationInput>
    by: Array<AllianceScalarFieldEnum>
    having?: AllianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllianceCountAggregateInputType | true
    _avg?: AllianceAvgAggregateInputType
    _sum?: AllianceSumAggregateInputType
    _min?: AllianceMinAggregateInputType
    _max?: AllianceMaxAggregateInputType
  }


  export type AllianceGroupByOutputType = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date
    executorCorporationId: number | null
    factionId: number | null
    ticker: string
    _count: AllianceCountAggregateOutputType | null
    _avg: AllianceAvgAggregateOutputType | null
    _sum: AllianceSumAggregateOutputType | null
    _min: AllianceMinAggregateOutputType | null
    _max: AllianceMaxAggregateOutputType | null
  }

  type GetAllianceGroupByPayload<T extends AllianceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AllianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllianceGroupByOutputType[P]>
            : GetScalarType<T[P], AllianceGroupByOutputType[P]>
        }
      >
    >


  export type AllianceSelect = {
    id?: boolean
    creatorCorporationId?: boolean
    creatorId?: boolean
    name?: boolean
    dateFounded?: boolean
    executorCorporationId?: boolean
    factionId?: boolean
    ticker?: boolean
    Corporation?: boolean | CorporationFindManyArgs
    Character?: boolean | CharacterFindManyArgs
    _count?: boolean | AllianceCountOutputTypeArgs
  }


  export type AllianceInclude = {
    Corporation?: boolean | CorporationFindManyArgs
    Character?: boolean | CharacterFindManyArgs
    _count?: boolean | AllianceCountOutputTypeArgs
  } 

  export type AllianceGetPayload<S extends boolean | null | undefined | AllianceArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Alliance :
    S extends undefined ? never :
    S extends { include: any } & (AllianceArgs | AllianceFindManyArgs)
    ? Alliance  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Corporation' ? Array < CorporationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Character' ? Array < CharacterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AllianceCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (AllianceArgs | AllianceFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Corporation' ? Array < CorporationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Character' ? Array < CharacterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AllianceCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Alliance ? Alliance[P] : never
  } 
      : Alliance


  type AllianceCountArgs = Merge<
    Omit<AllianceFindManyArgs, 'select' | 'include'> & {
      select?: AllianceCountAggregateInputType | true
    }
  >

  export interface AllianceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Alliance that matches the filter.
     * @param {AllianceFindUniqueArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AllianceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AllianceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alliance'> extends True ? Prisma__AllianceClient<AllianceGetPayload<T>> : Prisma__AllianceClient<AllianceGetPayload<T> | null, null>

    /**
     * Find the first Alliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindFirstArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AllianceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AllianceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alliance'> extends True ? Prisma__AllianceClient<AllianceGetPayload<T>> : Prisma__AllianceClient<AllianceGetPayload<T> | null, null>

    /**
     * Find zero or more Alliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alliances
     * const alliances = await prisma.alliance.findMany()
     * 
     * // Get first 10 Alliances
     * const alliances = await prisma.alliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allianceWithIdOnly = await prisma.alliance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AllianceFindManyArgs>(
      args?: SelectSubset<T, AllianceFindManyArgs>
    ): PrismaPromise<Array<AllianceGetPayload<T>>>

    /**
     * Create a Alliance.
     * @param {AllianceCreateArgs} args - Arguments to create a Alliance.
     * @example
     * // Create one Alliance
     * const Alliance = await prisma.alliance.create({
     *   data: {
     *     // ... data to create a Alliance
     *   }
     * })
     * 
    **/
    create<T extends AllianceCreateArgs>(
      args: SelectSubset<T, AllianceCreateArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Create many Alliances.
     *     @param {AllianceCreateManyArgs} args - Arguments to create many Alliances.
     *     @example
     *     // Create many Alliances
     *     const alliance = await prisma.alliance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AllianceCreateManyArgs>(
      args?: SelectSubset<T, AllianceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Alliance.
     * @param {AllianceDeleteArgs} args - Arguments to delete one Alliance.
     * @example
     * // Delete one Alliance
     * const Alliance = await prisma.alliance.delete({
     *   where: {
     *     // ... filter to delete one Alliance
     *   }
     * })
     * 
    **/
    delete<T extends AllianceDeleteArgs>(
      args: SelectSubset<T, AllianceDeleteArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Update one Alliance.
     * @param {AllianceUpdateArgs} args - Arguments to update one Alliance.
     * @example
     * // Update one Alliance
     * const alliance = await prisma.alliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AllianceUpdateArgs>(
      args: SelectSubset<T, AllianceUpdateArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Delete zero or more Alliances.
     * @param {AllianceDeleteManyArgs} args - Arguments to filter Alliances to delete.
     * @example
     * // Delete a few Alliances
     * const { count } = await prisma.alliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AllianceDeleteManyArgs>(
      args?: SelectSubset<T, AllianceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alliances
     * const alliance = await prisma.alliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AllianceUpdateManyArgs>(
      args: SelectSubset<T, AllianceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Alliance.
     * @param {AllianceUpsertArgs} args - Arguments to update or create a Alliance.
     * @example
     * // Update or create a Alliance
     * const alliance = await prisma.alliance.upsert({
     *   create: {
     *     // ... data to create a Alliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alliance we want to update
     *   }
     * })
    **/
    upsert<T extends AllianceUpsertArgs>(
      args: SelectSubset<T, AllianceUpsertArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Find one Alliance that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AllianceFindUniqueOrThrowArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AllianceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AllianceFindUniqueOrThrowArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Find the first Alliance that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceFindFirstOrThrowArgs} args - Arguments to find a Alliance
     * @example
     * // Get one Alliance
     * const alliance = await prisma.alliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AllianceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AllianceFindFirstOrThrowArgs>
    ): Prisma__AllianceClient<AllianceGetPayload<T>>

    /**
     * Count the number of Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceCountArgs} args - Arguments to filter Alliances to count.
     * @example
     * // Count the number of Alliances
     * const count = await prisma.alliance.count({
     *   where: {
     *     // ... the filter for the Alliances we want to count
     *   }
     * })
    **/
    count<T extends AllianceCountArgs>(
      args?: Subset<T, AllianceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllianceAggregateArgs>(args: Subset<T, AllianceAggregateArgs>): PrismaPromise<GetAllianceAggregateType<T>>

    /**
     * Group by Alliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllianceGroupByArgs['orderBy'] }
        : { orderBy?: AllianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllianceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AllianceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Corporation<T extends CorporationFindManyArgs= {}>(args?: Subset<T, CorporationFindManyArgs>): PrismaPromise<Array<CorporationGetPayload<T>>| Null>;

    Character<T extends CharacterFindManyArgs= {}>(args?: Subset<T, CharacterFindManyArgs>): PrismaPromise<Array<CharacterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alliance base type for findUnique actions
   */
  export type AllianceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * Filter, which Alliance to fetch.
     * 
    **/
    where: AllianceWhereUniqueInput
  }

  /**
   * Alliance: findUnique
   */
  export interface AllianceFindUniqueArgs extends AllianceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alliance base type for findFirst actions
   */
  export type AllianceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * Filter, which Alliance to fetch.
     * 
    **/
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     * 
    **/
    orderBy?: Enumerable<AllianceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alliances.
     * 
    **/
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alliances.
     * 
    **/
    distinct?: Enumerable<AllianceScalarFieldEnum>
  }

  /**
   * Alliance: findFirst
   */
  export interface AllianceFindFirstArgs extends AllianceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alliance findMany
   */
  export type AllianceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * Filter, which Alliances to fetch.
     * 
    **/
    where?: AllianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alliances to fetch.
     * 
    **/
    orderBy?: Enumerable<AllianceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alliances.
     * 
    **/
    cursor?: AllianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alliances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alliances.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AllianceScalarFieldEnum>
  }


  /**
   * Alliance create
   */
  export type AllianceCreateArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * The data needed to create a Alliance.
     * 
    **/
    data: XOR<AllianceCreateInput, AllianceUncheckedCreateInput>
  }


  /**
   * Alliance createMany
   */
  export type AllianceCreateManyArgs = {
    /**
     * The data used to create many Alliances.
     * 
    **/
    data: Enumerable<AllianceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alliance update
   */
  export type AllianceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * The data needed to update a Alliance.
     * 
    **/
    data: XOR<AllianceUpdateInput, AllianceUncheckedUpdateInput>
    /**
     * Choose, which Alliance to update.
     * 
    **/
    where: AllianceWhereUniqueInput
  }


  /**
   * Alliance updateMany
   */
  export type AllianceUpdateManyArgs = {
    /**
     * The data used to update Alliances.
     * 
    **/
    data: XOR<AllianceUpdateManyMutationInput, AllianceUncheckedUpdateManyInput>
    /**
     * Filter which Alliances to update
     * 
    **/
    where?: AllianceWhereInput
  }


  /**
   * Alliance upsert
   */
  export type AllianceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * The filter to search for the Alliance to update in case it exists.
     * 
    **/
    where: AllianceWhereUniqueInput
    /**
     * In case the Alliance found by the `where` argument doesn't exist, create a new Alliance with this data.
     * 
    **/
    create: XOR<AllianceCreateInput, AllianceUncheckedCreateInput>
    /**
     * In case the Alliance was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AllianceUpdateInput, AllianceUncheckedUpdateInput>
  }


  /**
   * Alliance delete
   */
  export type AllianceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
    /**
     * Filter which Alliance to delete.
     * 
    **/
    where: AllianceWhereUniqueInput
  }


  /**
   * Alliance deleteMany
   */
  export type AllianceDeleteManyArgs = {
    /**
     * Filter which Alliances to delete
     * 
    **/
    where?: AllianceWhereInput
  }


  /**
   * Alliance: findUniqueOrThrow
   */
  export type AllianceFindUniqueOrThrowArgs = AllianceFindUniqueArgsBase
      

  /**
   * Alliance: findFirstOrThrow
   */
  export type AllianceFindFirstOrThrowArgs = AllianceFindFirstArgsBase
      

  /**
   * Alliance without action
   */
  export type AllianceArgs = {
    /**
     * Select specific fields to fetch from the Alliance
     * 
    **/
    select?: AllianceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AllianceInclude | null
  }



  /**
   * Model Corporation
   */


  export type AggregateCorporation = {
    _count: CorporationCountAggregateOutputType | null
    _avg: CorporationAvgAggregateOutputType | null
    _sum: CorporationSumAggregateOutputType | null
    _min: CorporationMinAggregateOutputType | null
    _max: CorporationMaxAggregateOutputType | null
  }

  export type CorporationAvgAggregateOutputType = {
    id: number | null
    allianceId: number | null
    ceoId: number | null
    creatorId: number | null
    factionId: number | null
    homeStationId: number | null
    memberCount: number | null
    shares: number | null
    taxRate: Decimal | null
  }

  export type CorporationSumAggregateOutputType = {
    id: number | null
    allianceId: number | null
    ceoId: number | null
    creatorId: number | null
    factionId: number | null
    homeStationId: number | null
    memberCount: number | null
    shares: number | null
    taxRate: Decimal | null
  }

  export type CorporationMinAggregateOutputType = {
    id: number | null
    allianceId: number | null
    ceoId: number | null
    creatorId: number | null
    dateFounded: Date | null
    description: string | null
    factionId: number | null
    homeStationId: number | null
    memberCount: number | null
    name: string | null
    shares: number | null
    taxRate: Decimal | null
    ticker: string | null
    url: string | null
    warEligible: boolean | null
  }

  export type CorporationMaxAggregateOutputType = {
    id: number | null
    allianceId: number | null
    ceoId: number | null
    creatorId: number | null
    dateFounded: Date | null
    description: string | null
    factionId: number | null
    homeStationId: number | null
    memberCount: number | null
    name: string | null
    shares: number | null
    taxRate: Decimal | null
    ticker: string | null
    url: string | null
    warEligible: boolean | null
  }

  export type CorporationCountAggregateOutputType = {
    id: number
    allianceId: number
    ceoId: number
    creatorId: number
    dateFounded: number
    description: number
    factionId: number
    homeStationId: number
    memberCount: number
    name: number
    shares: number
    taxRate: number
    ticker: number
    url: number
    warEligible: number
    _all: number
  }


  export type CorporationAvgAggregateInputType = {
    id?: true
    allianceId?: true
    ceoId?: true
    creatorId?: true
    factionId?: true
    homeStationId?: true
    memberCount?: true
    shares?: true
    taxRate?: true
  }

  export type CorporationSumAggregateInputType = {
    id?: true
    allianceId?: true
    ceoId?: true
    creatorId?: true
    factionId?: true
    homeStationId?: true
    memberCount?: true
    shares?: true
    taxRate?: true
  }

  export type CorporationMinAggregateInputType = {
    id?: true
    allianceId?: true
    ceoId?: true
    creatorId?: true
    dateFounded?: true
    description?: true
    factionId?: true
    homeStationId?: true
    memberCount?: true
    name?: true
    shares?: true
    taxRate?: true
    ticker?: true
    url?: true
    warEligible?: true
  }

  export type CorporationMaxAggregateInputType = {
    id?: true
    allianceId?: true
    ceoId?: true
    creatorId?: true
    dateFounded?: true
    description?: true
    factionId?: true
    homeStationId?: true
    memberCount?: true
    name?: true
    shares?: true
    taxRate?: true
    ticker?: true
    url?: true
    warEligible?: true
  }

  export type CorporationCountAggregateInputType = {
    id?: true
    allianceId?: true
    ceoId?: true
    creatorId?: true
    dateFounded?: true
    description?: true
    factionId?: true
    homeStationId?: true
    memberCount?: true
    name?: true
    shares?: true
    taxRate?: true
    ticker?: true
    url?: true
    warEligible?: true
    _all?: true
  }

  export type CorporationAggregateArgs = {
    /**
     * Filter which Corporation to aggregate.
     * 
    **/
    where?: CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corporations to fetch.
     * 
    **/
    orderBy?: Enumerable<CorporationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corporations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Corporations
    **/
    _count?: true | CorporationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporationMaxAggregateInputType
  }

  export type GetCorporationAggregateType<T extends CorporationAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporation[P]>
      : GetScalarType<T[P], AggregateCorporation[P]>
  }




  export type CorporationGroupByArgs = {
    where?: CorporationWhereInput
    orderBy?: Enumerable<CorporationOrderByWithAggregationInput>
    by: Array<CorporationScalarFieldEnum>
    having?: CorporationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporationCountAggregateInputType | true
    _avg?: CorporationAvgAggregateInputType
    _sum?: CorporationSumAggregateInputType
    _min?: CorporationMinAggregateInputType
    _max?: CorporationMaxAggregateInputType
  }


  export type CorporationGroupByOutputType = {
    id: number
    allianceId: number | null
    ceoId: number
    creatorId: number
    dateFounded: Date | null
    description: string | null
    factionId: number | null
    homeStationId: number | null
    memberCount: number
    name: string
    shares: number | null
    taxRate: Decimal
    ticker: string
    url: string | null
    warEligible: boolean
    _count: CorporationCountAggregateOutputType | null
    _avg: CorporationAvgAggregateOutputType | null
    _sum: CorporationSumAggregateOutputType | null
    _min: CorporationMinAggregateOutputType | null
    _max: CorporationMaxAggregateOutputType | null
  }

  type GetCorporationGroupByPayload<T extends CorporationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CorporationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporationGroupByOutputType[P]>
            : GetScalarType<T[P], CorporationGroupByOutputType[P]>
        }
      >
    >


  export type CorporationSelect = {
    id?: boolean
    allianceId?: boolean
    alliance?: boolean | AllianceArgs
    ceoId?: boolean
    creatorId?: boolean
    dateFounded?: boolean
    description?: boolean
    factionId?: boolean
    homeStationId?: boolean
    memberCount?: boolean
    name?: boolean
    shares?: boolean
    taxRate?: boolean
    ticker?: boolean
    url?: boolean
    warEligible?: boolean
    Character?: boolean | CharacterFindManyArgs
    _count?: boolean | CorporationCountOutputTypeArgs
  }


  export type CorporationInclude = {
    alliance?: boolean | AllianceArgs
    Character?: boolean | CharacterFindManyArgs
    _count?: boolean | CorporationCountOutputTypeArgs
  } 

  export type CorporationGetPayload<S extends boolean | null | undefined | CorporationArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Corporation :
    S extends undefined ? never :
    S extends { include: any } & (CorporationArgs | CorporationFindManyArgs)
    ? Corporation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'alliance' ? AllianceGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Character' ? Array < CharacterGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CorporationCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (CorporationArgs | CorporationFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'alliance' ? AllianceGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Character' ? Array < CharacterGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CorporationCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Corporation ? Corporation[P] : never
  } 
      : Corporation


  type CorporationCountArgs = Merge<
    Omit<CorporationFindManyArgs, 'select' | 'include'> & {
      select?: CorporationCountAggregateInputType | true
    }
  >

  export interface CorporationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Corporation that matches the filter.
     * @param {CorporationFindUniqueArgs} args - Arguments to find a Corporation
     * @example
     * // Get one Corporation
     * const corporation = await prisma.corporation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CorporationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CorporationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Corporation'> extends True ? Prisma__CorporationClient<CorporationGetPayload<T>> : Prisma__CorporationClient<CorporationGetPayload<T> | null, null>

    /**
     * Find the first Corporation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationFindFirstArgs} args - Arguments to find a Corporation
     * @example
     * // Get one Corporation
     * const corporation = await prisma.corporation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CorporationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CorporationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Corporation'> extends True ? Prisma__CorporationClient<CorporationGetPayload<T>> : Prisma__CorporationClient<CorporationGetPayload<T> | null, null>

    /**
     * Find zero or more Corporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Corporations
     * const corporations = await prisma.corporation.findMany()
     * 
     * // Get first 10 Corporations
     * const corporations = await prisma.corporation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporationWithIdOnly = await prisma.corporation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CorporationFindManyArgs>(
      args?: SelectSubset<T, CorporationFindManyArgs>
    ): PrismaPromise<Array<CorporationGetPayload<T>>>

    /**
     * Create a Corporation.
     * @param {CorporationCreateArgs} args - Arguments to create a Corporation.
     * @example
     * // Create one Corporation
     * const Corporation = await prisma.corporation.create({
     *   data: {
     *     // ... data to create a Corporation
     *   }
     * })
     * 
    **/
    create<T extends CorporationCreateArgs>(
      args: SelectSubset<T, CorporationCreateArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Create many Corporations.
     *     @param {CorporationCreateManyArgs} args - Arguments to create many Corporations.
     *     @example
     *     // Create many Corporations
     *     const corporation = await prisma.corporation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CorporationCreateManyArgs>(
      args?: SelectSubset<T, CorporationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Corporation.
     * @param {CorporationDeleteArgs} args - Arguments to delete one Corporation.
     * @example
     * // Delete one Corporation
     * const Corporation = await prisma.corporation.delete({
     *   where: {
     *     // ... filter to delete one Corporation
     *   }
     * })
     * 
    **/
    delete<T extends CorporationDeleteArgs>(
      args: SelectSubset<T, CorporationDeleteArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Update one Corporation.
     * @param {CorporationUpdateArgs} args - Arguments to update one Corporation.
     * @example
     * // Update one Corporation
     * const corporation = await prisma.corporation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CorporationUpdateArgs>(
      args: SelectSubset<T, CorporationUpdateArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Delete zero or more Corporations.
     * @param {CorporationDeleteManyArgs} args - Arguments to filter Corporations to delete.
     * @example
     * // Delete a few Corporations
     * const { count } = await prisma.corporation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CorporationDeleteManyArgs>(
      args?: SelectSubset<T, CorporationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Corporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Corporations
     * const corporation = await prisma.corporation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CorporationUpdateManyArgs>(
      args: SelectSubset<T, CorporationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Corporation.
     * @param {CorporationUpsertArgs} args - Arguments to update or create a Corporation.
     * @example
     * // Update or create a Corporation
     * const corporation = await prisma.corporation.upsert({
     *   create: {
     *     // ... data to create a Corporation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Corporation we want to update
     *   }
     * })
    **/
    upsert<T extends CorporationUpsertArgs>(
      args: SelectSubset<T, CorporationUpsertArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Find one Corporation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CorporationFindUniqueOrThrowArgs} args - Arguments to find a Corporation
     * @example
     * // Get one Corporation
     * const corporation = await prisma.corporation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CorporationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CorporationFindUniqueOrThrowArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Find the first Corporation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationFindFirstOrThrowArgs} args - Arguments to find a Corporation
     * @example
     * // Get one Corporation
     * const corporation = await prisma.corporation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CorporationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CorporationFindFirstOrThrowArgs>
    ): Prisma__CorporationClient<CorporationGetPayload<T>>

    /**
     * Count the number of Corporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationCountArgs} args - Arguments to filter Corporations to count.
     * @example
     * // Count the number of Corporations
     * const count = await prisma.corporation.count({
     *   where: {
     *     // ... the filter for the Corporations we want to count
     *   }
     * })
    **/
    count<T extends CorporationCountArgs>(
      args?: Subset<T, CorporationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Corporation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporationAggregateArgs>(args: Subset<T, CorporationAggregateArgs>): PrismaPromise<GetCorporationAggregateType<T>>

    /**
     * Group by Corporation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporationGroupByArgs['orderBy'] }
        : { orderBy?: CorporationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Corporation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CorporationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    alliance<T extends AllianceArgs= {}>(args?: Subset<T, AllianceArgs>): Prisma__AllianceClient<AllianceGetPayload<T> | Null>;

    Character<T extends CharacterFindManyArgs= {}>(args?: Subset<T, CharacterFindManyArgs>): PrismaPromise<Array<CharacterGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Corporation base type for findUnique actions
   */
  export type CorporationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * Filter, which Corporation to fetch.
     * 
    **/
    where: CorporationWhereUniqueInput
  }

  /**
   * Corporation: findUnique
   */
  export interface CorporationFindUniqueArgs extends CorporationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Corporation base type for findFirst actions
   */
  export type CorporationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * Filter, which Corporation to fetch.
     * 
    **/
    where?: CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corporations to fetch.
     * 
    **/
    orderBy?: Enumerable<CorporationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Corporations.
     * 
    **/
    cursor?: CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corporations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Corporations.
     * 
    **/
    distinct?: Enumerable<CorporationScalarFieldEnum>
  }

  /**
   * Corporation: findFirst
   */
  export interface CorporationFindFirstArgs extends CorporationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Corporation findMany
   */
  export type CorporationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * Filter, which Corporations to fetch.
     * 
    **/
    where?: CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Corporations to fetch.
     * 
    **/
    orderBy?: Enumerable<CorporationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Corporations.
     * 
    **/
    cursor?: CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Corporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Corporations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CorporationScalarFieldEnum>
  }


  /**
   * Corporation create
   */
  export type CorporationCreateArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * The data needed to create a Corporation.
     * 
    **/
    data: XOR<CorporationCreateInput, CorporationUncheckedCreateInput>
  }


  /**
   * Corporation createMany
   */
  export type CorporationCreateManyArgs = {
    /**
     * The data used to create many Corporations.
     * 
    **/
    data: Enumerable<CorporationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Corporation update
   */
  export type CorporationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * The data needed to update a Corporation.
     * 
    **/
    data: XOR<CorporationUpdateInput, CorporationUncheckedUpdateInput>
    /**
     * Choose, which Corporation to update.
     * 
    **/
    where: CorporationWhereUniqueInput
  }


  /**
   * Corporation updateMany
   */
  export type CorporationUpdateManyArgs = {
    /**
     * The data used to update Corporations.
     * 
    **/
    data: XOR<CorporationUpdateManyMutationInput, CorporationUncheckedUpdateManyInput>
    /**
     * Filter which Corporations to update
     * 
    **/
    where?: CorporationWhereInput
  }


  /**
   * Corporation upsert
   */
  export type CorporationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * The filter to search for the Corporation to update in case it exists.
     * 
    **/
    where: CorporationWhereUniqueInput
    /**
     * In case the Corporation found by the `where` argument doesn't exist, create a new Corporation with this data.
     * 
    **/
    create: XOR<CorporationCreateInput, CorporationUncheckedCreateInput>
    /**
     * In case the Corporation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CorporationUpdateInput, CorporationUncheckedUpdateInput>
  }


  /**
   * Corporation delete
   */
  export type CorporationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
    /**
     * Filter which Corporation to delete.
     * 
    **/
    where: CorporationWhereUniqueInput
  }


  /**
   * Corporation deleteMany
   */
  export type CorporationDeleteManyArgs = {
    /**
     * Filter which Corporations to delete
     * 
    **/
    where?: CorporationWhereInput
  }


  /**
   * Corporation: findUniqueOrThrow
   */
  export type CorporationFindUniqueOrThrowArgs = CorporationFindUniqueArgsBase
      

  /**
   * Corporation: findFirstOrThrow
   */
  export type CorporationFindFirstOrThrowArgs = CorporationFindFirstArgsBase
      

  /**
   * Corporation without action
   */
  export type CorporationArgs = {
    /**
     * Select specific fields to fetch from the Corporation
     * 
    **/
    select?: CorporationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CorporationInclude | null
  }



  /**
   * Model agtAgentTypes
   */


  export type AggregateAgtAgentTypes = {
    _count: AgtAgentTypesCountAggregateOutputType | null
    _avg: AgtAgentTypesAvgAggregateOutputType | null
    _sum: AgtAgentTypesSumAggregateOutputType | null
    _min: AgtAgentTypesMinAggregateOutputType | null
    _max: AgtAgentTypesMaxAggregateOutputType | null
  }

  export type AgtAgentTypesAvgAggregateOutputType = {
    agentTypeID: number | null
  }

  export type AgtAgentTypesSumAggregateOutputType = {
    agentTypeID: number | null
  }

  export type AgtAgentTypesMinAggregateOutputType = {
    agentTypeID: number | null
    agentType: string | null
  }

  export type AgtAgentTypesMaxAggregateOutputType = {
    agentTypeID: number | null
    agentType: string | null
  }

  export type AgtAgentTypesCountAggregateOutputType = {
    agentTypeID: number
    agentType: number
    _all: number
  }


  export type AgtAgentTypesAvgAggregateInputType = {
    agentTypeID?: true
  }

  export type AgtAgentTypesSumAggregateInputType = {
    agentTypeID?: true
  }

  export type AgtAgentTypesMinAggregateInputType = {
    agentTypeID?: true
    agentType?: true
  }

  export type AgtAgentTypesMaxAggregateInputType = {
    agentTypeID?: true
    agentType?: true
  }

  export type AgtAgentTypesCountAggregateInputType = {
    agentTypeID?: true
    agentType?: true
    _all?: true
  }

  export type AgtAgentTypesAggregateArgs = {
    /**
     * Filter which agtAgentTypes to aggregate.
     * 
    **/
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgentTypes
    **/
    _count?: true | AgtAgentTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentTypesMaxAggregateInputType
  }

  export type GetAgtAgentTypesAggregateType<T extends AgtAgentTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgentTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgentTypes[P]>
      : GetScalarType<T[P], AggregateAgtAgentTypes[P]>
  }




  export type AgtAgentTypesGroupByArgs = {
    where?: agtAgentTypesWhereInput
    orderBy?: Enumerable<agtAgentTypesOrderByWithAggregationInput>
    by: Array<AgtAgentTypesScalarFieldEnum>
    having?: agtAgentTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentTypesCountAggregateInputType | true
    _avg?: AgtAgentTypesAvgAggregateInputType
    _sum?: AgtAgentTypesSumAggregateInputType
    _min?: AgtAgentTypesMinAggregateInputType
    _max?: AgtAgentTypesMaxAggregateInputType
  }


  export type AgtAgentTypesGroupByOutputType = {
    agentTypeID: number
    agentType: string | null
    _count: AgtAgentTypesCountAggregateOutputType | null
    _avg: AgtAgentTypesAvgAggregateOutputType | null
    _sum: AgtAgentTypesSumAggregateOutputType | null
    _min: AgtAgentTypesMinAggregateOutputType | null
    _max: AgtAgentTypesMaxAggregateOutputType | null
  }

  type GetAgtAgentTypesGroupByPayload<T extends AgtAgentTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgtAgentTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentTypesGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentTypesGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentTypesSelect = {
    agentTypeID?: boolean
    agentType?: boolean
  }


  export type agtAgentTypesGetPayload<S extends boolean | null | undefined | agtAgentTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? agtAgentTypes :
    S extends undefined ? never :
    S extends { include: any } & (agtAgentTypesArgs | agtAgentTypesFindManyArgs)
    ? agtAgentTypes 
    : S extends { select: any } & (agtAgentTypesArgs | agtAgentTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof agtAgentTypes ? agtAgentTypes[P] : never
  } 
      : agtAgentTypes


  type agtAgentTypesCountArgs = Merge<
    Omit<agtAgentTypesFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentTypesCountAggregateInputType | true
    }
  >

  export interface agtAgentTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AgtAgentTypes that matches the filter.
     * @param {agtAgentTypesFindUniqueArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, agtAgentTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'agtAgentTypes'> extends True ? Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>> : Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T> | null, null>

    /**
     * Find the first AgtAgentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindFirstArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, agtAgentTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'agtAgentTypes'> extends True ? Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>> : Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T> | null, null>

    /**
     * Find zero or more AgtAgentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
     * 
     * // Get first 10 AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findMany({ take: 10 })
     * 
     * // Only select the `agentTypeID`
     * const agtAgentTypesWithAgentTypeIDOnly = await prisma.agtAgentTypes.findMany({ select: { agentTypeID: true } })
     * 
    **/
    findMany<T extends agtAgentTypesFindManyArgs>(
      args?: SelectSubset<T, agtAgentTypesFindManyArgs>
    ): PrismaPromise<Array<agtAgentTypesGetPayload<T>>>

    /**
     * Create a AgtAgentTypes.
     * @param {agtAgentTypesCreateArgs} args - Arguments to create a AgtAgentTypes.
     * @example
     * // Create one AgtAgentTypes
     * const AgtAgentTypes = await prisma.agtAgentTypes.create({
     *   data: {
     *     // ... data to create a AgtAgentTypes
     *   }
     * })
     * 
    **/
    create<T extends agtAgentTypesCreateArgs>(
      args: SelectSubset<T, agtAgentTypesCreateArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Create many AgtAgentTypes.
     *     @param {agtAgentTypesCreateManyArgs} args - Arguments to create many AgtAgentTypes.
     *     @example
     *     // Create many AgtAgentTypes
     *     const agtAgentTypes = await prisma.agtAgentTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentTypesCreateManyArgs>(
      args?: SelectSubset<T, agtAgentTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgentTypes.
     * @param {agtAgentTypesDeleteArgs} args - Arguments to delete one AgtAgentTypes.
     * @example
     * // Delete one AgtAgentTypes
     * const AgtAgentTypes = await prisma.agtAgentTypes.delete({
     *   where: {
     *     // ... filter to delete one AgtAgentTypes
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentTypesDeleteArgs>(
      args: SelectSubset<T, agtAgentTypesDeleteArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Update one AgtAgentTypes.
     * @param {agtAgentTypesUpdateArgs} args - Arguments to update one AgtAgentTypes.
     * @example
     * // Update one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentTypesUpdateArgs>(
      args: SelectSubset<T, agtAgentTypesUpdateArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Delete zero or more AgtAgentTypes.
     * @param {agtAgentTypesDeleteManyArgs} args - Arguments to filter AgtAgentTypes to delete.
     * @example
     * // Delete a few AgtAgentTypes
     * const { count } = await prisma.agtAgentTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentTypesDeleteManyArgs>(
      args?: SelectSubset<T, agtAgentTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentTypesUpdateManyArgs>(
      args: SelectSubset<T, agtAgentTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgentTypes.
     * @param {agtAgentTypesUpsertArgs} args - Arguments to update or create a AgtAgentTypes.
     * @example
     * // Update or create a AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.upsert({
     *   create: {
     *     // ... data to create a AgtAgentTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgentTypes we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentTypesUpsertArgs>(
      args: SelectSubset<T, agtAgentTypesUpsertArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Find one AgtAgentTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {agtAgentTypesFindUniqueOrThrowArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, agtAgentTypesFindUniqueOrThrowArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Find the first AgtAgentTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindFirstOrThrowArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agtAgentTypesFindFirstOrThrowArgs>
    ): Prisma__agtAgentTypesClient<agtAgentTypesGetPayload<T>>

    /**
     * Count the number of AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesCountArgs} args - Arguments to filter AgtAgentTypes to count.
     * @example
     * // Count the number of AgtAgentTypes
     * const count = await prisma.agtAgentTypes.count({
     *   where: {
     *     // ... the filter for the AgtAgentTypes we want to count
     *   }
     * })
    **/
    count<T extends agtAgentTypesCountArgs>(
      args?: Subset<T, agtAgentTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentTypesAggregateArgs>(args: Subset<T, AgtAgentTypesAggregateArgs>): PrismaPromise<GetAgtAgentTypesAggregateType<T>>

    /**
     * Group by AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgtAgentTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgtAgentTypesGroupByArgs['orderBy'] }
        : { orderBy?: AgtAgentTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgtAgentTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgentTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__agtAgentTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * agtAgentTypes base type for findUnique actions
   */
  export type agtAgentTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * Filter, which agtAgentTypes to fetch.
     * 
    **/
    where: agtAgentTypesWhereUniqueInput
  }

  /**
   * agtAgentTypes: findUnique
   */
  export interface agtAgentTypesFindUniqueArgs extends agtAgentTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgentTypes base type for findFirst actions
   */
  export type agtAgentTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * Filter, which agtAgentTypes to fetch.
     * 
    **/
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentTypes.
     * 
    **/
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentTypes.
     * 
    **/
    distinct?: Enumerable<AgtAgentTypesScalarFieldEnum>
  }

  /**
   * agtAgentTypes: findFirst
   */
  export interface agtAgentTypesFindFirstArgs extends agtAgentTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgentTypes findMany
   */
  export type agtAgentTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * Filter, which agtAgentTypes to fetch.
     * 
    **/
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgentTypes.
     * 
    **/
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgtAgentTypesScalarFieldEnum>
  }


  /**
   * agtAgentTypes create
   */
  export type agtAgentTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * The data needed to create a agtAgentTypes.
     * 
    **/
    data: XOR<agtAgentTypesCreateInput, agtAgentTypesUncheckedCreateInput>
  }


  /**
   * agtAgentTypes createMany
   */
  export type agtAgentTypesCreateManyArgs = {
    /**
     * The data used to create many agtAgentTypes.
     * 
    **/
    data: Enumerable<agtAgentTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * agtAgentTypes update
   */
  export type agtAgentTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * The data needed to update a agtAgentTypes.
     * 
    **/
    data: XOR<agtAgentTypesUpdateInput, agtAgentTypesUncheckedUpdateInput>
    /**
     * Choose, which agtAgentTypes to update.
     * 
    **/
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes updateMany
   */
  export type agtAgentTypesUpdateManyArgs = {
    /**
     * The data used to update agtAgentTypes.
     * 
    **/
    data: XOR<agtAgentTypesUpdateManyMutationInput, agtAgentTypesUncheckedUpdateManyInput>
    /**
     * Filter which agtAgentTypes to update
     * 
    **/
    where?: agtAgentTypesWhereInput
  }


  /**
   * agtAgentTypes upsert
   */
  export type agtAgentTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * The filter to search for the agtAgentTypes to update in case it exists.
     * 
    **/
    where: agtAgentTypesWhereUniqueInput
    /**
     * In case the agtAgentTypes found by the `where` argument doesn't exist, create a new agtAgentTypes with this data.
     * 
    **/
    create: XOR<agtAgentTypesCreateInput, agtAgentTypesUncheckedCreateInput>
    /**
     * In case the agtAgentTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<agtAgentTypesUpdateInput, agtAgentTypesUncheckedUpdateInput>
  }


  /**
   * agtAgentTypes delete
   */
  export type agtAgentTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
    /**
     * Filter which agtAgentTypes to delete.
     * 
    **/
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes deleteMany
   */
  export type agtAgentTypesDeleteManyArgs = {
    /**
     * Filter which agtAgentTypes to delete
     * 
    **/
    where?: agtAgentTypesWhereInput
  }


  /**
   * agtAgentTypes: findUniqueOrThrow
   */
  export type agtAgentTypesFindUniqueOrThrowArgs = agtAgentTypesFindUniqueArgsBase
      

  /**
   * agtAgentTypes: findFirstOrThrow
   */
  export type agtAgentTypesFindFirstOrThrowArgs = agtAgentTypesFindFirstArgsBase
      

  /**
   * agtAgentTypes without action
   */
  export type agtAgentTypesArgs = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     * 
    **/
    select?: agtAgentTypesSelect | null
  }



  /**
   * Model agtAgents
   */


  export type AggregateAgtAgents = {
    _count: AgtAgentsCountAggregateOutputType | null
    _avg: AgtAgentsAvgAggregateOutputType | null
    _sum: AgtAgentsSumAggregateOutputType | null
    _min: AgtAgentsMinAggregateOutputType | null
    _max: AgtAgentsMaxAggregateOutputType | null
  }

  export type AgtAgentsAvgAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
  }

  export type AgtAgentsSumAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
  }

  export type AgtAgentsMinAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
  }

  export type AgtAgentsMaxAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
  }

  export type AgtAgentsCountAggregateOutputType = {
    agentID: number
    divisionID: number
    corporationID: number
    locationID: number
    level: number
    quality: number
    agentTypeID: number
    isLocator: number
    _all: number
  }


  export type AgtAgentsAvgAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
  }

  export type AgtAgentsSumAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
  }

  export type AgtAgentsMinAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
  }

  export type AgtAgentsMaxAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
  }

  export type AgtAgentsCountAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
    _all?: true
  }

  export type AgtAgentsAggregateArgs = {
    /**
     * Filter which agtAgents to aggregate.
     * 
    **/
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgents
    **/
    _count?: true | AgtAgentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentsMaxAggregateInputType
  }

  export type GetAgtAgentsAggregateType<T extends AgtAgentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgents[P]>
      : GetScalarType<T[P], AggregateAgtAgents[P]>
  }




  export type AgtAgentsGroupByArgs = {
    where?: agtAgentsWhereInput
    orderBy?: Enumerable<agtAgentsOrderByWithAggregationInput>
    by: Array<AgtAgentsScalarFieldEnum>
    having?: agtAgentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentsCountAggregateInputType | true
    _avg?: AgtAgentsAvgAggregateInputType
    _sum?: AgtAgentsSumAggregateInputType
    _min?: AgtAgentsMinAggregateInputType
    _max?: AgtAgentsMaxAggregateInputType
  }


  export type AgtAgentsGroupByOutputType = {
    agentID: number
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
    _count: AgtAgentsCountAggregateOutputType | null
    _avg: AgtAgentsAvgAggregateOutputType | null
    _sum: AgtAgentsSumAggregateOutputType | null
    _min: AgtAgentsMinAggregateOutputType | null
    _max: AgtAgentsMaxAggregateOutputType | null
  }

  type GetAgtAgentsGroupByPayload<T extends AgtAgentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgtAgentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentsGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentsGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentsSelect = {
    agentID?: boolean
    divisionID?: boolean
    corporationID?: boolean
    locationID?: boolean
    level?: boolean
    quality?: boolean
    agentTypeID?: boolean
    isLocator?: boolean
  }


  export type agtAgentsGetPayload<S extends boolean | null | undefined | agtAgentsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? agtAgents :
    S extends undefined ? never :
    S extends { include: any } & (agtAgentsArgs | agtAgentsFindManyArgs)
    ? agtAgents 
    : S extends { select: any } & (agtAgentsArgs | agtAgentsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof agtAgents ? agtAgents[P] : never
  } 
      : agtAgents


  type agtAgentsCountArgs = Merge<
    Omit<agtAgentsFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentsCountAggregateInputType | true
    }
  >

  export interface agtAgentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AgtAgents that matches the filter.
     * @param {agtAgentsFindUniqueArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, agtAgentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'agtAgents'> extends True ? Prisma__agtAgentsClient<agtAgentsGetPayload<T>> : Prisma__agtAgentsClient<agtAgentsGetPayload<T> | null, null>

    /**
     * Find the first AgtAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindFirstArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, agtAgentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'agtAgents'> extends True ? Prisma__agtAgentsClient<agtAgentsGetPayload<T>> : Prisma__agtAgentsClient<agtAgentsGetPayload<T> | null, null>

    /**
     * Find zero or more AgtAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgents
     * const agtAgents = await prisma.agtAgents.findMany()
     * 
     * // Get first 10 AgtAgents
     * const agtAgents = await prisma.agtAgents.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtAgentsWithAgentIDOnly = await prisma.agtAgents.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtAgentsFindManyArgs>(
      args?: SelectSubset<T, agtAgentsFindManyArgs>
    ): PrismaPromise<Array<agtAgentsGetPayload<T>>>

    /**
     * Create a AgtAgents.
     * @param {agtAgentsCreateArgs} args - Arguments to create a AgtAgents.
     * @example
     * // Create one AgtAgents
     * const AgtAgents = await prisma.agtAgents.create({
     *   data: {
     *     // ... data to create a AgtAgents
     *   }
     * })
     * 
    **/
    create<T extends agtAgentsCreateArgs>(
      args: SelectSubset<T, agtAgentsCreateArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Create many AgtAgents.
     *     @param {agtAgentsCreateManyArgs} args - Arguments to create many AgtAgents.
     *     @example
     *     // Create many AgtAgents
     *     const agtAgents = await prisma.agtAgents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentsCreateManyArgs>(
      args?: SelectSubset<T, agtAgentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgents.
     * @param {agtAgentsDeleteArgs} args - Arguments to delete one AgtAgents.
     * @example
     * // Delete one AgtAgents
     * const AgtAgents = await prisma.agtAgents.delete({
     *   where: {
     *     // ... filter to delete one AgtAgents
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentsDeleteArgs>(
      args: SelectSubset<T, agtAgentsDeleteArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Update one AgtAgents.
     * @param {agtAgentsUpdateArgs} args - Arguments to update one AgtAgents.
     * @example
     * // Update one AgtAgents
     * const agtAgents = await prisma.agtAgents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentsUpdateArgs>(
      args: SelectSubset<T, agtAgentsUpdateArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Delete zero or more AgtAgents.
     * @param {agtAgentsDeleteManyArgs} args - Arguments to filter AgtAgents to delete.
     * @example
     * // Delete a few AgtAgents
     * const { count } = await prisma.agtAgents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentsDeleteManyArgs>(
      args?: SelectSubset<T, agtAgentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgents
     * const agtAgents = await prisma.agtAgents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentsUpdateManyArgs>(
      args: SelectSubset<T, agtAgentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgents.
     * @param {agtAgentsUpsertArgs} args - Arguments to update or create a AgtAgents.
     * @example
     * // Update or create a AgtAgents
     * const agtAgents = await prisma.agtAgents.upsert({
     *   create: {
     *     // ... data to create a AgtAgents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgents we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentsUpsertArgs>(
      args: SelectSubset<T, agtAgentsUpsertArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Find one AgtAgents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {agtAgentsFindUniqueOrThrowArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, agtAgentsFindUniqueOrThrowArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Find the first AgtAgents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindFirstOrThrowArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agtAgentsFindFirstOrThrowArgs>
    ): Prisma__agtAgentsClient<agtAgentsGetPayload<T>>

    /**
     * Count the number of AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsCountArgs} args - Arguments to filter AgtAgents to count.
     * @example
     * // Count the number of AgtAgents
     * const count = await prisma.agtAgents.count({
     *   where: {
     *     // ... the filter for the AgtAgents we want to count
     *   }
     * })
    **/
    count<T extends agtAgentsCountArgs>(
      args?: Subset<T, agtAgentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentsAggregateArgs>(args: Subset<T, AgtAgentsAggregateArgs>): PrismaPromise<GetAgtAgentsAggregateType<T>>

    /**
     * Group by AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgtAgentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgtAgentsGroupByArgs['orderBy'] }
        : { orderBy?: AgtAgentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgtAgentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__agtAgentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * agtAgents base type for findUnique actions
   */
  export type agtAgentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * Filter, which agtAgents to fetch.
     * 
    **/
    where: agtAgentsWhereUniqueInput
  }

  /**
   * agtAgents: findUnique
   */
  export interface agtAgentsFindUniqueArgs extends agtAgentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgents base type for findFirst actions
   */
  export type agtAgentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * Filter, which agtAgents to fetch.
     * 
    **/
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgents.
     * 
    **/
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgents.
     * 
    **/
    distinct?: Enumerable<AgtAgentsScalarFieldEnum>
  }

  /**
   * agtAgents: findFirst
   */
  export interface agtAgentsFindFirstArgs extends agtAgentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgents findMany
   */
  export type agtAgentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * Filter, which agtAgents to fetch.
     * 
    **/
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgents.
     * 
    **/
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgtAgentsScalarFieldEnum>
  }


  /**
   * agtAgents create
   */
  export type agtAgentsCreateArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * The data needed to create a agtAgents.
     * 
    **/
    data: XOR<agtAgentsCreateInput, agtAgentsUncheckedCreateInput>
  }


  /**
   * agtAgents createMany
   */
  export type agtAgentsCreateManyArgs = {
    /**
     * The data used to create many agtAgents.
     * 
    **/
    data: Enumerable<agtAgentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * agtAgents update
   */
  export type agtAgentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * The data needed to update a agtAgents.
     * 
    **/
    data: XOR<agtAgentsUpdateInput, agtAgentsUncheckedUpdateInput>
    /**
     * Choose, which agtAgents to update.
     * 
    **/
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents updateMany
   */
  export type agtAgentsUpdateManyArgs = {
    /**
     * The data used to update agtAgents.
     * 
    **/
    data: XOR<agtAgentsUpdateManyMutationInput, agtAgentsUncheckedUpdateManyInput>
    /**
     * Filter which agtAgents to update
     * 
    **/
    where?: agtAgentsWhereInput
  }


  /**
   * agtAgents upsert
   */
  export type agtAgentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * The filter to search for the agtAgents to update in case it exists.
     * 
    **/
    where: agtAgentsWhereUniqueInput
    /**
     * In case the agtAgents found by the `where` argument doesn't exist, create a new agtAgents with this data.
     * 
    **/
    create: XOR<agtAgentsCreateInput, agtAgentsUncheckedCreateInput>
    /**
     * In case the agtAgents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<agtAgentsUpdateInput, agtAgentsUncheckedUpdateInput>
  }


  /**
   * agtAgents delete
   */
  export type agtAgentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
    /**
     * Filter which agtAgents to delete.
     * 
    **/
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents deleteMany
   */
  export type agtAgentsDeleteManyArgs = {
    /**
     * Filter which agtAgents to delete
     * 
    **/
    where?: agtAgentsWhereInput
  }


  /**
   * agtAgents: findUniqueOrThrow
   */
  export type agtAgentsFindUniqueOrThrowArgs = agtAgentsFindUniqueArgsBase
      

  /**
   * agtAgents: findFirstOrThrow
   */
  export type agtAgentsFindFirstOrThrowArgs = agtAgentsFindFirstArgsBase
      

  /**
   * agtAgents without action
   */
  export type agtAgentsArgs = {
    /**
     * Select specific fields to fetch from the agtAgents
     * 
    **/
    select?: agtAgentsSelect | null
  }



  /**
   * Model agtAgentsInSpace
   */


  export type AggregateAgtAgentsInSpace = {
    _count: AgtAgentsInSpaceCountAggregateOutputType | null
    _avg: AgtAgentsInSpaceAvgAggregateOutputType | null
    _sum: AgtAgentsInSpaceSumAggregateOutputType | null
    _min: AgtAgentsInSpaceMinAggregateOutputType | null
    _max: AgtAgentsInSpaceMaxAggregateOutputType | null
  }

  export type AgtAgentsInSpaceAvgAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceSumAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceMinAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceMaxAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceCountAggregateOutputType = {
    agentID: number
    dungeonID: number
    solarSystemID: number
    spawnPointID: number
    typeID: number
    _all: number
  }


  export type AgtAgentsInSpaceAvgAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceSumAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceMinAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceMaxAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceCountAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
    _all?: true
  }

  export type AgtAgentsInSpaceAggregateArgs = {
    /**
     * Filter which agtAgentsInSpace to aggregate.
     * 
    **/
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsInSpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgentsInSpaces
    **/
    _count?: true | AgtAgentsInSpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentsInSpaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentsInSpaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentsInSpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentsInSpaceMaxAggregateInputType
  }

  export type GetAgtAgentsInSpaceAggregateType<T extends AgtAgentsInSpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgentsInSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgentsInSpace[P]>
      : GetScalarType<T[P], AggregateAgtAgentsInSpace[P]>
  }




  export type AgtAgentsInSpaceGroupByArgs = {
    where?: agtAgentsInSpaceWhereInput
    orderBy?: Enumerable<agtAgentsInSpaceOrderByWithAggregationInput>
    by: Array<AgtAgentsInSpaceScalarFieldEnum>
    having?: agtAgentsInSpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentsInSpaceCountAggregateInputType | true
    _avg?: AgtAgentsInSpaceAvgAggregateInputType
    _sum?: AgtAgentsInSpaceSumAggregateInputType
    _min?: AgtAgentsInSpaceMinAggregateInputType
    _max?: AgtAgentsInSpaceMaxAggregateInputType
  }


  export type AgtAgentsInSpaceGroupByOutputType = {
    agentID: number
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
    _count: AgtAgentsInSpaceCountAggregateOutputType | null
    _avg: AgtAgentsInSpaceAvgAggregateOutputType | null
    _sum: AgtAgentsInSpaceSumAggregateOutputType | null
    _min: AgtAgentsInSpaceMinAggregateOutputType | null
    _max: AgtAgentsInSpaceMaxAggregateOutputType | null
  }

  type GetAgtAgentsInSpaceGroupByPayload<T extends AgtAgentsInSpaceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgtAgentsInSpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentsInSpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentsInSpaceGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentsInSpaceGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentsInSpaceSelect = {
    agentID?: boolean
    dungeonID?: boolean
    solarSystemID?: boolean
    spawnPointID?: boolean
    typeID?: boolean
  }


  export type agtAgentsInSpaceGetPayload<S extends boolean | null | undefined | agtAgentsInSpaceArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? agtAgentsInSpace :
    S extends undefined ? never :
    S extends { include: any } & (agtAgentsInSpaceArgs | agtAgentsInSpaceFindManyArgs)
    ? agtAgentsInSpace 
    : S extends { select: any } & (agtAgentsInSpaceArgs | agtAgentsInSpaceFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof agtAgentsInSpace ? agtAgentsInSpace[P] : never
  } 
      : agtAgentsInSpace


  type agtAgentsInSpaceCountArgs = Merge<
    Omit<agtAgentsInSpaceFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentsInSpaceCountAggregateInputType | true
    }
  >

  export interface agtAgentsInSpaceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AgtAgentsInSpace that matches the filter.
     * @param {agtAgentsInSpaceFindUniqueArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentsInSpaceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, agtAgentsInSpaceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'agtAgentsInSpace'> extends True ? Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>> : Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T> | null, null>

    /**
     * Find the first AgtAgentsInSpace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindFirstArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentsInSpaceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, agtAgentsInSpaceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'agtAgentsInSpace'> extends True ? Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>> : Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T> | null, null>

    /**
     * Find zero or more AgtAgentsInSpaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgentsInSpaces
     * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany()
     * 
     * // Get first 10 AgtAgentsInSpaces
     * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtAgentsInSpaceWithAgentIDOnly = await prisma.agtAgentsInSpace.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtAgentsInSpaceFindManyArgs>(
      args?: SelectSubset<T, agtAgentsInSpaceFindManyArgs>
    ): PrismaPromise<Array<agtAgentsInSpaceGetPayload<T>>>

    /**
     * Create a AgtAgentsInSpace.
     * @param {agtAgentsInSpaceCreateArgs} args - Arguments to create a AgtAgentsInSpace.
     * @example
     * // Create one AgtAgentsInSpace
     * const AgtAgentsInSpace = await prisma.agtAgentsInSpace.create({
     *   data: {
     *     // ... data to create a AgtAgentsInSpace
     *   }
     * })
     * 
    **/
    create<T extends agtAgentsInSpaceCreateArgs>(
      args: SelectSubset<T, agtAgentsInSpaceCreateArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Create many AgtAgentsInSpaces.
     *     @param {agtAgentsInSpaceCreateManyArgs} args - Arguments to create many AgtAgentsInSpaces.
     *     @example
     *     // Create many AgtAgentsInSpaces
     *     const agtAgentsInSpace = await prisma.agtAgentsInSpace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentsInSpaceCreateManyArgs>(
      args?: SelectSubset<T, agtAgentsInSpaceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgentsInSpace.
     * @param {agtAgentsInSpaceDeleteArgs} args - Arguments to delete one AgtAgentsInSpace.
     * @example
     * // Delete one AgtAgentsInSpace
     * const AgtAgentsInSpace = await prisma.agtAgentsInSpace.delete({
     *   where: {
     *     // ... filter to delete one AgtAgentsInSpace
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentsInSpaceDeleteArgs>(
      args: SelectSubset<T, agtAgentsInSpaceDeleteArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Update one AgtAgentsInSpace.
     * @param {agtAgentsInSpaceUpdateArgs} args - Arguments to update one AgtAgentsInSpace.
     * @example
     * // Update one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentsInSpaceUpdateArgs>(
      args: SelectSubset<T, agtAgentsInSpaceUpdateArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Delete zero or more AgtAgentsInSpaces.
     * @param {agtAgentsInSpaceDeleteManyArgs} args - Arguments to filter AgtAgentsInSpaces to delete.
     * @example
     * // Delete a few AgtAgentsInSpaces
     * const { count } = await prisma.agtAgentsInSpace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentsInSpaceDeleteManyArgs>(
      args?: SelectSubset<T, agtAgentsInSpaceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgentsInSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgentsInSpaces
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentsInSpaceUpdateManyArgs>(
      args: SelectSubset<T, agtAgentsInSpaceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgentsInSpace.
     * @param {agtAgentsInSpaceUpsertArgs} args - Arguments to update or create a AgtAgentsInSpace.
     * @example
     * // Update or create a AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.upsert({
     *   create: {
     *     // ... data to create a AgtAgentsInSpace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgentsInSpace we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentsInSpaceUpsertArgs>(
      args: SelectSubset<T, agtAgentsInSpaceUpsertArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Find one AgtAgentsInSpace that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {agtAgentsInSpaceFindUniqueOrThrowArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentsInSpaceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, agtAgentsInSpaceFindUniqueOrThrowArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Find the first AgtAgentsInSpace that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindFirstOrThrowArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentsInSpaceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agtAgentsInSpaceFindFirstOrThrowArgs>
    ): Prisma__agtAgentsInSpaceClient<agtAgentsInSpaceGetPayload<T>>

    /**
     * Count the number of AgtAgentsInSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceCountArgs} args - Arguments to filter AgtAgentsInSpaces to count.
     * @example
     * // Count the number of AgtAgentsInSpaces
     * const count = await prisma.agtAgentsInSpace.count({
     *   where: {
     *     // ... the filter for the AgtAgentsInSpaces we want to count
     *   }
     * })
    **/
    count<T extends agtAgentsInSpaceCountArgs>(
      args?: Subset<T, agtAgentsInSpaceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentsInSpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgentsInSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsInSpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentsInSpaceAggregateArgs>(args: Subset<T, AgtAgentsInSpaceAggregateArgs>): PrismaPromise<GetAgtAgentsInSpaceAggregateType<T>>

    /**
     * Group by AgtAgentsInSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsInSpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgtAgentsInSpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgtAgentsInSpaceGroupByArgs['orderBy'] }
        : { orderBy?: AgtAgentsInSpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgtAgentsInSpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentsInSpaceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgentsInSpace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__agtAgentsInSpaceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * agtAgentsInSpace base type for findUnique actions
   */
  export type agtAgentsInSpaceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     * 
    **/
    where: agtAgentsInSpaceWhereUniqueInput
  }

  /**
   * agtAgentsInSpace: findUnique
   */
  export interface agtAgentsInSpaceFindUniqueArgs extends agtAgentsInSpaceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgentsInSpace base type for findFirst actions
   */
  export type agtAgentsInSpaceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     * 
    **/
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsInSpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentsInSpaces.
     * 
    **/
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentsInSpaces.
     * 
    **/
    distinct?: Enumerable<AgtAgentsInSpaceScalarFieldEnum>
  }

  /**
   * agtAgentsInSpace: findFirst
   */
  export interface agtAgentsInSpaceFindFirstArgs extends agtAgentsInSpaceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtAgentsInSpace findMany
   */
  export type agtAgentsInSpaceFindManyArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * Filter, which agtAgentsInSpaces to fetch.
     * 
    **/
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     * 
    **/
    orderBy?: Enumerable<agtAgentsInSpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgentsInSpaces.
     * 
    **/
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgtAgentsInSpaceScalarFieldEnum>
  }


  /**
   * agtAgentsInSpace create
   */
  export type agtAgentsInSpaceCreateArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * The data needed to create a agtAgentsInSpace.
     * 
    **/
    data: XOR<agtAgentsInSpaceCreateInput, agtAgentsInSpaceUncheckedCreateInput>
  }


  /**
   * agtAgentsInSpace createMany
   */
  export type agtAgentsInSpaceCreateManyArgs = {
    /**
     * The data used to create many agtAgentsInSpaces.
     * 
    **/
    data: Enumerable<agtAgentsInSpaceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * agtAgentsInSpace update
   */
  export type agtAgentsInSpaceUpdateArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * The data needed to update a agtAgentsInSpace.
     * 
    **/
    data: XOR<agtAgentsInSpaceUpdateInput, agtAgentsInSpaceUncheckedUpdateInput>
    /**
     * Choose, which agtAgentsInSpace to update.
     * 
    **/
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace updateMany
   */
  export type agtAgentsInSpaceUpdateManyArgs = {
    /**
     * The data used to update agtAgentsInSpaces.
     * 
    **/
    data: XOR<agtAgentsInSpaceUpdateManyMutationInput, agtAgentsInSpaceUncheckedUpdateManyInput>
    /**
     * Filter which agtAgentsInSpaces to update
     * 
    **/
    where?: agtAgentsInSpaceWhereInput
  }


  /**
   * agtAgentsInSpace upsert
   */
  export type agtAgentsInSpaceUpsertArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * The filter to search for the agtAgentsInSpace to update in case it exists.
     * 
    **/
    where: agtAgentsInSpaceWhereUniqueInput
    /**
     * In case the agtAgentsInSpace found by the `where` argument doesn't exist, create a new agtAgentsInSpace with this data.
     * 
    **/
    create: XOR<agtAgentsInSpaceCreateInput, agtAgentsInSpaceUncheckedCreateInput>
    /**
     * In case the agtAgentsInSpace was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<agtAgentsInSpaceUpdateInput, agtAgentsInSpaceUncheckedUpdateInput>
  }


  /**
   * agtAgentsInSpace delete
   */
  export type agtAgentsInSpaceDeleteArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
    /**
     * Filter which agtAgentsInSpace to delete.
     * 
    **/
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace deleteMany
   */
  export type agtAgentsInSpaceDeleteManyArgs = {
    /**
     * Filter which agtAgentsInSpaces to delete
     * 
    **/
    where?: agtAgentsInSpaceWhereInput
  }


  /**
   * agtAgentsInSpace: findUniqueOrThrow
   */
  export type agtAgentsInSpaceFindUniqueOrThrowArgs = agtAgentsInSpaceFindUniqueArgsBase
      

  /**
   * agtAgentsInSpace: findFirstOrThrow
   */
  export type agtAgentsInSpaceFindFirstOrThrowArgs = agtAgentsInSpaceFindFirstArgsBase
      

  /**
   * agtAgentsInSpace without action
   */
  export type agtAgentsInSpaceArgs = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     * 
    **/
    select?: agtAgentsInSpaceSelect | null
  }



  /**
   * Model agtResearchAgents
   */


  export type AggregateAgtResearchAgents = {
    _count: AgtResearchAgentsCountAggregateOutputType | null
    _avg: AgtResearchAgentsAvgAggregateOutputType | null
    _sum: AgtResearchAgentsSumAggregateOutputType | null
    _min: AgtResearchAgentsMinAggregateOutputType | null
    _max: AgtResearchAgentsMaxAggregateOutputType | null
  }

  export type AgtResearchAgentsAvgAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsSumAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsMinAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsMaxAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsCountAggregateOutputType = {
    agentID: number
    typeID: number
    _all: number
  }


  export type AgtResearchAgentsAvgAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsSumAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsMinAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsMaxAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsCountAggregateInputType = {
    agentID?: true
    typeID?: true
    _all?: true
  }

  export type AgtResearchAgentsAggregateArgs = {
    /**
     * Filter which agtResearchAgents to aggregate.
     * 
    **/
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtResearchAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtResearchAgents
    **/
    _count?: true | AgtResearchAgentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtResearchAgentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtResearchAgentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtResearchAgentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtResearchAgentsMaxAggregateInputType
  }

  export type GetAgtResearchAgentsAggregateType<T extends AgtResearchAgentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtResearchAgents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtResearchAgents[P]>
      : GetScalarType<T[P], AggregateAgtResearchAgents[P]>
  }




  export type AgtResearchAgentsGroupByArgs = {
    where?: agtResearchAgentsWhereInput
    orderBy?: Enumerable<agtResearchAgentsOrderByWithAggregationInput>
    by: Array<AgtResearchAgentsScalarFieldEnum>
    having?: agtResearchAgentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtResearchAgentsCountAggregateInputType | true
    _avg?: AgtResearchAgentsAvgAggregateInputType
    _sum?: AgtResearchAgentsSumAggregateInputType
    _min?: AgtResearchAgentsMinAggregateInputType
    _max?: AgtResearchAgentsMaxAggregateInputType
  }


  export type AgtResearchAgentsGroupByOutputType = {
    agentID: number
    typeID: number
    _count: AgtResearchAgentsCountAggregateOutputType | null
    _avg: AgtResearchAgentsAvgAggregateOutputType | null
    _sum: AgtResearchAgentsSumAggregateOutputType | null
    _min: AgtResearchAgentsMinAggregateOutputType | null
    _max: AgtResearchAgentsMaxAggregateOutputType | null
  }

  type GetAgtResearchAgentsGroupByPayload<T extends AgtResearchAgentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgtResearchAgentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtResearchAgentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtResearchAgentsGroupByOutputType[P]>
            : GetScalarType<T[P], AgtResearchAgentsGroupByOutputType[P]>
        }
      >
    >


  export type agtResearchAgentsSelect = {
    agentID?: boolean
    typeID?: boolean
  }


  export type agtResearchAgentsGetPayload<S extends boolean | null | undefined | agtResearchAgentsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? agtResearchAgents :
    S extends undefined ? never :
    S extends { include: any } & (agtResearchAgentsArgs | agtResearchAgentsFindManyArgs)
    ? agtResearchAgents 
    : S extends { select: any } & (agtResearchAgentsArgs | agtResearchAgentsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof agtResearchAgents ? agtResearchAgents[P] : never
  } 
      : agtResearchAgents


  type agtResearchAgentsCountArgs = Merge<
    Omit<agtResearchAgentsFindManyArgs, 'select' | 'include'> & {
      select?: AgtResearchAgentsCountAggregateInputType | true
    }
  >

  export interface agtResearchAgentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AgtResearchAgents that matches the filter.
     * @param {agtResearchAgentsFindUniqueArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtResearchAgentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, agtResearchAgentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'agtResearchAgents'> extends True ? Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>> : Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T> | null, null>

    /**
     * Find the first AgtResearchAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindFirstArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtResearchAgentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, agtResearchAgentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'agtResearchAgents'> extends True ? Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>> : Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T> | null, null>

    /**
     * Find zero or more AgtResearchAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findMany()
     * 
     * // Get first 10 AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtResearchAgentsWithAgentIDOnly = await prisma.agtResearchAgents.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtResearchAgentsFindManyArgs>(
      args?: SelectSubset<T, agtResearchAgentsFindManyArgs>
    ): PrismaPromise<Array<agtResearchAgentsGetPayload<T>>>

    /**
     * Create a AgtResearchAgents.
     * @param {agtResearchAgentsCreateArgs} args - Arguments to create a AgtResearchAgents.
     * @example
     * // Create one AgtResearchAgents
     * const AgtResearchAgents = await prisma.agtResearchAgents.create({
     *   data: {
     *     // ... data to create a AgtResearchAgents
     *   }
     * })
     * 
    **/
    create<T extends agtResearchAgentsCreateArgs>(
      args: SelectSubset<T, agtResearchAgentsCreateArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Create many AgtResearchAgents.
     *     @param {agtResearchAgentsCreateManyArgs} args - Arguments to create many AgtResearchAgents.
     *     @example
     *     // Create many AgtResearchAgents
     *     const agtResearchAgents = await prisma.agtResearchAgents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtResearchAgentsCreateManyArgs>(
      args?: SelectSubset<T, agtResearchAgentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AgtResearchAgents.
     * @param {agtResearchAgentsDeleteArgs} args - Arguments to delete one AgtResearchAgents.
     * @example
     * // Delete one AgtResearchAgents
     * const AgtResearchAgents = await prisma.agtResearchAgents.delete({
     *   where: {
     *     // ... filter to delete one AgtResearchAgents
     *   }
     * })
     * 
    **/
    delete<T extends agtResearchAgentsDeleteArgs>(
      args: SelectSubset<T, agtResearchAgentsDeleteArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Update one AgtResearchAgents.
     * @param {agtResearchAgentsUpdateArgs} args - Arguments to update one AgtResearchAgents.
     * @example
     * // Update one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtResearchAgentsUpdateArgs>(
      args: SelectSubset<T, agtResearchAgentsUpdateArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Delete zero or more AgtResearchAgents.
     * @param {agtResearchAgentsDeleteManyArgs} args - Arguments to filter AgtResearchAgents to delete.
     * @example
     * // Delete a few AgtResearchAgents
     * const { count } = await prisma.agtResearchAgents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtResearchAgentsDeleteManyArgs>(
      args?: SelectSubset<T, agtResearchAgentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtResearchAgentsUpdateManyArgs>(
      args: SelectSubset<T, agtResearchAgentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtResearchAgents.
     * @param {agtResearchAgentsUpsertArgs} args - Arguments to update or create a AgtResearchAgents.
     * @example
     * // Update or create a AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.upsert({
     *   create: {
     *     // ... data to create a AgtResearchAgents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtResearchAgents we want to update
     *   }
     * })
    **/
    upsert<T extends agtResearchAgentsUpsertArgs>(
      args: SelectSubset<T, agtResearchAgentsUpsertArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Find one AgtResearchAgents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {agtResearchAgentsFindUniqueOrThrowArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtResearchAgentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, agtResearchAgentsFindUniqueOrThrowArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Find the first AgtResearchAgents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindFirstOrThrowArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtResearchAgentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agtResearchAgentsFindFirstOrThrowArgs>
    ): Prisma__agtResearchAgentsClient<agtResearchAgentsGetPayload<T>>

    /**
     * Count the number of AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsCountArgs} args - Arguments to filter AgtResearchAgents to count.
     * @example
     * // Count the number of AgtResearchAgents
     * const count = await prisma.agtResearchAgents.count({
     *   where: {
     *     // ... the filter for the AgtResearchAgents we want to count
     *   }
     * })
    **/
    count<T extends agtResearchAgentsCountArgs>(
      args?: Subset<T, agtResearchAgentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtResearchAgentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtResearchAgentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtResearchAgentsAggregateArgs>(args: Subset<T, AgtResearchAgentsAggregateArgs>): PrismaPromise<GetAgtResearchAgentsAggregateType<T>>

    /**
     * Group by AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtResearchAgentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgtResearchAgentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgtResearchAgentsGroupByArgs['orderBy'] }
        : { orderBy?: AgtResearchAgentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgtResearchAgentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtResearchAgentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for agtResearchAgents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__agtResearchAgentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * agtResearchAgents base type for findUnique actions
   */
  export type agtResearchAgentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * Filter, which agtResearchAgents to fetch.
     * 
    **/
    where: agtResearchAgentsWhereUniqueInput
  }

  /**
   * agtResearchAgents: findUnique
   */
  export interface agtResearchAgentsFindUniqueArgs extends agtResearchAgentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtResearchAgents base type for findFirst actions
   */
  export type agtResearchAgentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * Filter, which agtResearchAgents to fetch.
     * 
    **/
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtResearchAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtResearchAgents.
     * 
    **/
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtResearchAgents.
     * 
    **/
    distinct?: Enumerable<AgtResearchAgentsScalarFieldEnum>
  }

  /**
   * agtResearchAgents: findFirst
   */
  export interface agtResearchAgentsFindFirstArgs extends agtResearchAgentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agtResearchAgents findMany
   */
  export type agtResearchAgentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * Filter, which agtResearchAgents to fetch.
     * 
    **/
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     * 
    **/
    orderBy?: Enumerable<agtResearchAgentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtResearchAgents.
     * 
    **/
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgtResearchAgentsScalarFieldEnum>
  }


  /**
   * agtResearchAgents create
   */
  export type agtResearchAgentsCreateArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * The data needed to create a agtResearchAgents.
     * 
    **/
    data: XOR<agtResearchAgentsCreateInput, agtResearchAgentsUncheckedCreateInput>
  }


  /**
   * agtResearchAgents createMany
   */
  export type agtResearchAgentsCreateManyArgs = {
    /**
     * The data used to create many agtResearchAgents.
     * 
    **/
    data: Enumerable<agtResearchAgentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * agtResearchAgents update
   */
  export type agtResearchAgentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * The data needed to update a agtResearchAgents.
     * 
    **/
    data: XOR<agtResearchAgentsUpdateInput, agtResearchAgentsUncheckedUpdateInput>
    /**
     * Choose, which agtResearchAgents to update.
     * 
    **/
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents updateMany
   */
  export type agtResearchAgentsUpdateManyArgs = {
    /**
     * The data used to update agtResearchAgents.
     * 
    **/
    data: XOR<agtResearchAgentsUpdateManyMutationInput, agtResearchAgentsUncheckedUpdateManyInput>
    /**
     * Filter which agtResearchAgents to update
     * 
    **/
    where?: agtResearchAgentsWhereInput
  }


  /**
   * agtResearchAgents upsert
   */
  export type agtResearchAgentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * The filter to search for the agtResearchAgents to update in case it exists.
     * 
    **/
    where: agtResearchAgentsWhereUniqueInput
    /**
     * In case the agtResearchAgents found by the `where` argument doesn't exist, create a new agtResearchAgents with this data.
     * 
    **/
    create: XOR<agtResearchAgentsCreateInput, agtResearchAgentsUncheckedCreateInput>
    /**
     * In case the agtResearchAgents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<agtResearchAgentsUpdateInput, agtResearchAgentsUncheckedUpdateInput>
  }


  /**
   * agtResearchAgents delete
   */
  export type agtResearchAgentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
    /**
     * Filter which agtResearchAgents to delete.
     * 
    **/
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents deleteMany
   */
  export type agtResearchAgentsDeleteManyArgs = {
    /**
     * Filter which agtResearchAgents to delete
     * 
    **/
    where?: agtResearchAgentsWhereInput
  }


  /**
   * agtResearchAgents: findUniqueOrThrow
   */
  export type agtResearchAgentsFindUniqueOrThrowArgs = agtResearchAgentsFindUniqueArgsBase
      

  /**
   * agtResearchAgents: findFirstOrThrow
   */
  export type agtResearchAgentsFindFirstOrThrowArgs = agtResearchAgentsFindFirstArgsBase
      

  /**
   * agtResearchAgents without action
   */
  export type agtResearchAgentsArgs = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     * 
    **/
    select?: agtResearchAgentsSelect | null
  }



  /**
   * Model certCerts
   */


  export type AggregateCertCerts = {
    _count: CertCertsCountAggregateOutputType | null
    _avg: CertCertsAvgAggregateOutputType | null
    _sum: CertCertsSumAggregateOutputType | null
    _min: CertCertsMinAggregateOutputType | null
    _max: CertCertsMaxAggregateOutputType | null
  }

  export type CertCertsAvgAggregateOutputType = {
    certID: number | null
    groupID: number | null
  }

  export type CertCertsSumAggregateOutputType = {
    certID: number | null
    groupID: number | null
  }

  export type CertCertsMinAggregateOutputType = {
    certID: number | null
    description: string | null
    groupID: number | null
    name: string | null
  }

  export type CertCertsMaxAggregateOutputType = {
    certID: number | null
    description: string | null
    groupID: number | null
    name: string | null
  }

  export type CertCertsCountAggregateOutputType = {
    certID: number
    description: number
    groupID: number
    name: number
    _all: number
  }


  export type CertCertsAvgAggregateInputType = {
    certID?: true
    groupID?: true
  }

  export type CertCertsSumAggregateInputType = {
    certID?: true
    groupID?: true
  }

  export type CertCertsMinAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
  }

  export type CertCertsMaxAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
  }

  export type CertCertsCountAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
    _all?: true
  }

  export type CertCertsAggregateArgs = {
    /**
     * Filter which certCerts to aggregate.
     * 
    **/
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     * 
    **/
    orderBy?: Enumerable<certCertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certCerts
    **/
    _count?: true | CertCertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertCertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertCertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertCertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertCertsMaxAggregateInputType
  }

  export type GetCertCertsAggregateType<T extends CertCertsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertCerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertCerts[P]>
      : GetScalarType<T[P], AggregateCertCerts[P]>
  }




  export type CertCertsGroupByArgs = {
    where?: certCertsWhereInput
    orderBy?: Enumerable<certCertsOrderByWithAggregationInput>
    by: Array<CertCertsScalarFieldEnum>
    having?: certCertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertCertsCountAggregateInputType | true
    _avg?: CertCertsAvgAggregateInputType
    _sum?: CertCertsSumAggregateInputType
    _min?: CertCertsMinAggregateInputType
    _max?: CertCertsMaxAggregateInputType
  }


  export type CertCertsGroupByOutputType = {
    certID: number
    description: string | null
    groupID: number | null
    name: string | null
    _count: CertCertsCountAggregateOutputType | null
    _avg: CertCertsAvgAggregateOutputType | null
    _sum: CertCertsSumAggregateOutputType | null
    _min: CertCertsMinAggregateOutputType | null
    _max: CertCertsMaxAggregateOutputType | null
  }

  type GetCertCertsGroupByPayload<T extends CertCertsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CertCertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertCertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertCertsGroupByOutputType[P]>
            : GetScalarType<T[P], CertCertsGroupByOutputType[P]>
        }
      >
    >


  export type certCertsSelect = {
    certID?: boolean
    description?: boolean
    groupID?: boolean
    name?: boolean
  }


  export type certCertsGetPayload<S extends boolean | null | undefined | certCertsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? certCerts :
    S extends undefined ? never :
    S extends { include: any } & (certCertsArgs | certCertsFindManyArgs)
    ? certCerts 
    : S extends { select: any } & (certCertsArgs | certCertsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof certCerts ? certCerts[P] : never
  } 
      : certCerts


  type certCertsCountArgs = Merge<
    Omit<certCertsFindManyArgs, 'select' | 'include'> & {
      select?: CertCertsCountAggregateInputType | true
    }
  >

  export interface certCertsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CertCerts that matches the filter.
     * @param {certCertsFindUniqueArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends certCertsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, certCertsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'certCerts'> extends True ? Prisma__certCertsClient<certCertsGetPayload<T>> : Prisma__certCertsClient<certCertsGetPayload<T> | null, null>

    /**
     * Find the first CertCerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindFirstArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends certCertsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, certCertsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'certCerts'> extends True ? Prisma__certCertsClient<certCertsGetPayload<T>> : Prisma__certCertsClient<certCertsGetPayload<T> | null, null>

    /**
     * Find zero or more CertCerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertCerts
     * const certCerts = await prisma.certCerts.findMany()
     * 
     * // Get first 10 CertCerts
     * const certCerts = await prisma.certCerts.findMany({ take: 10 })
     * 
     * // Only select the `certID`
     * const certCertsWithCertIDOnly = await prisma.certCerts.findMany({ select: { certID: true } })
     * 
    **/
    findMany<T extends certCertsFindManyArgs>(
      args?: SelectSubset<T, certCertsFindManyArgs>
    ): PrismaPromise<Array<certCertsGetPayload<T>>>

    /**
     * Create a CertCerts.
     * @param {certCertsCreateArgs} args - Arguments to create a CertCerts.
     * @example
     * // Create one CertCerts
     * const CertCerts = await prisma.certCerts.create({
     *   data: {
     *     // ... data to create a CertCerts
     *   }
     * })
     * 
    **/
    create<T extends certCertsCreateArgs>(
      args: SelectSubset<T, certCertsCreateArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Create many CertCerts.
     *     @param {certCertsCreateManyArgs} args - Arguments to create many CertCerts.
     *     @example
     *     // Create many CertCerts
     *     const certCerts = await prisma.certCerts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends certCertsCreateManyArgs>(
      args?: SelectSubset<T, certCertsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CertCerts.
     * @param {certCertsDeleteArgs} args - Arguments to delete one CertCerts.
     * @example
     * // Delete one CertCerts
     * const CertCerts = await prisma.certCerts.delete({
     *   where: {
     *     // ... filter to delete one CertCerts
     *   }
     * })
     * 
    **/
    delete<T extends certCertsDeleteArgs>(
      args: SelectSubset<T, certCertsDeleteArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Update one CertCerts.
     * @param {certCertsUpdateArgs} args - Arguments to update one CertCerts.
     * @example
     * // Update one CertCerts
     * const certCerts = await prisma.certCerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends certCertsUpdateArgs>(
      args: SelectSubset<T, certCertsUpdateArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Delete zero or more CertCerts.
     * @param {certCertsDeleteManyArgs} args - Arguments to filter CertCerts to delete.
     * @example
     * // Delete a few CertCerts
     * const { count } = await prisma.certCerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends certCertsDeleteManyArgs>(
      args?: SelectSubset<T, certCertsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertCerts
     * const certCerts = await prisma.certCerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends certCertsUpdateManyArgs>(
      args: SelectSubset<T, certCertsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CertCerts.
     * @param {certCertsUpsertArgs} args - Arguments to update or create a CertCerts.
     * @example
     * // Update or create a CertCerts
     * const certCerts = await prisma.certCerts.upsert({
     *   create: {
     *     // ... data to create a CertCerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertCerts we want to update
     *   }
     * })
    **/
    upsert<T extends certCertsUpsertArgs>(
      args: SelectSubset<T, certCertsUpsertArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Find one CertCerts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {certCertsFindUniqueOrThrowArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends certCertsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, certCertsFindUniqueOrThrowArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Find the first CertCerts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindFirstOrThrowArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends certCertsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, certCertsFindFirstOrThrowArgs>
    ): Prisma__certCertsClient<certCertsGetPayload<T>>

    /**
     * Count the number of CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsCountArgs} args - Arguments to filter CertCerts to count.
     * @example
     * // Count the number of CertCerts
     * const count = await prisma.certCerts.count({
     *   where: {
     *     // ... the filter for the CertCerts we want to count
     *   }
     * })
    **/
    count<T extends certCertsCountArgs>(
      args?: Subset<T, certCertsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertCertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertCertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertCertsAggregateArgs>(args: Subset<T, CertCertsAggregateArgs>): PrismaPromise<GetCertCertsAggregateType<T>>

    /**
     * Group by CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertCertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertCertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertCertsGroupByArgs['orderBy'] }
        : { orderBy?: CertCertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertCertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertCertsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for certCerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__certCertsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * certCerts base type for findUnique actions
   */
  export type certCertsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * Filter, which certCerts to fetch.
     * 
    **/
    where: certCertsWhereUniqueInput
  }

  /**
   * certCerts: findUnique
   */
  export interface certCertsFindUniqueArgs extends certCertsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * certCerts base type for findFirst actions
   */
  export type certCertsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * Filter, which certCerts to fetch.
     * 
    **/
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     * 
    **/
    orderBy?: Enumerable<certCertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certCerts.
     * 
    **/
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certCerts.
     * 
    **/
    distinct?: Enumerable<CertCertsScalarFieldEnum>
  }

  /**
   * certCerts: findFirst
   */
  export interface certCertsFindFirstArgs extends certCertsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * certCerts findMany
   */
  export type certCertsFindManyArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * Filter, which certCerts to fetch.
     * 
    **/
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     * 
    **/
    orderBy?: Enumerable<certCertsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certCerts.
     * 
    **/
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CertCertsScalarFieldEnum>
  }


  /**
   * certCerts create
   */
  export type certCertsCreateArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * The data needed to create a certCerts.
     * 
    **/
    data: XOR<certCertsCreateInput, certCertsUncheckedCreateInput>
  }


  /**
   * certCerts createMany
   */
  export type certCertsCreateManyArgs = {
    /**
     * The data used to create many certCerts.
     * 
    **/
    data: Enumerable<certCertsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * certCerts update
   */
  export type certCertsUpdateArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * The data needed to update a certCerts.
     * 
    **/
    data: XOR<certCertsUpdateInput, certCertsUncheckedUpdateInput>
    /**
     * Choose, which certCerts to update.
     * 
    **/
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts updateMany
   */
  export type certCertsUpdateManyArgs = {
    /**
     * The data used to update certCerts.
     * 
    **/
    data: XOR<certCertsUpdateManyMutationInput, certCertsUncheckedUpdateManyInput>
    /**
     * Filter which certCerts to update
     * 
    **/
    where?: certCertsWhereInput
  }


  /**
   * certCerts upsert
   */
  export type certCertsUpsertArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * The filter to search for the certCerts to update in case it exists.
     * 
    **/
    where: certCertsWhereUniqueInput
    /**
     * In case the certCerts found by the `where` argument doesn't exist, create a new certCerts with this data.
     * 
    **/
    create: XOR<certCertsCreateInput, certCertsUncheckedCreateInput>
    /**
     * In case the certCerts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<certCertsUpdateInput, certCertsUncheckedUpdateInput>
  }


  /**
   * certCerts delete
   */
  export type certCertsDeleteArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
    /**
     * Filter which certCerts to delete.
     * 
    **/
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts deleteMany
   */
  export type certCertsDeleteManyArgs = {
    /**
     * Filter which certCerts to delete
     * 
    **/
    where?: certCertsWhereInput
  }


  /**
   * certCerts: findUniqueOrThrow
   */
  export type certCertsFindUniqueOrThrowArgs = certCertsFindUniqueArgsBase
      

  /**
   * certCerts: findFirstOrThrow
   */
  export type certCertsFindFirstOrThrowArgs = certCertsFindFirstArgsBase
      

  /**
   * certCerts without action
   */
  export type certCertsArgs = {
    /**
     * Select specific fields to fetch from the certCerts
     * 
    **/
    select?: certCertsSelect | null
  }



  /**
   * Model chrAncestries
   */


  export type AggregateChrAncestries = {
    _count: ChrAncestriesCountAggregateOutputType | null
    _avg: ChrAncestriesAvgAggregateOutputType | null
    _sum: ChrAncestriesSumAggregateOutputType | null
    _min: ChrAncestriesMinAggregateOutputType | null
    _max: ChrAncestriesMaxAggregateOutputType | null
  }

  export type ChrAncestriesAvgAggregateOutputType = {
    ancestryID: number | null
    bloodlineID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrAncestriesSumAggregateOutputType = {
    ancestryID: number | null
    bloodlineID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrAncestriesMinAggregateOutputType = {
    ancestryID: number | null
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrAncestriesMaxAggregateOutputType = {
    ancestryID: number | null
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrAncestriesCountAggregateOutputType = {
    ancestryID: number
    ancestryName: number
    bloodlineID: number
    description: number
    perception: number
    willpower: number
    charisma: number
    memory: number
    intelligence: number
    iconID: number
    shortDescription: number
    _all: number
  }


  export type ChrAncestriesAvgAggregateInputType = {
    ancestryID?: true
    bloodlineID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrAncestriesSumAggregateInputType = {
    ancestryID?: true
    bloodlineID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrAncestriesMinAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrAncestriesMaxAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrAncestriesCountAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    _all?: true
  }

  export type ChrAncestriesAggregateArgs = {
    /**
     * Filter which chrAncestries to aggregate.
     * 
    **/
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAncestriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrAncestries
    **/
    _count?: true | ChrAncestriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrAncestriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrAncestriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrAncestriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrAncestriesMaxAggregateInputType
  }

  export type GetChrAncestriesAggregateType<T extends ChrAncestriesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrAncestries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrAncestries[P]>
      : GetScalarType<T[P], AggregateChrAncestries[P]>
  }




  export type ChrAncestriesGroupByArgs = {
    where?: chrAncestriesWhereInput
    orderBy?: Enumerable<chrAncestriesOrderByWithAggregationInput>
    by: Array<ChrAncestriesScalarFieldEnum>
    having?: chrAncestriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrAncestriesCountAggregateInputType | true
    _avg?: ChrAncestriesAvgAggregateInputType
    _sum?: ChrAncestriesSumAggregateInputType
    _min?: ChrAncestriesMinAggregateInputType
    _max?: ChrAncestriesMaxAggregateInputType
  }


  export type ChrAncestriesGroupByOutputType = {
    ancestryID: number
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    _count: ChrAncestriesCountAggregateOutputType | null
    _avg: ChrAncestriesAvgAggregateOutputType | null
    _sum: ChrAncestriesSumAggregateOutputType | null
    _min: ChrAncestriesMinAggregateOutputType | null
    _max: ChrAncestriesMaxAggregateOutputType | null
  }

  type GetChrAncestriesGroupByPayload<T extends ChrAncestriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChrAncestriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrAncestriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrAncestriesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrAncestriesGroupByOutputType[P]>
        }
      >
    >


  export type chrAncestriesSelect = {
    ancestryID?: boolean
    ancestryName?: boolean
    bloodlineID?: boolean
    description?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }


  export type chrAncestriesGetPayload<S extends boolean | null | undefined | chrAncestriesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? chrAncestries :
    S extends undefined ? never :
    S extends { include: any } & (chrAncestriesArgs | chrAncestriesFindManyArgs)
    ? chrAncestries 
    : S extends { select: any } & (chrAncestriesArgs | chrAncestriesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof chrAncestries ? chrAncestries[P] : never
  } 
      : chrAncestries


  type chrAncestriesCountArgs = Merge<
    Omit<chrAncestriesFindManyArgs, 'select' | 'include'> & {
      select?: ChrAncestriesCountAggregateInputType | true
    }
  >

  export interface chrAncestriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ChrAncestries that matches the filter.
     * @param {chrAncestriesFindUniqueArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrAncestriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, chrAncestriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'chrAncestries'> extends True ? Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>> : Prisma__chrAncestriesClient<chrAncestriesGetPayload<T> | null, null>

    /**
     * Find the first ChrAncestries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindFirstArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrAncestriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, chrAncestriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'chrAncestries'> extends True ? Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>> : Prisma__chrAncestriesClient<chrAncestriesGetPayload<T> | null, null>

    /**
     * Find zero or more ChrAncestries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findMany()
     * 
     * // Get first 10 ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findMany({ take: 10 })
     * 
     * // Only select the `ancestryID`
     * const chrAncestriesWithAncestryIDOnly = await prisma.chrAncestries.findMany({ select: { ancestryID: true } })
     * 
    **/
    findMany<T extends chrAncestriesFindManyArgs>(
      args?: SelectSubset<T, chrAncestriesFindManyArgs>
    ): PrismaPromise<Array<chrAncestriesGetPayload<T>>>

    /**
     * Create a ChrAncestries.
     * @param {chrAncestriesCreateArgs} args - Arguments to create a ChrAncestries.
     * @example
     * // Create one ChrAncestries
     * const ChrAncestries = await prisma.chrAncestries.create({
     *   data: {
     *     // ... data to create a ChrAncestries
     *   }
     * })
     * 
    **/
    create<T extends chrAncestriesCreateArgs>(
      args: SelectSubset<T, chrAncestriesCreateArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Create many ChrAncestries.
     *     @param {chrAncestriesCreateManyArgs} args - Arguments to create many ChrAncestries.
     *     @example
     *     // Create many ChrAncestries
     *     const chrAncestries = await prisma.chrAncestries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrAncestriesCreateManyArgs>(
      args?: SelectSubset<T, chrAncestriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChrAncestries.
     * @param {chrAncestriesDeleteArgs} args - Arguments to delete one ChrAncestries.
     * @example
     * // Delete one ChrAncestries
     * const ChrAncestries = await prisma.chrAncestries.delete({
     *   where: {
     *     // ... filter to delete one ChrAncestries
     *   }
     * })
     * 
    **/
    delete<T extends chrAncestriesDeleteArgs>(
      args: SelectSubset<T, chrAncestriesDeleteArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Update one ChrAncestries.
     * @param {chrAncestriesUpdateArgs} args - Arguments to update one ChrAncestries.
     * @example
     * // Update one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrAncestriesUpdateArgs>(
      args: SelectSubset<T, chrAncestriesUpdateArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Delete zero or more ChrAncestries.
     * @param {chrAncestriesDeleteManyArgs} args - Arguments to filter ChrAncestries to delete.
     * @example
     * // Delete a few ChrAncestries
     * const { count } = await prisma.chrAncestries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrAncestriesDeleteManyArgs>(
      args?: SelectSubset<T, chrAncestriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrAncestriesUpdateManyArgs>(
      args: SelectSubset<T, chrAncestriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrAncestries.
     * @param {chrAncestriesUpsertArgs} args - Arguments to update or create a ChrAncestries.
     * @example
     * // Update or create a ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.upsert({
     *   create: {
     *     // ... data to create a ChrAncestries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrAncestries we want to update
     *   }
     * })
    **/
    upsert<T extends chrAncestriesUpsertArgs>(
      args: SelectSubset<T, chrAncestriesUpsertArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Find one ChrAncestries that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {chrAncestriesFindUniqueOrThrowArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrAncestriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, chrAncestriesFindUniqueOrThrowArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Find the first ChrAncestries that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindFirstOrThrowArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrAncestriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chrAncestriesFindFirstOrThrowArgs>
    ): Prisma__chrAncestriesClient<chrAncestriesGetPayload<T>>

    /**
     * Count the number of ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesCountArgs} args - Arguments to filter ChrAncestries to count.
     * @example
     * // Count the number of ChrAncestries
     * const count = await prisma.chrAncestries.count({
     *   where: {
     *     // ... the filter for the ChrAncestries we want to count
     *   }
     * })
    **/
    count<T extends chrAncestriesCountArgs>(
      args?: Subset<T, chrAncestriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrAncestriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAncestriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrAncestriesAggregateArgs>(args: Subset<T, ChrAncestriesAggregateArgs>): PrismaPromise<GetChrAncestriesAggregateType<T>>

    /**
     * Group by ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAncestriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChrAncestriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChrAncestriesGroupByArgs['orderBy'] }
        : { orderBy?: ChrAncestriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChrAncestriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrAncestriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for chrAncestries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chrAncestriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * chrAncestries base type for findUnique actions
   */
  export type chrAncestriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * Filter, which chrAncestries to fetch.
     * 
    **/
    where: chrAncestriesWhereUniqueInput
  }

  /**
   * chrAncestries: findUnique
   */
  export interface chrAncestriesFindUniqueArgs extends chrAncestriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrAncestries base type for findFirst actions
   */
  export type chrAncestriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * Filter, which chrAncestries to fetch.
     * 
    **/
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAncestriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAncestries.
     * 
    **/
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAncestries.
     * 
    **/
    distinct?: Enumerable<ChrAncestriesScalarFieldEnum>
  }

  /**
   * chrAncestries: findFirst
   */
  export interface chrAncestriesFindFirstArgs extends chrAncestriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrAncestries findMany
   */
  export type chrAncestriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * Filter, which chrAncestries to fetch.
     * 
    **/
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAncestriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrAncestries.
     * 
    **/
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChrAncestriesScalarFieldEnum>
  }


  /**
   * chrAncestries create
   */
  export type chrAncestriesCreateArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * The data needed to create a chrAncestries.
     * 
    **/
    data: XOR<chrAncestriesCreateInput, chrAncestriesUncheckedCreateInput>
  }


  /**
   * chrAncestries createMany
   */
  export type chrAncestriesCreateManyArgs = {
    /**
     * The data used to create many chrAncestries.
     * 
    **/
    data: Enumerable<chrAncestriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * chrAncestries update
   */
  export type chrAncestriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * The data needed to update a chrAncestries.
     * 
    **/
    data: XOR<chrAncestriesUpdateInput, chrAncestriesUncheckedUpdateInput>
    /**
     * Choose, which chrAncestries to update.
     * 
    **/
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries updateMany
   */
  export type chrAncestriesUpdateManyArgs = {
    /**
     * The data used to update chrAncestries.
     * 
    **/
    data: XOR<chrAncestriesUpdateManyMutationInput, chrAncestriesUncheckedUpdateManyInput>
    /**
     * Filter which chrAncestries to update
     * 
    **/
    where?: chrAncestriesWhereInput
  }


  /**
   * chrAncestries upsert
   */
  export type chrAncestriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * The filter to search for the chrAncestries to update in case it exists.
     * 
    **/
    where: chrAncestriesWhereUniqueInput
    /**
     * In case the chrAncestries found by the `where` argument doesn't exist, create a new chrAncestries with this data.
     * 
    **/
    create: XOR<chrAncestriesCreateInput, chrAncestriesUncheckedCreateInput>
    /**
     * In case the chrAncestries was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<chrAncestriesUpdateInput, chrAncestriesUncheckedUpdateInput>
  }


  /**
   * chrAncestries delete
   */
  export type chrAncestriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
    /**
     * Filter which chrAncestries to delete.
     * 
    **/
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries deleteMany
   */
  export type chrAncestriesDeleteManyArgs = {
    /**
     * Filter which chrAncestries to delete
     * 
    **/
    where?: chrAncestriesWhereInput
  }


  /**
   * chrAncestries: findUniqueOrThrow
   */
  export type chrAncestriesFindUniqueOrThrowArgs = chrAncestriesFindUniqueArgsBase
      

  /**
   * chrAncestries: findFirstOrThrow
   */
  export type chrAncestriesFindFirstOrThrowArgs = chrAncestriesFindFirstArgsBase
      

  /**
   * chrAncestries without action
   */
  export type chrAncestriesArgs = {
    /**
     * Select specific fields to fetch from the chrAncestries
     * 
    **/
    select?: chrAncestriesSelect | null
  }



  /**
   * Model chrAttributes
   */


  export type AggregateChrAttributes = {
    _count: ChrAttributesCountAggregateOutputType | null
    _avg: ChrAttributesAvgAggregateOutputType | null
    _sum: ChrAttributesSumAggregateOutputType | null
    _min: ChrAttributesMinAggregateOutputType | null
    _max: ChrAttributesMaxAggregateOutputType | null
  }

  export type ChrAttributesAvgAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
  }

  export type ChrAttributesSumAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
  }

  export type ChrAttributesMinAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
  }

  export type ChrAttributesMaxAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
  }

  export type ChrAttributesCountAggregateOutputType = {
    attributeID: number
    attributeName: number
    description: number
    iconID: number
    shortDescription: number
    notes: number
    _all: number
  }


  export type ChrAttributesAvgAggregateInputType = {
    attributeID?: true
    iconID?: true
  }

  export type ChrAttributesSumAggregateInputType = {
    attributeID?: true
    iconID?: true
  }

  export type ChrAttributesMinAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
  }

  export type ChrAttributesMaxAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
  }

  export type ChrAttributesCountAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
    _all?: true
  }

  export type ChrAttributesAggregateArgs = {
    /**
     * Filter which chrAttributes to aggregate.
     * 
    **/
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrAttributes
    **/
    _count?: true | ChrAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrAttributesMaxAggregateInputType
  }

  export type GetChrAttributesAggregateType<T extends ChrAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrAttributes[P]>
      : GetScalarType<T[P], AggregateChrAttributes[P]>
  }




  export type ChrAttributesGroupByArgs = {
    where?: chrAttributesWhereInput
    orderBy?: Enumerable<chrAttributesOrderByWithAggregationInput>
    by: Array<ChrAttributesScalarFieldEnum>
    having?: chrAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrAttributesCountAggregateInputType | true
    _avg?: ChrAttributesAvgAggregateInputType
    _sum?: ChrAttributesSumAggregateInputType
    _min?: ChrAttributesMinAggregateInputType
    _max?: ChrAttributesMaxAggregateInputType
  }


  export type ChrAttributesGroupByOutputType = {
    attributeID: number
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
    _count: ChrAttributesCountAggregateOutputType | null
    _avg: ChrAttributesAvgAggregateOutputType | null
    _sum: ChrAttributesSumAggregateOutputType | null
    _min: ChrAttributesMinAggregateOutputType | null
    _max: ChrAttributesMaxAggregateOutputType | null
  }

  type GetChrAttributesGroupByPayload<T extends ChrAttributesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChrAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrAttributesGroupByOutputType[P]>
        }
      >
    >


  export type chrAttributesSelect = {
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
    notes?: boolean
  }


  export type chrAttributesGetPayload<S extends boolean | null | undefined | chrAttributesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? chrAttributes :
    S extends undefined ? never :
    S extends { include: any } & (chrAttributesArgs | chrAttributesFindManyArgs)
    ? chrAttributes 
    : S extends { select: any } & (chrAttributesArgs | chrAttributesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof chrAttributes ? chrAttributes[P] : never
  } 
      : chrAttributes


  type chrAttributesCountArgs = Merge<
    Omit<chrAttributesFindManyArgs, 'select' | 'include'> & {
      select?: ChrAttributesCountAggregateInputType | true
    }
  >

  export interface chrAttributesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ChrAttributes that matches the filter.
     * @param {chrAttributesFindUniqueArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrAttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, chrAttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'chrAttributes'> extends True ? Prisma__chrAttributesClient<chrAttributesGetPayload<T>> : Prisma__chrAttributesClient<chrAttributesGetPayload<T> | null, null>

    /**
     * Find the first ChrAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindFirstArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrAttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, chrAttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'chrAttributes'> extends True ? Prisma__chrAttributesClient<chrAttributesGetPayload<T>> : Prisma__chrAttributesClient<chrAttributesGetPayload<T> | null, null>

    /**
     * Find zero or more ChrAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findMany()
     * 
     * // Get first 10 ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findMany({ take: 10 })
     * 
     * // Only select the `attributeID`
     * const chrAttributesWithAttributeIDOnly = await prisma.chrAttributes.findMany({ select: { attributeID: true } })
     * 
    **/
    findMany<T extends chrAttributesFindManyArgs>(
      args?: SelectSubset<T, chrAttributesFindManyArgs>
    ): PrismaPromise<Array<chrAttributesGetPayload<T>>>

    /**
     * Create a ChrAttributes.
     * @param {chrAttributesCreateArgs} args - Arguments to create a ChrAttributes.
     * @example
     * // Create one ChrAttributes
     * const ChrAttributes = await prisma.chrAttributes.create({
     *   data: {
     *     // ... data to create a ChrAttributes
     *   }
     * })
     * 
    **/
    create<T extends chrAttributesCreateArgs>(
      args: SelectSubset<T, chrAttributesCreateArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Create many ChrAttributes.
     *     @param {chrAttributesCreateManyArgs} args - Arguments to create many ChrAttributes.
     *     @example
     *     // Create many ChrAttributes
     *     const chrAttributes = await prisma.chrAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrAttributesCreateManyArgs>(
      args?: SelectSubset<T, chrAttributesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChrAttributes.
     * @param {chrAttributesDeleteArgs} args - Arguments to delete one ChrAttributes.
     * @example
     * // Delete one ChrAttributes
     * const ChrAttributes = await prisma.chrAttributes.delete({
     *   where: {
     *     // ... filter to delete one ChrAttributes
     *   }
     * })
     * 
    **/
    delete<T extends chrAttributesDeleteArgs>(
      args: SelectSubset<T, chrAttributesDeleteArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Update one ChrAttributes.
     * @param {chrAttributesUpdateArgs} args - Arguments to update one ChrAttributes.
     * @example
     * // Update one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrAttributesUpdateArgs>(
      args: SelectSubset<T, chrAttributesUpdateArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Delete zero or more ChrAttributes.
     * @param {chrAttributesDeleteManyArgs} args - Arguments to filter ChrAttributes to delete.
     * @example
     * // Delete a few ChrAttributes
     * const { count } = await prisma.chrAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrAttributesDeleteManyArgs>(
      args?: SelectSubset<T, chrAttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrAttributesUpdateManyArgs>(
      args: SelectSubset<T, chrAttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrAttributes.
     * @param {chrAttributesUpsertArgs} args - Arguments to update or create a ChrAttributes.
     * @example
     * // Update or create a ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.upsert({
     *   create: {
     *     // ... data to create a ChrAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends chrAttributesUpsertArgs>(
      args: SelectSubset<T, chrAttributesUpsertArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Find one ChrAttributes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {chrAttributesFindUniqueOrThrowArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrAttributesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, chrAttributesFindUniqueOrThrowArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Find the first ChrAttributes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindFirstOrThrowArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrAttributesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chrAttributesFindFirstOrThrowArgs>
    ): Prisma__chrAttributesClient<chrAttributesGetPayload<T>>

    /**
     * Count the number of ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesCountArgs} args - Arguments to filter ChrAttributes to count.
     * @example
     * // Count the number of ChrAttributes
     * const count = await prisma.chrAttributes.count({
     *   where: {
     *     // ... the filter for the ChrAttributes we want to count
     *   }
     * })
    **/
    count<T extends chrAttributesCountArgs>(
      args?: Subset<T, chrAttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrAttributesAggregateArgs>(args: Subset<T, ChrAttributesAggregateArgs>): PrismaPromise<GetChrAttributesAggregateType<T>>

    /**
     * Group by ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChrAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChrAttributesGroupByArgs['orderBy'] }
        : { orderBy?: ChrAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChrAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrAttributesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for chrAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chrAttributesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * chrAttributes base type for findUnique actions
   */
  export type chrAttributesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * Filter, which chrAttributes to fetch.
     * 
    **/
    where: chrAttributesWhereUniqueInput
  }

  /**
   * chrAttributes: findUnique
   */
  export interface chrAttributesFindUniqueArgs extends chrAttributesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrAttributes base type for findFirst actions
   */
  export type chrAttributesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * Filter, which chrAttributes to fetch.
     * 
    **/
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAttributes.
     * 
    **/
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAttributes.
     * 
    **/
    distinct?: Enumerable<ChrAttributesScalarFieldEnum>
  }

  /**
   * chrAttributes: findFirst
   */
  export interface chrAttributesFindFirstArgs extends chrAttributesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrAttributes findMany
   */
  export type chrAttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * Filter, which chrAttributes to fetch.
     * 
    **/
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<chrAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrAttributes.
     * 
    **/
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChrAttributesScalarFieldEnum>
  }


  /**
   * chrAttributes create
   */
  export type chrAttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * The data needed to create a chrAttributes.
     * 
    **/
    data: XOR<chrAttributesCreateInput, chrAttributesUncheckedCreateInput>
  }


  /**
   * chrAttributes createMany
   */
  export type chrAttributesCreateManyArgs = {
    /**
     * The data used to create many chrAttributes.
     * 
    **/
    data: Enumerable<chrAttributesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * chrAttributes update
   */
  export type chrAttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * The data needed to update a chrAttributes.
     * 
    **/
    data: XOR<chrAttributesUpdateInput, chrAttributesUncheckedUpdateInput>
    /**
     * Choose, which chrAttributes to update.
     * 
    **/
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes updateMany
   */
  export type chrAttributesUpdateManyArgs = {
    /**
     * The data used to update chrAttributes.
     * 
    **/
    data: XOR<chrAttributesUpdateManyMutationInput, chrAttributesUncheckedUpdateManyInput>
    /**
     * Filter which chrAttributes to update
     * 
    **/
    where?: chrAttributesWhereInput
  }


  /**
   * chrAttributes upsert
   */
  export type chrAttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * The filter to search for the chrAttributes to update in case it exists.
     * 
    **/
    where: chrAttributesWhereUniqueInput
    /**
     * In case the chrAttributes found by the `where` argument doesn't exist, create a new chrAttributes with this data.
     * 
    **/
    create: XOR<chrAttributesCreateInput, chrAttributesUncheckedCreateInput>
    /**
     * In case the chrAttributes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<chrAttributesUpdateInput, chrAttributesUncheckedUpdateInput>
  }


  /**
   * chrAttributes delete
   */
  export type chrAttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
    /**
     * Filter which chrAttributes to delete.
     * 
    **/
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes deleteMany
   */
  export type chrAttributesDeleteManyArgs = {
    /**
     * Filter which chrAttributes to delete
     * 
    **/
    where?: chrAttributesWhereInput
  }


  /**
   * chrAttributes: findUniqueOrThrow
   */
  export type chrAttributesFindUniqueOrThrowArgs = chrAttributesFindUniqueArgsBase
      

  /**
   * chrAttributes: findFirstOrThrow
   */
  export type chrAttributesFindFirstOrThrowArgs = chrAttributesFindFirstArgsBase
      

  /**
   * chrAttributes without action
   */
  export type chrAttributesArgs = {
    /**
     * Select specific fields to fetch from the chrAttributes
     * 
    **/
    select?: chrAttributesSelect | null
  }



  /**
   * Model chrBloodlines
   */


  export type AggregateChrBloodlines = {
    _count: ChrBloodlinesCountAggregateOutputType | null
    _avg: ChrBloodlinesAvgAggregateOutputType | null
    _sum: ChrBloodlinesSumAggregateOutputType | null
    _min: ChrBloodlinesMinAggregateOutputType | null
    _max: ChrBloodlinesMaxAggregateOutputType | null
  }

  export type ChrBloodlinesAvgAggregateOutputType = {
    bloodlineID: number | null
    raceID: number | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrBloodlinesSumAggregateOutputType = {
    bloodlineID: number | null
    raceID: number | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrBloodlinesMinAggregateOutputType = {
    bloodlineID: number | null
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
  }

  export type ChrBloodlinesMaxAggregateOutputType = {
    bloodlineID: number | null
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
  }

  export type ChrBloodlinesCountAggregateOutputType = {
    bloodlineID: number
    bloodlineName: number
    raceID: number
    description: number
    maleDescription: number
    femaleDescription: number
    shipTypeID: number
    corporationID: number
    perception: number
    willpower: number
    charisma: number
    memory: number
    intelligence: number
    iconID: number
    shortDescription: number
    shortMaleDescription: number
    shortFemaleDescription: number
    _all: number
  }


  export type ChrBloodlinesAvgAggregateInputType = {
    bloodlineID?: true
    raceID?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrBloodlinesSumAggregateInputType = {
    bloodlineID?: true
    raceID?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrBloodlinesMinAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
  }

  export type ChrBloodlinesMaxAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
  }

  export type ChrBloodlinesCountAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
    _all?: true
  }

  export type ChrBloodlinesAggregateArgs = {
    /**
     * Filter which chrBloodlines to aggregate.
     * 
    **/
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     * 
    **/
    orderBy?: Enumerable<chrBloodlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrBloodlines
    **/
    _count?: true | ChrBloodlinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrBloodlinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrBloodlinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrBloodlinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrBloodlinesMaxAggregateInputType
  }

  export type GetChrBloodlinesAggregateType<T extends ChrBloodlinesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrBloodlines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrBloodlines[P]>
      : GetScalarType<T[P], AggregateChrBloodlines[P]>
  }




  export type ChrBloodlinesGroupByArgs = {
    where?: chrBloodlinesWhereInput
    orderBy?: Enumerable<chrBloodlinesOrderByWithAggregationInput>
    by: Array<ChrBloodlinesScalarFieldEnum>
    having?: chrBloodlinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrBloodlinesCountAggregateInputType | true
    _avg?: ChrBloodlinesAvgAggregateInputType
    _sum?: ChrBloodlinesSumAggregateInputType
    _min?: ChrBloodlinesMinAggregateInputType
    _max?: ChrBloodlinesMaxAggregateInputType
  }


  export type ChrBloodlinesGroupByOutputType = {
    bloodlineID: number
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
    _count: ChrBloodlinesCountAggregateOutputType | null
    _avg: ChrBloodlinesAvgAggregateOutputType | null
    _sum: ChrBloodlinesSumAggregateOutputType | null
    _min: ChrBloodlinesMinAggregateOutputType | null
    _max: ChrBloodlinesMaxAggregateOutputType | null
  }

  type GetChrBloodlinesGroupByPayload<T extends ChrBloodlinesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChrBloodlinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrBloodlinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrBloodlinesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrBloodlinesGroupByOutputType[P]>
        }
      >
    >


  export type chrBloodlinesSelect = {
    bloodlineID?: boolean
    bloodlineName?: boolean
    raceID?: boolean
    description?: boolean
    maleDescription?: boolean
    femaleDescription?: boolean
    shipTypeID?: boolean
    corporationID?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
    shortMaleDescription?: boolean
    shortFemaleDescription?: boolean
  }


  export type chrBloodlinesGetPayload<S extends boolean | null | undefined | chrBloodlinesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? chrBloodlines :
    S extends undefined ? never :
    S extends { include: any } & (chrBloodlinesArgs | chrBloodlinesFindManyArgs)
    ? chrBloodlines 
    : S extends { select: any } & (chrBloodlinesArgs | chrBloodlinesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof chrBloodlines ? chrBloodlines[P] : never
  } 
      : chrBloodlines


  type chrBloodlinesCountArgs = Merge<
    Omit<chrBloodlinesFindManyArgs, 'select' | 'include'> & {
      select?: ChrBloodlinesCountAggregateInputType | true
    }
  >

  export interface chrBloodlinesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ChrBloodlines that matches the filter.
     * @param {chrBloodlinesFindUniqueArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrBloodlinesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, chrBloodlinesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'chrBloodlines'> extends True ? Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>> : Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T> | null, null>

    /**
     * Find the first ChrBloodlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindFirstArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrBloodlinesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, chrBloodlinesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'chrBloodlines'> extends True ? Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>> : Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T> | null, null>

    /**
     * Find zero or more ChrBloodlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findMany()
     * 
     * // Get first 10 ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findMany({ take: 10 })
     * 
     * // Only select the `bloodlineID`
     * const chrBloodlinesWithBloodlineIDOnly = await prisma.chrBloodlines.findMany({ select: { bloodlineID: true } })
     * 
    **/
    findMany<T extends chrBloodlinesFindManyArgs>(
      args?: SelectSubset<T, chrBloodlinesFindManyArgs>
    ): PrismaPromise<Array<chrBloodlinesGetPayload<T>>>

    /**
     * Create a ChrBloodlines.
     * @param {chrBloodlinesCreateArgs} args - Arguments to create a ChrBloodlines.
     * @example
     * // Create one ChrBloodlines
     * const ChrBloodlines = await prisma.chrBloodlines.create({
     *   data: {
     *     // ... data to create a ChrBloodlines
     *   }
     * })
     * 
    **/
    create<T extends chrBloodlinesCreateArgs>(
      args: SelectSubset<T, chrBloodlinesCreateArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Create many ChrBloodlines.
     *     @param {chrBloodlinesCreateManyArgs} args - Arguments to create many ChrBloodlines.
     *     @example
     *     // Create many ChrBloodlines
     *     const chrBloodlines = await prisma.chrBloodlines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrBloodlinesCreateManyArgs>(
      args?: SelectSubset<T, chrBloodlinesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChrBloodlines.
     * @param {chrBloodlinesDeleteArgs} args - Arguments to delete one ChrBloodlines.
     * @example
     * // Delete one ChrBloodlines
     * const ChrBloodlines = await prisma.chrBloodlines.delete({
     *   where: {
     *     // ... filter to delete one ChrBloodlines
     *   }
     * })
     * 
    **/
    delete<T extends chrBloodlinesDeleteArgs>(
      args: SelectSubset<T, chrBloodlinesDeleteArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Update one ChrBloodlines.
     * @param {chrBloodlinesUpdateArgs} args - Arguments to update one ChrBloodlines.
     * @example
     * // Update one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrBloodlinesUpdateArgs>(
      args: SelectSubset<T, chrBloodlinesUpdateArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Delete zero or more ChrBloodlines.
     * @param {chrBloodlinesDeleteManyArgs} args - Arguments to filter ChrBloodlines to delete.
     * @example
     * // Delete a few ChrBloodlines
     * const { count } = await prisma.chrBloodlines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrBloodlinesDeleteManyArgs>(
      args?: SelectSubset<T, chrBloodlinesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrBloodlinesUpdateManyArgs>(
      args: SelectSubset<T, chrBloodlinesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrBloodlines.
     * @param {chrBloodlinesUpsertArgs} args - Arguments to update or create a ChrBloodlines.
     * @example
     * // Update or create a ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.upsert({
     *   create: {
     *     // ... data to create a ChrBloodlines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrBloodlines we want to update
     *   }
     * })
    **/
    upsert<T extends chrBloodlinesUpsertArgs>(
      args: SelectSubset<T, chrBloodlinesUpsertArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Find one ChrBloodlines that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {chrBloodlinesFindUniqueOrThrowArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrBloodlinesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, chrBloodlinesFindUniqueOrThrowArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Find the first ChrBloodlines that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindFirstOrThrowArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrBloodlinesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chrBloodlinesFindFirstOrThrowArgs>
    ): Prisma__chrBloodlinesClient<chrBloodlinesGetPayload<T>>

    /**
     * Count the number of ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesCountArgs} args - Arguments to filter ChrBloodlines to count.
     * @example
     * // Count the number of ChrBloodlines
     * const count = await prisma.chrBloodlines.count({
     *   where: {
     *     // ... the filter for the ChrBloodlines we want to count
     *   }
     * })
    **/
    count<T extends chrBloodlinesCountArgs>(
      args?: Subset<T, chrBloodlinesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrBloodlinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrBloodlinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrBloodlinesAggregateArgs>(args: Subset<T, ChrBloodlinesAggregateArgs>): PrismaPromise<GetChrBloodlinesAggregateType<T>>

    /**
     * Group by ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrBloodlinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChrBloodlinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChrBloodlinesGroupByArgs['orderBy'] }
        : { orderBy?: ChrBloodlinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChrBloodlinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrBloodlinesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for chrBloodlines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chrBloodlinesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * chrBloodlines base type for findUnique actions
   */
  export type chrBloodlinesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * Filter, which chrBloodlines to fetch.
     * 
    **/
    where: chrBloodlinesWhereUniqueInput
  }

  /**
   * chrBloodlines: findUnique
   */
  export interface chrBloodlinesFindUniqueArgs extends chrBloodlinesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrBloodlines base type for findFirst actions
   */
  export type chrBloodlinesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * Filter, which chrBloodlines to fetch.
     * 
    **/
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     * 
    **/
    orderBy?: Enumerable<chrBloodlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrBloodlines.
     * 
    **/
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrBloodlines.
     * 
    **/
    distinct?: Enumerable<ChrBloodlinesScalarFieldEnum>
  }

  /**
   * chrBloodlines: findFirst
   */
  export interface chrBloodlinesFindFirstArgs extends chrBloodlinesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrBloodlines findMany
   */
  export type chrBloodlinesFindManyArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * Filter, which chrBloodlines to fetch.
     * 
    **/
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     * 
    **/
    orderBy?: Enumerable<chrBloodlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrBloodlines.
     * 
    **/
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChrBloodlinesScalarFieldEnum>
  }


  /**
   * chrBloodlines create
   */
  export type chrBloodlinesCreateArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * The data needed to create a chrBloodlines.
     * 
    **/
    data: XOR<chrBloodlinesCreateInput, chrBloodlinesUncheckedCreateInput>
  }


  /**
   * chrBloodlines createMany
   */
  export type chrBloodlinesCreateManyArgs = {
    /**
     * The data used to create many chrBloodlines.
     * 
    **/
    data: Enumerable<chrBloodlinesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * chrBloodlines update
   */
  export type chrBloodlinesUpdateArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * The data needed to update a chrBloodlines.
     * 
    **/
    data: XOR<chrBloodlinesUpdateInput, chrBloodlinesUncheckedUpdateInput>
    /**
     * Choose, which chrBloodlines to update.
     * 
    **/
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines updateMany
   */
  export type chrBloodlinesUpdateManyArgs = {
    /**
     * The data used to update chrBloodlines.
     * 
    **/
    data: XOR<chrBloodlinesUpdateManyMutationInput, chrBloodlinesUncheckedUpdateManyInput>
    /**
     * Filter which chrBloodlines to update
     * 
    **/
    where?: chrBloodlinesWhereInput
  }


  /**
   * chrBloodlines upsert
   */
  export type chrBloodlinesUpsertArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * The filter to search for the chrBloodlines to update in case it exists.
     * 
    **/
    where: chrBloodlinesWhereUniqueInput
    /**
     * In case the chrBloodlines found by the `where` argument doesn't exist, create a new chrBloodlines with this data.
     * 
    **/
    create: XOR<chrBloodlinesCreateInput, chrBloodlinesUncheckedCreateInput>
    /**
     * In case the chrBloodlines was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<chrBloodlinesUpdateInput, chrBloodlinesUncheckedUpdateInput>
  }


  /**
   * chrBloodlines delete
   */
  export type chrBloodlinesDeleteArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
    /**
     * Filter which chrBloodlines to delete.
     * 
    **/
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines deleteMany
   */
  export type chrBloodlinesDeleteManyArgs = {
    /**
     * Filter which chrBloodlines to delete
     * 
    **/
    where?: chrBloodlinesWhereInput
  }


  /**
   * chrBloodlines: findUniqueOrThrow
   */
  export type chrBloodlinesFindUniqueOrThrowArgs = chrBloodlinesFindUniqueArgsBase
      

  /**
   * chrBloodlines: findFirstOrThrow
   */
  export type chrBloodlinesFindFirstOrThrowArgs = chrBloodlinesFindFirstArgsBase
      

  /**
   * chrBloodlines without action
   */
  export type chrBloodlinesArgs = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     * 
    **/
    select?: chrBloodlinesSelect | null
  }



  /**
   * Model chrFactions
   */


  export type AggregateChrFactions = {
    _count: ChrFactionsCountAggregateOutputType | null
    _avg: ChrFactionsAvgAggregateOutputType | null
    _sum: ChrFactionsSumAggregateOutputType | null
    _min: ChrFactionsMinAggregateOutputType | null
    _max: ChrFactionsMaxAggregateOutputType | null
  }

  export type ChrFactionsAvgAggregateOutputType = {
    factionID: number | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsSumAggregateOutputType = {
    factionID: number | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsMinAggregateOutputType = {
    factionID: number | null
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsMaxAggregateOutputType = {
    factionID: number | null
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsCountAggregateOutputType = {
    factionID: number
    factionName: number
    description: number
    raceIDs: number
    solarSystemID: number
    corporationID: number
    sizeFactor: number
    stationCount: number
    stationSystemCount: number
    militiaCorporationID: number
    iconID: number
    _all: number
  }


  export type ChrFactionsAvgAggregateInputType = {
    factionID?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsSumAggregateInputType = {
    factionID?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsMinAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsMaxAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsCountAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
    _all?: true
  }

  export type ChrFactionsAggregateArgs = {
    /**
     * Filter which chrFactions to aggregate.
     * 
    **/
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     * 
    **/
    orderBy?: Enumerable<chrFactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrFactions
    **/
    _count?: true | ChrFactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrFactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrFactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrFactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrFactionsMaxAggregateInputType
  }

  export type GetChrFactionsAggregateType<T extends ChrFactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChrFactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrFactions[P]>
      : GetScalarType<T[P], AggregateChrFactions[P]>
  }




  export type ChrFactionsGroupByArgs = {
    where?: chrFactionsWhereInput
    orderBy?: Enumerable<chrFactionsOrderByWithAggregationInput>
    by: Array<ChrFactionsScalarFieldEnum>
    having?: chrFactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrFactionsCountAggregateInputType | true
    _avg?: ChrFactionsAvgAggregateInputType
    _sum?: ChrFactionsSumAggregateInputType
    _min?: ChrFactionsMinAggregateInputType
    _max?: ChrFactionsMaxAggregateInputType
  }


  export type ChrFactionsGroupByOutputType = {
    factionID: number
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
    _count: ChrFactionsCountAggregateOutputType | null
    _avg: ChrFactionsAvgAggregateOutputType | null
    _sum: ChrFactionsSumAggregateOutputType | null
    _min: ChrFactionsMinAggregateOutputType | null
    _max: ChrFactionsMaxAggregateOutputType | null
  }

  type GetChrFactionsGroupByPayload<T extends ChrFactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChrFactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrFactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrFactionsGroupByOutputType[P]>
            : GetScalarType<T[P], ChrFactionsGroupByOutputType[P]>
        }
      >
    >


  export type chrFactionsSelect = {
    factionID?: boolean
    factionName?: boolean
    description?: boolean
    raceIDs?: boolean
    solarSystemID?: boolean
    corporationID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    militiaCorporationID?: boolean
    iconID?: boolean
  }


  export type chrFactionsGetPayload<S extends boolean | null | undefined | chrFactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? chrFactions :
    S extends undefined ? never :
    S extends { include: any } & (chrFactionsArgs | chrFactionsFindManyArgs)
    ? chrFactions 
    : S extends { select: any } & (chrFactionsArgs | chrFactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof chrFactions ? chrFactions[P] : never
  } 
      : chrFactions


  type chrFactionsCountArgs = Merge<
    Omit<chrFactionsFindManyArgs, 'select' | 'include'> & {
      select?: ChrFactionsCountAggregateInputType | true
    }
  >

  export interface chrFactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ChrFactions that matches the filter.
     * @param {chrFactionsFindUniqueArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrFactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, chrFactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'chrFactions'> extends True ? Prisma__chrFactionsClient<chrFactionsGetPayload<T>> : Prisma__chrFactionsClient<chrFactionsGetPayload<T> | null, null>

    /**
     * Find the first ChrFactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindFirstArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrFactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, chrFactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'chrFactions'> extends True ? Prisma__chrFactionsClient<chrFactionsGetPayload<T>> : Prisma__chrFactionsClient<chrFactionsGetPayload<T> | null, null>

    /**
     * Find zero or more ChrFactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrFactions
     * const chrFactions = await prisma.chrFactions.findMany()
     * 
     * // Get first 10 ChrFactions
     * const chrFactions = await prisma.chrFactions.findMany({ take: 10 })
     * 
     * // Only select the `factionID`
     * const chrFactionsWithFactionIDOnly = await prisma.chrFactions.findMany({ select: { factionID: true } })
     * 
    **/
    findMany<T extends chrFactionsFindManyArgs>(
      args?: SelectSubset<T, chrFactionsFindManyArgs>
    ): PrismaPromise<Array<chrFactionsGetPayload<T>>>

    /**
     * Create a ChrFactions.
     * @param {chrFactionsCreateArgs} args - Arguments to create a ChrFactions.
     * @example
     * // Create one ChrFactions
     * const ChrFactions = await prisma.chrFactions.create({
     *   data: {
     *     // ... data to create a ChrFactions
     *   }
     * })
     * 
    **/
    create<T extends chrFactionsCreateArgs>(
      args: SelectSubset<T, chrFactionsCreateArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Create many ChrFactions.
     *     @param {chrFactionsCreateManyArgs} args - Arguments to create many ChrFactions.
     *     @example
     *     // Create many ChrFactions
     *     const chrFactions = await prisma.chrFactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrFactionsCreateManyArgs>(
      args?: SelectSubset<T, chrFactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChrFactions.
     * @param {chrFactionsDeleteArgs} args - Arguments to delete one ChrFactions.
     * @example
     * // Delete one ChrFactions
     * const ChrFactions = await prisma.chrFactions.delete({
     *   where: {
     *     // ... filter to delete one ChrFactions
     *   }
     * })
     * 
    **/
    delete<T extends chrFactionsDeleteArgs>(
      args: SelectSubset<T, chrFactionsDeleteArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Update one ChrFactions.
     * @param {chrFactionsUpdateArgs} args - Arguments to update one ChrFactions.
     * @example
     * // Update one ChrFactions
     * const chrFactions = await prisma.chrFactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrFactionsUpdateArgs>(
      args: SelectSubset<T, chrFactionsUpdateArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Delete zero or more ChrFactions.
     * @param {chrFactionsDeleteManyArgs} args - Arguments to filter ChrFactions to delete.
     * @example
     * // Delete a few ChrFactions
     * const { count } = await prisma.chrFactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrFactionsDeleteManyArgs>(
      args?: SelectSubset<T, chrFactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrFactions
     * const chrFactions = await prisma.chrFactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrFactionsUpdateManyArgs>(
      args: SelectSubset<T, chrFactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrFactions.
     * @param {chrFactionsUpsertArgs} args - Arguments to update or create a ChrFactions.
     * @example
     * // Update or create a ChrFactions
     * const chrFactions = await prisma.chrFactions.upsert({
     *   create: {
     *     // ... data to create a ChrFactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrFactions we want to update
     *   }
     * })
    **/
    upsert<T extends chrFactionsUpsertArgs>(
      args: SelectSubset<T, chrFactionsUpsertArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Find one ChrFactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {chrFactionsFindUniqueOrThrowArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrFactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, chrFactionsFindUniqueOrThrowArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Find the first ChrFactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindFirstOrThrowArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrFactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chrFactionsFindFirstOrThrowArgs>
    ): Prisma__chrFactionsClient<chrFactionsGetPayload<T>>

    /**
     * Count the number of ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsCountArgs} args - Arguments to filter ChrFactions to count.
     * @example
     * // Count the number of ChrFactions
     * const count = await prisma.chrFactions.count({
     *   where: {
     *     // ... the filter for the ChrFactions we want to count
     *   }
     * })
    **/
    count<T extends chrFactionsCountArgs>(
      args?: Subset<T, chrFactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrFactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrFactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrFactionsAggregateArgs>(args: Subset<T, ChrFactionsAggregateArgs>): PrismaPromise<GetChrFactionsAggregateType<T>>

    /**
     * Group by ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrFactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChrFactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChrFactionsGroupByArgs['orderBy'] }
        : { orderBy?: ChrFactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChrFactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrFactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for chrFactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chrFactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * chrFactions base type for findUnique actions
   */
  export type chrFactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * Filter, which chrFactions to fetch.
     * 
    **/
    where: chrFactionsWhereUniqueInput
  }

  /**
   * chrFactions: findUnique
   */
  export interface chrFactionsFindUniqueArgs extends chrFactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrFactions base type for findFirst actions
   */
  export type chrFactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * Filter, which chrFactions to fetch.
     * 
    **/
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     * 
    **/
    orderBy?: Enumerable<chrFactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrFactions.
     * 
    **/
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrFactions.
     * 
    **/
    distinct?: Enumerable<ChrFactionsScalarFieldEnum>
  }

  /**
   * chrFactions: findFirst
   */
  export interface chrFactionsFindFirstArgs extends chrFactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrFactions findMany
   */
  export type chrFactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * Filter, which chrFactions to fetch.
     * 
    **/
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     * 
    **/
    orderBy?: Enumerable<chrFactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrFactions.
     * 
    **/
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChrFactionsScalarFieldEnum>
  }


  /**
   * chrFactions create
   */
  export type chrFactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * The data needed to create a chrFactions.
     * 
    **/
    data: XOR<chrFactionsCreateInput, chrFactionsUncheckedCreateInput>
  }


  /**
   * chrFactions createMany
   */
  export type chrFactionsCreateManyArgs = {
    /**
     * The data used to create many chrFactions.
     * 
    **/
    data: Enumerable<chrFactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * chrFactions update
   */
  export type chrFactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * The data needed to update a chrFactions.
     * 
    **/
    data: XOR<chrFactionsUpdateInput, chrFactionsUncheckedUpdateInput>
    /**
     * Choose, which chrFactions to update.
     * 
    **/
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions updateMany
   */
  export type chrFactionsUpdateManyArgs = {
    /**
     * The data used to update chrFactions.
     * 
    **/
    data: XOR<chrFactionsUpdateManyMutationInput, chrFactionsUncheckedUpdateManyInput>
    /**
     * Filter which chrFactions to update
     * 
    **/
    where?: chrFactionsWhereInput
  }


  /**
   * chrFactions upsert
   */
  export type chrFactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * The filter to search for the chrFactions to update in case it exists.
     * 
    **/
    where: chrFactionsWhereUniqueInput
    /**
     * In case the chrFactions found by the `where` argument doesn't exist, create a new chrFactions with this data.
     * 
    **/
    create: XOR<chrFactionsCreateInput, chrFactionsUncheckedCreateInput>
    /**
     * In case the chrFactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<chrFactionsUpdateInput, chrFactionsUncheckedUpdateInput>
  }


  /**
   * chrFactions delete
   */
  export type chrFactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
    /**
     * Filter which chrFactions to delete.
     * 
    **/
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions deleteMany
   */
  export type chrFactionsDeleteManyArgs = {
    /**
     * Filter which chrFactions to delete
     * 
    **/
    where?: chrFactionsWhereInput
  }


  /**
   * chrFactions: findUniqueOrThrow
   */
  export type chrFactionsFindUniqueOrThrowArgs = chrFactionsFindUniqueArgsBase
      

  /**
   * chrFactions: findFirstOrThrow
   */
  export type chrFactionsFindFirstOrThrowArgs = chrFactionsFindFirstArgsBase
      

  /**
   * chrFactions without action
   */
  export type chrFactionsArgs = {
    /**
     * Select specific fields to fetch from the chrFactions
     * 
    **/
    select?: chrFactionsSelect | null
  }



  /**
   * Model chrRaces
   */


  export type AggregateChrRaces = {
    _count: ChrRacesCountAggregateOutputType | null
    _avg: ChrRacesAvgAggregateOutputType | null
    _sum: ChrRacesSumAggregateOutputType | null
    _min: ChrRacesMinAggregateOutputType | null
    _max: ChrRacesMaxAggregateOutputType | null
  }

  export type ChrRacesAvgAggregateOutputType = {
    raceID: number | null
    iconID: number | null
  }

  export type ChrRacesSumAggregateOutputType = {
    raceID: number | null
    iconID: number | null
  }

  export type ChrRacesMinAggregateOutputType = {
    raceID: number | null
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrRacesMaxAggregateOutputType = {
    raceID: number | null
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrRacesCountAggregateOutputType = {
    raceID: number
    raceName: number
    description: number
    iconID: number
    shortDescription: number
    _all: number
  }


  export type ChrRacesAvgAggregateInputType = {
    raceID?: true
    iconID?: true
  }

  export type ChrRacesSumAggregateInputType = {
    raceID?: true
    iconID?: true
  }

  export type ChrRacesMinAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrRacesMaxAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrRacesCountAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    _all?: true
  }

  export type ChrRacesAggregateArgs = {
    /**
     * Filter which chrRaces to aggregate.
     * 
    **/
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     * 
    **/
    orderBy?: Enumerable<chrRacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrRaces
    **/
    _count?: true | ChrRacesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrRacesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrRacesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrRacesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrRacesMaxAggregateInputType
  }

  export type GetChrRacesAggregateType<T extends ChrRacesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrRaces]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrRaces[P]>
      : GetScalarType<T[P], AggregateChrRaces[P]>
  }




  export type ChrRacesGroupByArgs = {
    where?: chrRacesWhereInput
    orderBy?: Enumerable<chrRacesOrderByWithAggregationInput>
    by: Array<ChrRacesScalarFieldEnum>
    having?: chrRacesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrRacesCountAggregateInputType | true
    _avg?: ChrRacesAvgAggregateInputType
    _sum?: ChrRacesSumAggregateInputType
    _min?: ChrRacesMinAggregateInputType
    _max?: ChrRacesMaxAggregateInputType
  }


  export type ChrRacesGroupByOutputType = {
    raceID: number
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    _count: ChrRacesCountAggregateOutputType | null
    _avg: ChrRacesAvgAggregateOutputType | null
    _sum: ChrRacesSumAggregateOutputType | null
    _min: ChrRacesMinAggregateOutputType | null
    _max: ChrRacesMaxAggregateOutputType | null
  }

  type GetChrRacesGroupByPayload<T extends ChrRacesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChrRacesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrRacesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrRacesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrRacesGroupByOutputType[P]>
        }
      >
    >


  export type chrRacesSelect = {
    raceID?: boolean
    raceName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }


  export type chrRacesGetPayload<S extends boolean | null | undefined | chrRacesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? chrRaces :
    S extends undefined ? never :
    S extends { include: any } & (chrRacesArgs | chrRacesFindManyArgs)
    ? chrRaces 
    : S extends { select: any } & (chrRacesArgs | chrRacesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof chrRaces ? chrRaces[P] : never
  } 
      : chrRaces


  type chrRacesCountArgs = Merge<
    Omit<chrRacesFindManyArgs, 'select' | 'include'> & {
      select?: ChrRacesCountAggregateInputType | true
    }
  >

  export interface chrRacesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ChrRaces that matches the filter.
     * @param {chrRacesFindUniqueArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrRacesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, chrRacesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'chrRaces'> extends True ? Prisma__chrRacesClient<chrRacesGetPayload<T>> : Prisma__chrRacesClient<chrRacesGetPayload<T> | null, null>

    /**
     * Find the first ChrRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindFirstArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrRacesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, chrRacesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'chrRaces'> extends True ? Prisma__chrRacesClient<chrRacesGetPayload<T>> : Prisma__chrRacesClient<chrRacesGetPayload<T> | null, null>

    /**
     * Find zero or more ChrRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrRaces
     * const chrRaces = await prisma.chrRaces.findMany()
     * 
     * // Get first 10 ChrRaces
     * const chrRaces = await prisma.chrRaces.findMany({ take: 10 })
     * 
     * // Only select the `raceID`
     * const chrRacesWithRaceIDOnly = await prisma.chrRaces.findMany({ select: { raceID: true } })
     * 
    **/
    findMany<T extends chrRacesFindManyArgs>(
      args?: SelectSubset<T, chrRacesFindManyArgs>
    ): PrismaPromise<Array<chrRacesGetPayload<T>>>

    /**
     * Create a ChrRaces.
     * @param {chrRacesCreateArgs} args - Arguments to create a ChrRaces.
     * @example
     * // Create one ChrRaces
     * const ChrRaces = await prisma.chrRaces.create({
     *   data: {
     *     // ... data to create a ChrRaces
     *   }
     * })
     * 
    **/
    create<T extends chrRacesCreateArgs>(
      args: SelectSubset<T, chrRacesCreateArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Create many ChrRaces.
     *     @param {chrRacesCreateManyArgs} args - Arguments to create many ChrRaces.
     *     @example
     *     // Create many ChrRaces
     *     const chrRaces = await prisma.chrRaces.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrRacesCreateManyArgs>(
      args?: SelectSubset<T, chrRacesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChrRaces.
     * @param {chrRacesDeleteArgs} args - Arguments to delete one ChrRaces.
     * @example
     * // Delete one ChrRaces
     * const ChrRaces = await prisma.chrRaces.delete({
     *   where: {
     *     // ... filter to delete one ChrRaces
     *   }
     * })
     * 
    **/
    delete<T extends chrRacesDeleteArgs>(
      args: SelectSubset<T, chrRacesDeleteArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Update one ChrRaces.
     * @param {chrRacesUpdateArgs} args - Arguments to update one ChrRaces.
     * @example
     * // Update one ChrRaces
     * const chrRaces = await prisma.chrRaces.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrRacesUpdateArgs>(
      args: SelectSubset<T, chrRacesUpdateArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Delete zero or more ChrRaces.
     * @param {chrRacesDeleteManyArgs} args - Arguments to filter ChrRaces to delete.
     * @example
     * // Delete a few ChrRaces
     * const { count } = await prisma.chrRaces.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrRacesDeleteManyArgs>(
      args?: SelectSubset<T, chrRacesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrRaces
     * const chrRaces = await prisma.chrRaces.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrRacesUpdateManyArgs>(
      args: SelectSubset<T, chrRacesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrRaces.
     * @param {chrRacesUpsertArgs} args - Arguments to update or create a ChrRaces.
     * @example
     * // Update or create a ChrRaces
     * const chrRaces = await prisma.chrRaces.upsert({
     *   create: {
     *     // ... data to create a ChrRaces
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrRaces we want to update
     *   }
     * })
    **/
    upsert<T extends chrRacesUpsertArgs>(
      args: SelectSubset<T, chrRacesUpsertArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Find one ChrRaces that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {chrRacesFindUniqueOrThrowArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrRacesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, chrRacesFindUniqueOrThrowArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Find the first ChrRaces that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindFirstOrThrowArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrRacesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chrRacesFindFirstOrThrowArgs>
    ): Prisma__chrRacesClient<chrRacesGetPayload<T>>

    /**
     * Count the number of ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesCountArgs} args - Arguments to filter ChrRaces to count.
     * @example
     * // Count the number of ChrRaces
     * const count = await prisma.chrRaces.count({
     *   where: {
     *     // ... the filter for the ChrRaces we want to count
     *   }
     * })
    **/
    count<T extends chrRacesCountArgs>(
      args?: Subset<T, chrRacesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrRacesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrRacesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrRacesAggregateArgs>(args: Subset<T, ChrRacesAggregateArgs>): PrismaPromise<GetChrRacesAggregateType<T>>

    /**
     * Group by ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrRacesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChrRacesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChrRacesGroupByArgs['orderBy'] }
        : { orderBy?: ChrRacesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChrRacesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrRacesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for chrRaces.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chrRacesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * chrRaces base type for findUnique actions
   */
  export type chrRacesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * Filter, which chrRaces to fetch.
     * 
    **/
    where: chrRacesWhereUniqueInput
  }

  /**
   * chrRaces: findUnique
   */
  export interface chrRacesFindUniqueArgs extends chrRacesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrRaces base type for findFirst actions
   */
  export type chrRacesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * Filter, which chrRaces to fetch.
     * 
    **/
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     * 
    **/
    orderBy?: Enumerable<chrRacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrRaces.
     * 
    **/
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrRaces.
     * 
    **/
    distinct?: Enumerable<ChrRacesScalarFieldEnum>
  }

  /**
   * chrRaces: findFirst
   */
  export interface chrRacesFindFirstArgs extends chrRacesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * chrRaces findMany
   */
  export type chrRacesFindManyArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * Filter, which chrRaces to fetch.
     * 
    **/
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     * 
    **/
    orderBy?: Enumerable<chrRacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrRaces.
     * 
    **/
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChrRacesScalarFieldEnum>
  }


  /**
   * chrRaces create
   */
  export type chrRacesCreateArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * The data needed to create a chrRaces.
     * 
    **/
    data: XOR<chrRacesCreateInput, chrRacesUncheckedCreateInput>
  }


  /**
   * chrRaces createMany
   */
  export type chrRacesCreateManyArgs = {
    /**
     * The data used to create many chrRaces.
     * 
    **/
    data: Enumerable<chrRacesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * chrRaces update
   */
  export type chrRacesUpdateArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * The data needed to update a chrRaces.
     * 
    **/
    data: XOR<chrRacesUpdateInput, chrRacesUncheckedUpdateInput>
    /**
     * Choose, which chrRaces to update.
     * 
    **/
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces updateMany
   */
  export type chrRacesUpdateManyArgs = {
    /**
     * The data used to update chrRaces.
     * 
    **/
    data: XOR<chrRacesUpdateManyMutationInput, chrRacesUncheckedUpdateManyInput>
    /**
     * Filter which chrRaces to update
     * 
    **/
    where?: chrRacesWhereInput
  }


  /**
   * chrRaces upsert
   */
  export type chrRacesUpsertArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * The filter to search for the chrRaces to update in case it exists.
     * 
    **/
    where: chrRacesWhereUniqueInput
    /**
     * In case the chrRaces found by the `where` argument doesn't exist, create a new chrRaces with this data.
     * 
    **/
    create: XOR<chrRacesCreateInput, chrRacesUncheckedCreateInput>
    /**
     * In case the chrRaces was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<chrRacesUpdateInput, chrRacesUncheckedUpdateInput>
  }


  /**
   * chrRaces delete
   */
  export type chrRacesDeleteArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
    /**
     * Filter which chrRaces to delete.
     * 
    **/
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces deleteMany
   */
  export type chrRacesDeleteManyArgs = {
    /**
     * Filter which chrRaces to delete
     * 
    **/
    where?: chrRacesWhereInput
  }


  /**
   * chrRaces: findUniqueOrThrow
   */
  export type chrRacesFindUniqueOrThrowArgs = chrRacesFindUniqueArgsBase
      

  /**
   * chrRaces: findFirstOrThrow
   */
  export type chrRacesFindFirstOrThrowArgs = chrRacesFindFirstArgsBase
      

  /**
   * chrRaces without action
   */
  export type chrRacesArgs = {
    /**
     * Select specific fields to fetch from the chrRaces
     * 
    **/
    select?: chrRacesSelect | null
  }



  /**
   * Model crpActivities
   */


  export type AggregateCrpActivities = {
    _count: CrpActivitiesCountAggregateOutputType | null
    _avg: CrpActivitiesAvgAggregateOutputType | null
    _sum: CrpActivitiesSumAggregateOutputType | null
    _min: CrpActivitiesMinAggregateOutputType | null
    _max: CrpActivitiesMaxAggregateOutputType | null
  }

  export type CrpActivitiesAvgAggregateOutputType = {
    activityID: number | null
  }

  export type CrpActivitiesSumAggregateOutputType = {
    activityID: number | null
  }

  export type CrpActivitiesMinAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    description: string | null
  }

  export type CrpActivitiesMaxAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    description: string | null
  }

  export type CrpActivitiesCountAggregateOutputType = {
    activityID: number
    activityName: number
    description: number
    _all: number
  }


  export type CrpActivitiesAvgAggregateInputType = {
    activityID?: true
  }

  export type CrpActivitiesSumAggregateInputType = {
    activityID?: true
  }

  export type CrpActivitiesMinAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
  }

  export type CrpActivitiesMaxAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
  }

  export type CrpActivitiesCountAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
    _all?: true
  }

  export type CrpActivitiesAggregateArgs = {
    /**
     * Filter which crpActivities to aggregate.
     * 
    **/
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<crpActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpActivities
    **/
    _count?: true | CrpActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpActivitiesMaxAggregateInputType
  }

  export type GetCrpActivitiesAggregateType<T extends CrpActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpActivities[P]>
      : GetScalarType<T[P], AggregateCrpActivities[P]>
  }




  export type CrpActivitiesGroupByArgs = {
    where?: crpActivitiesWhereInput
    orderBy?: Enumerable<crpActivitiesOrderByWithAggregationInput>
    by: Array<CrpActivitiesScalarFieldEnum>
    having?: crpActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpActivitiesCountAggregateInputType | true
    _avg?: CrpActivitiesAvgAggregateInputType
    _sum?: CrpActivitiesSumAggregateInputType
    _min?: CrpActivitiesMinAggregateInputType
    _max?: CrpActivitiesMaxAggregateInputType
  }


  export type CrpActivitiesGroupByOutputType = {
    activityID: number
    activityName: string | null
    description: string | null
    _count: CrpActivitiesCountAggregateOutputType | null
    _avg: CrpActivitiesAvgAggregateOutputType | null
    _sum: CrpActivitiesSumAggregateOutputType | null
    _min: CrpActivitiesMinAggregateOutputType | null
    _max: CrpActivitiesMaxAggregateOutputType | null
  }

  type GetCrpActivitiesGroupByPayload<T extends CrpActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CrpActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type crpActivitiesSelect = {
    activityID?: boolean
    activityName?: boolean
    description?: boolean
  }


  export type crpActivitiesGetPayload<S extends boolean | null | undefined | crpActivitiesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpActivities :
    S extends undefined ? never :
    S extends { include: any } & (crpActivitiesArgs | crpActivitiesFindManyArgs)
    ? crpActivities 
    : S extends { select: any } & (crpActivitiesArgs | crpActivitiesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpActivities ? crpActivities[P] : never
  } 
      : crpActivities


  type crpActivitiesCountArgs = Merge<
    Omit<crpActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: CrpActivitiesCountAggregateInputType | true
    }
  >

  export interface crpActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpActivities that matches the filter.
     * @param {crpActivitiesFindUniqueArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpActivities'> extends True ? Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>> : Prisma__crpActivitiesClient<crpActivitiesGetPayload<T> | null, null>

    /**
     * Find the first CrpActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindFirstArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpActivities'> extends True ? Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>> : Prisma__crpActivitiesClient<crpActivitiesGetPayload<T> | null, null>

    /**
     * Find zero or more CrpActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpActivities
     * const crpActivities = await prisma.crpActivities.findMany()
     * 
     * // Get first 10 CrpActivities
     * const crpActivities = await prisma.crpActivities.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const crpActivitiesWithActivityIDOnly = await prisma.crpActivities.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends crpActivitiesFindManyArgs>(
      args?: SelectSubset<T, crpActivitiesFindManyArgs>
    ): PrismaPromise<Array<crpActivitiesGetPayload<T>>>

    /**
     * Create a CrpActivities.
     * @param {crpActivitiesCreateArgs} args - Arguments to create a CrpActivities.
     * @example
     * // Create one CrpActivities
     * const CrpActivities = await prisma.crpActivities.create({
     *   data: {
     *     // ... data to create a CrpActivities
     *   }
     * })
     * 
    **/
    create<T extends crpActivitiesCreateArgs>(
      args: SelectSubset<T, crpActivitiesCreateArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Create many CrpActivities.
     *     @param {crpActivitiesCreateManyArgs} args - Arguments to create many CrpActivities.
     *     @example
     *     // Create many CrpActivities
     *     const crpActivities = await prisma.crpActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpActivitiesCreateManyArgs>(
      args?: SelectSubset<T, crpActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpActivities.
     * @param {crpActivitiesDeleteArgs} args - Arguments to delete one CrpActivities.
     * @example
     * // Delete one CrpActivities
     * const CrpActivities = await prisma.crpActivities.delete({
     *   where: {
     *     // ... filter to delete one CrpActivities
     *   }
     * })
     * 
    **/
    delete<T extends crpActivitiesDeleteArgs>(
      args: SelectSubset<T, crpActivitiesDeleteArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Update one CrpActivities.
     * @param {crpActivitiesUpdateArgs} args - Arguments to update one CrpActivities.
     * @example
     * // Update one CrpActivities
     * const crpActivities = await prisma.crpActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpActivitiesUpdateArgs>(
      args: SelectSubset<T, crpActivitiesUpdateArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Delete zero or more CrpActivities.
     * @param {crpActivitiesDeleteManyArgs} args - Arguments to filter CrpActivities to delete.
     * @example
     * // Delete a few CrpActivities
     * const { count } = await prisma.crpActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, crpActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpActivities
     * const crpActivities = await prisma.crpActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpActivitiesUpdateManyArgs>(
      args: SelectSubset<T, crpActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpActivities.
     * @param {crpActivitiesUpsertArgs} args - Arguments to update or create a CrpActivities.
     * @example
     * // Update or create a CrpActivities
     * const crpActivities = await prisma.crpActivities.upsert({
     *   create: {
     *     // ... data to create a CrpActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpActivities we want to update
     *   }
     * })
    **/
    upsert<T extends crpActivitiesUpsertArgs>(
      args: SelectSubset<T, crpActivitiesUpsertArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Find one CrpActivities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpActivitiesFindUniqueOrThrowArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpActivitiesFindUniqueOrThrowArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Find the first CrpActivities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindFirstOrThrowArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpActivitiesFindFirstOrThrowArgs>
    ): Prisma__crpActivitiesClient<crpActivitiesGetPayload<T>>

    /**
     * Count the number of CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesCountArgs} args - Arguments to filter CrpActivities to count.
     * @example
     * // Count the number of CrpActivities
     * const count = await prisma.crpActivities.count({
     *   where: {
     *     // ... the filter for the CrpActivities we want to count
     *   }
     * })
    **/
    count<T extends crpActivitiesCountArgs>(
      args?: Subset<T, crpActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpActivitiesAggregateArgs>(args: Subset<T, CrpActivitiesAggregateArgs>): PrismaPromise<GetCrpActivitiesAggregateType<T>>

    /**
     * Group by CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: CrpActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpActivities base type for findUnique actions
   */
  export type crpActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * Filter, which crpActivities to fetch.
     * 
    **/
    where: crpActivitiesWhereUniqueInput
  }

  /**
   * crpActivities: findUnique
   */
  export interface crpActivitiesFindUniqueArgs extends crpActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpActivities base type for findFirst actions
   */
  export type crpActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * Filter, which crpActivities to fetch.
     * 
    **/
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<crpActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpActivities.
     * 
    **/
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpActivities.
     * 
    **/
    distinct?: Enumerable<CrpActivitiesScalarFieldEnum>
  }

  /**
   * crpActivities: findFirst
   */
  export interface crpActivitiesFindFirstArgs extends crpActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpActivities findMany
   */
  export type crpActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * Filter, which crpActivities to fetch.
     * 
    **/
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<crpActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpActivities.
     * 
    **/
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpActivitiesScalarFieldEnum>
  }


  /**
   * crpActivities create
   */
  export type crpActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * The data needed to create a crpActivities.
     * 
    **/
    data: XOR<crpActivitiesCreateInput, crpActivitiesUncheckedCreateInput>
  }


  /**
   * crpActivities createMany
   */
  export type crpActivitiesCreateManyArgs = {
    /**
     * The data used to create many crpActivities.
     * 
    **/
    data: Enumerable<crpActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpActivities update
   */
  export type crpActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * The data needed to update a crpActivities.
     * 
    **/
    data: XOR<crpActivitiesUpdateInput, crpActivitiesUncheckedUpdateInput>
    /**
     * Choose, which crpActivities to update.
     * 
    **/
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities updateMany
   */
  export type crpActivitiesUpdateManyArgs = {
    /**
     * The data used to update crpActivities.
     * 
    **/
    data: XOR<crpActivitiesUpdateManyMutationInput, crpActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which crpActivities to update
     * 
    **/
    where?: crpActivitiesWhereInput
  }


  /**
   * crpActivities upsert
   */
  export type crpActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * The filter to search for the crpActivities to update in case it exists.
     * 
    **/
    where: crpActivitiesWhereUniqueInput
    /**
     * In case the crpActivities found by the `where` argument doesn't exist, create a new crpActivities with this data.
     * 
    **/
    create: XOR<crpActivitiesCreateInput, crpActivitiesUncheckedCreateInput>
    /**
     * In case the crpActivities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpActivitiesUpdateInput, crpActivitiesUncheckedUpdateInput>
  }


  /**
   * crpActivities delete
   */
  export type crpActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
    /**
     * Filter which crpActivities to delete.
     * 
    **/
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities deleteMany
   */
  export type crpActivitiesDeleteManyArgs = {
    /**
     * Filter which crpActivities to delete
     * 
    **/
    where?: crpActivitiesWhereInput
  }


  /**
   * crpActivities: findUniqueOrThrow
   */
  export type crpActivitiesFindUniqueOrThrowArgs = crpActivitiesFindUniqueArgsBase
      

  /**
   * crpActivities: findFirstOrThrow
   */
  export type crpActivitiesFindFirstOrThrowArgs = crpActivitiesFindFirstArgsBase
      

  /**
   * crpActivities without action
   */
  export type crpActivitiesArgs = {
    /**
     * Select specific fields to fetch from the crpActivities
     * 
    **/
    select?: crpActivitiesSelect | null
  }



  /**
   * Model crpNPCCorporationDivisions
   */


  export type AggregateCrpNPCCorporationDivisions = {
    _count: CrpNPCCorporationDivisionsCountAggregateOutputType | null
    _avg: CrpNPCCorporationDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationDivisionsSumAggregateOutputType | null
    _min: CrpNPCCorporationDivisionsMinAggregateOutputType | null
    _max: CrpNPCCorporationDivisionsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationDivisionsAvgAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsSumAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsMinAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsMaxAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsCountAggregateOutputType = {
    corporationID: number
    divisionID: number
    size: number
    _all: number
  }


  export type CrpNPCCorporationDivisionsAvgAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsSumAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsMinAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsMaxAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsCountAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
    _all?: true
  }

  export type CrpNPCCorporationDivisionsAggregateArgs = {
    /**
     * Filter which crpNPCCorporationDivisions to aggregate.
     * 
    **/
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationDivisions
    **/
    _count?: true | CrpNPCCorporationDivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationDivisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationDivisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationDivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationDivisionsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationDivisionsAggregateType<T extends CrpNPCCorporationDivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationDivisions[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationDivisions[P]>
  }




  export type CrpNPCCorporationDivisionsGroupByArgs = {
    where?: crpNPCCorporationDivisionsWhereInput
    orderBy?: Enumerable<crpNPCCorporationDivisionsOrderByWithAggregationInput>
    by: Array<CrpNPCCorporationDivisionsScalarFieldEnum>
    having?: crpNPCCorporationDivisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationDivisionsCountAggregateInputType | true
    _avg?: CrpNPCCorporationDivisionsAvgAggregateInputType
    _sum?: CrpNPCCorporationDivisionsSumAggregateInputType
    _min?: CrpNPCCorporationDivisionsMinAggregateInputType
    _max?: CrpNPCCorporationDivisionsMaxAggregateInputType
  }


  export type CrpNPCCorporationDivisionsGroupByOutputType = {
    corporationID: number
    divisionID: number
    size: number | null
    _count: CrpNPCCorporationDivisionsCountAggregateOutputType | null
    _avg: CrpNPCCorporationDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationDivisionsSumAggregateOutputType | null
    _min: CrpNPCCorporationDivisionsMinAggregateOutputType | null
    _max: CrpNPCCorporationDivisionsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationDivisionsGroupByPayload<T extends CrpNPCCorporationDivisionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpNPCCorporationDivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationDivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationDivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationDivisionsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationDivisionsSelect = {
    corporationID?: boolean
    divisionID?: boolean
    size?: boolean
  }


  export type crpNPCCorporationDivisionsGetPayload<S extends boolean | null | undefined | crpNPCCorporationDivisionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpNPCCorporationDivisions :
    S extends undefined ? never :
    S extends { include: any } & (crpNPCCorporationDivisionsArgs | crpNPCCorporationDivisionsFindManyArgs)
    ? crpNPCCorporationDivisions 
    : S extends { select: any } & (crpNPCCorporationDivisionsArgs | crpNPCCorporationDivisionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpNPCCorporationDivisions ? crpNPCCorporationDivisions[P] : never
  } 
      : crpNPCCorporationDivisions


  type crpNPCCorporationDivisionsCountArgs = Merge<
    Omit<crpNPCCorporationDivisionsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationDivisionsCountAggregateInputType | true
    }
  >

  export interface crpNPCCorporationDivisionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpNPCCorporationDivisions that matches the filter.
     * @param {crpNPCCorporationDivisionsFindUniqueArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationDivisionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpNPCCorporationDivisionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpNPCCorporationDivisions'> extends True ? Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>> : Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T> | null, null>

    /**
     * Find the first CrpNPCCorporationDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindFirstArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationDivisionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpNPCCorporationDivisions'> extends True ? Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>> : Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T> | null, null>

    /**
     * Find zero or more CrpNPCCorporationDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany()
     * 
     * // Get first 10 CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationDivisionsWithCorporationIDOnly = await prisma.crpNPCCorporationDivisions.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationDivisionsFindManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindManyArgs>
    ): PrismaPromise<Array<crpNPCCorporationDivisionsGetPayload<T>>>

    /**
     * Create a CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsCreateArgs} args - Arguments to create a CrpNPCCorporationDivisions.
     * @example
     * // Create one CrpNPCCorporationDivisions
     * const CrpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationDivisions
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationDivisionsCreateArgs>(
      args: SelectSubset<T, crpNPCCorporationDivisionsCreateArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Create many CrpNPCCorporationDivisions.
     *     @param {crpNPCCorporationDivisionsCreateManyArgs} args - Arguments to create many CrpNPCCorporationDivisions.
     *     @example
     *     // Create many CrpNPCCorporationDivisions
     *     const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationDivisionsCreateManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsDeleteArgs} args - Arguments to delete one CrpNPCCorporationDivisions.
     * @example
     * // Delete one CrpNPCCorporationDivisions
     * const CrpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationDivisions
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationDivisionsDeleteArgs>(
      args: SelectSubset<T, crpNPCCorporationDivisionsDeleteArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Update one CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsUpdateArgs} args - Arguments to update one CrpNPCCorporationDivisions.
     * @example
     * // Update one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationDivisionsUpdateArgs>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpdateArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Delete zero or more CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsDeleteManyArgs} args - Arguments to filter CrpNPCCorporationDivisions to delete.
     * @example
     * // Delete a few CrpNPCCorporationDivisions
     * const { count } = await prisma.crpNPCCorporationDivisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationDivisionsDeleteManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationDivisionsUpdateManyArgs>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsUpsertArgs} args - Arguments to update or create a CrpNPCCorporationDivisions.
     * @example
     * // Update or create a CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationDivisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationDivisions we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationDivisionsUpsertArgs>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpsertArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Find one CrpNPCCorporationDivisions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpNPCCorporationDivisionsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationDivisionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindUniqueOrThrowArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Find the first CrpNPCCorporationDivisions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationDivisionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindFirstOrThrowArgs>
    ): Prisma__crpNPCCorporationDivisionsClient<crpNPCCorporationDivisionsGetPayload<T>>

    /**
     * Count the number of CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsCountArgs} args - Arguments to filter CrpNPCCorporationDivisions to count.
     * @example
     * // Count the number of CrpNPCCorporationDivisions
     * const count = await prisma.crpNPCCorporationDivisions.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationDivisions we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationDivisionsCountArgs>(
      args?: Subset<T, crpNPCCorporationDivisionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationDivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationDivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationDivisionsAggregateArgs>(args: Subset<T, CrpNPCCorporationDivisionsAggregateArgs>): PrismaPromise<GetCrpNPCCorporationDivisionsAggregateType<T>>

    /**
     * Group by CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationDivisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpNPCCorporationDivisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpNPCCorporationDivisionsGroupByArgs['orderBy'] }
        : { orderBy?: CrpNPCCorporationDivisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpNPCCorporationDivisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationDivisionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationDivisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpNPCCorporationDivisionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpNPCCorporationDivisions base type for findUnique actions
   */
  export type crpNPCCorporationDivisionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     * 
    **/
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }

  /**
   * crpNPCCorporationDivisions: findUnique
   */
  export interface crpNPCCorporationDivisionsFindUniqueArgs extends crpNPCCorporationDivisionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationDivisions base type for findFirst actions
   */
  export type crpNPCCorporationDivisionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     * 
    **/
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationDivisions.
     * 
    **/
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationDivisions.
     * 
    **/
    distinct?: Enumerable<CrpNPCCorporationDivisionsScalarFieldEnum>
  }

  /**
   * crpNPCCorporationDivisions: findFirst
   */
  export interface crpNPCCorporationDivisionsFindFirstArgs extends crpNPCCorporationDivisionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationDivisions findMany
   */
  export type crpNPCCorporationDivisionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     * 
    **/
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationDivisions.
     * 
    **/
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpNPCCorporationDivisionsScalarFieldEnum>
  }


  /**
   * crpNPCCorporationDivisions create
   */
  export type crpNPCCorporationDivisionsCreateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * The data needed to create a crpNPCCorporationDivisions.
     * 
    **/
    data: XOR<crpNPCCorporationDivisionsCreateInput, crpNPCCorporationDivisionsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationDivisions createMany
   */
  export type crpNPCCorporationDivisionsCreateManyArgs = {
    /**
     * The data used to create many crpNPCCorporationDivisions.
     * 
    **/
    data: Enumerable<crpNPCCorporationDivisionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationDivisions update
   */
  export type crpNPCCorporationDivisionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * The data needed to update a crpNPCCorporationDivisions.
     * 
    **/
    data: XOR<crpNPCCorporationDivisionsUpdateInput, crpNPCCorporationDivisionsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationDivisions to update.
     * 
    **/
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions updateMany
   */
  export type crpNPCCorporationDivisionsUpdateManyArgs = {
    /**
     * The data used to update crpNPCCorporationDivisions.
     * 
    **/
    data: XOR<crpNPCCorporationDivisionsUpdateManyMutationInput, crpNPCCorporationDivisionsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationDivisions to update
     * 
    **/
    where?: crpNPCCorporationDivisionsWhereInput
  }


  /**
   * crpNPCCorporationDivisions upsert
   */
  export type crpNPCCorporationDivisionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * The filter to search for the crpNPCCorporationDivisions to update in case it exists.
     * 
    **/
    where: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * In case the crpNPCCorporationDivisions found by the `where` argument doesn't exist, create a new crpNPCCorporationDivisions with this data.
     * 
    **/
    create: XOR<crpNPCCorporationDivisionsCreateInput, crpNPCCorporationDivisionsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationDivisions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpNPCCorporationDivisionsUpdateInput, crpNPCCorporationDivisionsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationDivisions delete
   */
  export type crpNPCCorporationDivisionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
    /**
     * Filter which crpNPCCorporationDivisions to delete.
     * 
    **/
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions deleteMany
   */
  export type crpNPCCorporationDivisionsDeleteManyArgs = {
    /**
     * Filter which crpNPCCorporationDivisions to delete
     * 
    **/
    where?: crpNPCCorporationDivisionsWhereInput
  }


  /**
   * crpNPCCorporationDivisions: findUniqueOrThrow
   */
  export type crpNPCCorporationDivisionsFindUniqueOrThrowArgs = crpNPCCorporationDivisionsFindUniqueArgsBase
      

  /**
   * crpNPCCorporationDivisions: findFirstOrThrow
   */
  export type crpNPCCorporationDivisionsFindFirstOrThrowArgs = crpNPCCorporationDivisionsFindFirstArgsBase
      

  /**
   * crpNPCCorporationDivisions without action
   */
  export type crpNPCCorporationDivisionsArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     * 
    **/
    select?: crpNPCCorporationDivisionsSelect | null
  }



  /**
   * Model crpNPCCorporationResearchFields
   */


  export type AggregateCrpNPCCorporationResearchFields = {
    _count: CrpNPCCorporationResearchFieldsCountAggregateOutputType | null
    _avg: CrpNPCCorporationResearchFieldsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationResearchFieldsSumAggregateOutputType | null
    _min: CrpNPCCorporationResearchFieldsMinAggregateOutputType | null
    _max: CrpNPCCorporationResearchFieldsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationResearchFieldsAvgAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsSumAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsMinAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsMaxAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsCountAggregateOutputType = {
    skillID: number
    corporationID: number
    _all: number
  }


  export type CrpNPCCorporationResearchFieldsAvgAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsSumAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsMinAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsMaxAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsCountAggregateInputType = {
    skillID?: true
    corporationID?: true
    _all?: true
  }

  export type CrpNPCCorporationResearchFieldsAggregateArgs = {
    /**
     * Filter which crpNPCCorporationResearchFields to aggregate.
     * 
    **/
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationResearchFieldsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationResearchFields
    **/
    _count?: true | CrpNPCCorporationResearchFieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationResearchFieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationResearchFieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationResearchFieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationResearchFieldsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationResearchFieldsAggregateType<T extends CrpNPCCorporationResearchFieldsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationResearchFields]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationResearchFields[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationResearchFields[P]>
  }




  export type CrpNPCCorporationResearchFieldsGroupByArgs = {
    where?: crpNPCCorporationResearchFieldsWhereInput
    orderBy?: Enumerable<crpNPCCorporationResearchFieldsOrderByWithAggregationInput>
    by: Array<CrpNPCCorporationResearchFieldsScalarFieldEnum>
    having?: crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationResearchFieldsCountAggregateInputType | true
    _avg?: CrpNPCCorporationResearchFieldsAvgAggregateInputType
    _sum?: CrpNPCCorporationResearchFieldsSumAggregateInputType
    _min?: CrpNPCCorporationResearchFieldsMinAggregateInputType
    _max?: CrpNPCCorporationResearchFieldsMaxAggregateInputType
  }


  export type CrpNPCCorporationResearchFieldsGroupByOutputType = {
    skillID: number
    corporationID: number
    _count: CrpNPCCorporationResearchFieldsCountAggregateOutputType | null
    _avg: CrpNPCCorporationResearchFieldsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationResearchFieldsSumAggregateOutputType | null
    _min: CrpNPCCorporationResearchFieldsMinAggregateOutputType | null
    _max: CrpNPCCorporationResearchFieldsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationResearchFieldsGroupByPayload<T extends CrpNPCCorporationResearchFieldsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpNPCCorporationResearchFieldsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationResearchFieldsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationResearchFieldsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationResearchFieldsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationResearchFieldsSelect = {
    skillID?: boolean
    corporationID?: boolean
  }


  export type crpNPCCorporationResearchFieldsGetPayload<S extends boolean | null | undefined | crpNPCCorporationResearchFieldsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpNPCCorporationResearchFields :
    S extends undefined ? never :
    S extends { include: any } & (crpNPCCorporationResearchFieldsArgs | crpNPCCorporationResearchFieldsFindManyArgs)
    ? crpNPCCorporationResearchFields 
    : S extends { select: any } & (crpNPCCorporationResearchFieldsArgs | crpNPCCorporationResearchFieldsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpNPCCorporationResearchFields ? crpNPCCorporationResearchFields[P] : never
  } 
      : crpNPCCorporationResearchFields


  type crpNPCCorporationResearchFieldsCountArgs = Merge<
    Omit<crpNPCCorporationResearchFieldsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationResearchFieldsCountAggregateInputType | true
    }
  >

  export interface crpNPCCorporationResearchFieldsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpNPCCorporationResearchFields that matches the filter.
     * @param {crpNPCCorporationResearchFieldsFindUniqueArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationResearchFieldsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpNPCCorporationResearchFields'> extends True ? Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>> : Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T> | null, null>

    /**
     * Find the first CrpNPCCorporationResearchFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindFirstArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationResearchFieldsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpNPCCorporationResearchFields'> extends True ? Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>> : Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T> | null, null>

    /**
     * Find zero or more CrpNPCCorporationResearchFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany()
     * 
     * // Get first 10 CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany({ take: 10 })
     * 
     * // Only select the `skillID`
     * const crpNPCCorporationResearchFieldsWithSkillIDOnly = await prisma.crpNPCCorporationResearchFields.findMany({ select: { skillID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationResearchFieldsFindManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindManyArgs>
    ): PrismaPromise<Array<crpNPCCorporationResearchFieldsGetPayload<T>>>

    /**
     * Create a CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsCreateArgs} args - Arguments to create a CrpNPCCorporationResearchFields.
     * @example
     * // Create one CrpNPCCorporationResearchFields
     * const CrpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationResearchFields
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationResearchFieldsCreateArgs>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsCreateArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Create many CrpNPCCorporationResearchFields.
     *     @param {crpNPCCorporationResearchFieldsCreateManyArgs} args - Arguments to create many CrpNPCCorporationResearchFields.
     *     @example
     *     // Create many CrpNPCCorporationResearchFields
     *     const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationResearchFieldsCreateManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsDeleteArgs} args - Arguments to delete one CrpNPCCorporationResearchFields.
     * @example
     * // Delete one CrpNPCCorporationResearchFields
     * const CrpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationResearchFields
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationResearchFieldsDeleteArgs>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsDeleteArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Update one CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsUpdateArgs} args - Arguments to update one CrpNPCCorporationResearchFields.
     * @example
     * // Update one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationResearchFieldsUpdateArgs>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpdateArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Delete zero or more CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsDeleteManyArgs} args - Arguments to filter CrpNPCCorporationResearchFields to delete.
     * @example
     * // Delete a few CrpNPCCorporationResearchFields
     * const { count } = await prisma.crpNPCCorporationResearchFields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationResearchFieldsDeleteManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationResearchFieldsUpdateManyArgs>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsUpsertArgs} args - Arguments to update or create a CrpNPCCorporationResearchFields.
     * @example
     * // Update or create a CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationResearchFields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationResearchFields we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationResearchFieldsUpsertArgs>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpsertArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Find one CrpNPCCorporationResearchFields that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Find the first CrpNPCCorporationResearchFields that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationResearchFieldsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindFirstOrThrowArgs>
    ): Prisma__crpNPCCorporationResearchFieldsClient<crpNPCCorporationResearchFieldsGetPayload<T>>

    /**
     * Count the number of CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsCountArgs} args - Arguments to filter CrpNPCCorporationResearchFields to count.
     * @example
     * // Count the number of CrpNPCCorporationResearchFields
     * const count = await prisma.crpNPCCorporationResearchFields.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationResearchFields we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationResearchFieldsCountArgs>(
      args?: Subset<T, crpNPCCorporationResearchFieldsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationResearchFieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationResearchFieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationResearchFieldsAggregateArgs>(args: Subset<T, CrpNPCCorporationResearchFieldsAggregateArgs>): PrismaPromise<GetCrpNPCCorporationResearchFieldsAggregateType<T>>

    /**
     * Group by CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationResearchFieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpNPCCorporationResearchFieldsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpNPCCorporationResearchFieldsGroupByArgs['orderBy'] }
        : { orderBy?: CrpNPCCorporationResearchFieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpNPCCorporationResearchFieldsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationResearchFieldsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationResearchFields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpNPCCorporationResearchFieldsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpNPCCorporationResearchFields base type for findUnique actions
   */
  export type crpNPCCorporationResearchFieldsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     * 
    **/
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }

  /**
   * crpNPCCorporationResearchFields: findUnique
   */
  export interface crpNPCCorporationResearchFieldsFindUniqueArgs extends crpNPCCorporationResearchFieldsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationResearchFields base type for findFirst actions
   */
  export type crpNPCCorporationResearchFieldsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     * 
    **/
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationResearchFieldsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationResearchFields.
     * 
    **/
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationResearchFields.
     * 
    **/
    distinct?: Enumerable<CrpNPCCorporationResearchFieldsScalarFieldEnum>
  }

  /**
   * crpNPCCorporationResearchFields: findFirst
   */
  export interface crpNPCCorporationResearchFieldsFindFirstArgs extends crpNPCCorporationResearchFieldsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationResearchFields findMany
   */
  export type crpNPCCorporationResearchFieldsFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     * 
    **/
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationResearchFieldsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationResearchFields.
     * 
    **/
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpNPCCorporationResearchFieldsScalarFieldEnum>
  }


  /**
   * crpNPCCorporationResearchFields create
   */
  export type crpNPCCorporationResearchFieldsCreateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * The data needed to create a crpNPCCorporationResearchFields.
     * 
    **/
    data: XOR<crpNPCCorporationResearchFieldsCreateInput, crpNPCCorporationResearchFieldsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationResearchFields createMany
   */
  export type crpNPCCorporationResearchFieldsCreateManyArgs = {
    /**
     * The data used to create many crpNPCCorporationResearchFields.
     * 
    **/
    data: Enumerable<crpNPCCorporationResearchFieldsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationResearchFields update
   */
  export type crpNPCCorporationResearchFieldsUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * The data needed to update a crpNPCCorporationResearchFields.
     * 
    **/
    data: XOR<crpNPCCorporationResearchFieldsUpdateInput, crpNPCCorporationResearchFieldsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationResearchFields to update.
     * 
    **/
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields updateMany
   */
  export type crpNPCCorporationResearchFieldsUpdateManyArgs = {
    /**
     * The data used to update crpNPCCorporationResearchFields.
     * 
    **/
    data: XOR<crpNPCCorporationResearchFieldsUpdateManyMutationInput, crpNPCCorporationResearchFieldsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationResearchFields to update
     * 
    **/
    where?: crpNPCCorporationResearchFieldsWhereInput
  }


  /**
   * crpNPCCorporationResearchFields upsert
   */
  export type crpNPCCorporationResearchFieldsUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * The filter to search for the crpNPCCorporationResearchFields to update in case it exists.
     * 
    **/
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * In case the crpNPCCorporationResearchFields found by the `where` argument doesn't exist, create a new crpNPCCorporationResearchFields with this data.
     * 
    **/
    create: XOR<crpNPCCorporationResearchFieldsCreateInput, crpNPCCorporationResearchFieldsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationResearchFields was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpNPCCorporationResearchFieldsUpdateInput, crpNPCCorporationResearchFieldsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationResearchFields delete
   */
  export type crpNPCCorporationResearchFieldsDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
    /**
     * Filter which crpNPCCorporationResearchFields to delete.
     * 
    **/
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields deleteMany
   */
  export type crpNPCCorporationResearchFieldsDeleteManyArgs = {
    /**
     * Filter which crpNPCCorporationResearchFields to delete
     * 
    **/
    where?: crpNPCCorporationResearchFieldsWhereInput
  }


  /**
   * crpNPCCorporationResearchFields: findUniqueOrThrow
   */
  export type crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs = crpNPCCorporationResearchFieldsFindUniqueArgsBase
      

  /**
   * crpNPCCorporationResearchFields: findFirstOrThrow
   */
  export type crpNPCCorporationResearchFieldsFindFirstOrThrowArgs = crpNPCCorporationResearchFieldsFindFirstArgsBase
      

  /**
   * crpNPCCorporationResearchFields without action
   */
  export type crpNPCCorporationResearchFieldsArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     * 
    **/
    select?: crpNPCCorporationResearchFieldsSelect | null
  }



  /**
   * Model crpNPCCorporationTrades
   */


  export type AggregateCrpNPCCorporationTrades = {
    _count: CrpNPCCorporationTradesCountAggregateOutputType | null
    _avg: CrpNPCCorporationTradesAvgAggregateOutputType | null
    _sum: CrpNPCCorporationTradesSumAggregateOutputType | null
    _min: CrpNPCCorporationTradesMinAggregateOutputType | null
    _max: CrpNPCCorporationTradesMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationTradesAvgAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesSumAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesMinAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesMaxAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesCountAggregateOutputType = {
    corporationID: number
    typeID: number
    _all: number
  }


  export type CrpNPCCorporationTradesAvgAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesSumAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesMinAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesMaxAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesCountAggregateInputType = {
    corporationID?: true
    typeID?: true
    _all?: true
  }

  export type CrpNPCCorporationTradesAggregateArgs = {
    /**
     * Filter which crpNPCCorporationTrades to aggregate.
     * 
    **/
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationTradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationTrades
    **/
    _count?: true | CrpNPCCorporationTradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationTradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationTradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationTradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationTradesMaxAggregateInputType
  }

  export type GetCrpNPCCorporationTradesAggregateType<T extends CrpNPCCorporationTradesAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationTrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationTrades[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationTrades[P]>
  }




  export type CrpNPCCorporationTradesGroupByArgs = {
    where?: crpNPCCorporationTradesWhereInput
    orderBy?: Enumerable<crpNPCCorporationTradesOrderByWithAggregationInput>
    by: Array<CrpNPCCorporationTradesScalarFieldEnum>
    having?: crpNPCCorporationTradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationTradesCountAggregateInputType | true
    _avg?: CrpNPCCorporationTradesAvgAggregateInputType
    _sum?: CrpNPCCorporationTradesSumAggregateInputType
    _min?: CrpNPCCorporationTradesMinAggregateInputType
    _max?: CrpNPCCorporationTradesMaxAggregateInputType
  }


  export type CrpNPCCorporationTradesGroupByOutputType = {
    corporationID: number
    typeID: number
    _count: CrpNPCCorporationTradesCountAggregateOutputType | null
    _avg: CrpNPCCorporationTradesAvgAggregateOutputType | null
    _sum: CrpNPCCorporationTradesSumAggregateOutputType | null
    _min: CrpNPCCorporationTradesMinAggregateOutputType | null
    _max: CrpNPCCorporationTradesMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationTradesGroupByPayload<T extends CrpNPCCorporationTradesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpNPCCorporationTradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationTradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationTradesGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationTradesGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationTradesSelect = {
    corporationID?: boolean
    typeID?: boolean
  }


  export type crpNPCCorporationTradesGetPayload<S extends boolean | null | undefined | crpNPCCorporationTradesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpNPCCorporationTrades :
    S extends undefined ? never :
    S extends { include: any } & (crpNPCCorporationTradesArgs | crpNPCCorporationTradesFindManyArgs)
    ? crpNPCCorporationTrades 
    : S extends { select: any } & (crpNPCCorporationTradesArgs | crpNPCCorporationTradesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpNPCCorporationTrades ? crpNPCCorporationTrades[P] : never
  } 
      : crpNPCCorporationTrades


  type crpNPCCorporationTradesCountArgs = Merge<
    Omit<crpNPCCorporationTradesFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationTradesCountAggregateInputType | true
    }
  >

  export interface crpNPCCorporationTradesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpNPCCorporationTrades that matches the filter.
     * @param {crpNPCCorporationTradesFindUniqueArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationTradesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpNPCCorporationTradesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpNPCCorporationTrades'> extends True ? Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>> : Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T> | null, null>

    /**
     * Find the first CrpNPCCorporationTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindFirstArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationTradesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpNPCCorporationTrades'> extends True ? Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>> : Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T> | null, null>

    /**
     * Find zero or more CrpNPCCorporationTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany()
     * 
     * // Get first 10 CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationTradesWithCorporationIDOnly = await prisma.crpNPCCorporationTrades.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationTradesFindManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindManyArgs>
    ): PrismaPromise<Array<crpNPCCorporationTradesGetPayload<T>>>

    /**
     * Create a CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesCreateArgs} args - Arguments to create a CrpNPCCorporationTrades.
     * @example
     * // Create one CrpNPCCorporationTrades
     * const CrpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationTrades
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationTradesCreateArgs>(
      args: SelectSubset<T, crpNPCCorporationTradesCreateArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Create many CrpNPCCorporationTrades.
     *     @param {crpNPCCorporationTradesCreateManyArgs} args - Arguments to create many CrpNPCCorporationTrades.
     *     @example
     *     // Create many CrpNPCCorporationTrades
     *     const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationTradesCreateManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationTradesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesDeleteArgs} args - Arguments to delete one CrpNPCCorporationTrades.
     * @example
     * // Delete one CrpNPCCorporationTrades
     * const CrpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationTrades
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationTradesDeleteArgs>(
      args: SelectSubset<T, crpNPCCorporationTradesDeleteArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Update one CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesUpdateArgs} args - Arguments to update one CrpNPCCorporationTrades.
     * @example
     * // Update one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationTradesUpdateArgs>(
      args: SelectSubset<T, crpNPCCorporationTradesUpdateArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Delete zero or more CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesDeleteManyArgs} args - Arguments to filter CrpNPCCorporationTrades to delete.
     * @example
     * // Delete a few CrpNPCCorporationTrades
     * const { count } = await prisma.crpNPCCorporationTrades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationTradesDeleteManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationTradesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationTradesUpdateManyArgs>(
      args: SelectSubset<T, crpNPCCorporationTradesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesUpsertArgs} args - Arguments to update or create a CrpNPCCorporationTrades.
     * @example
     * // Update or create a CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationTrades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationTrades we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationTradesUpsertArgs>(
      args: SelectSubset<T, crpNPCCorporationTradesUpsertArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Find one CrpNPCCorporationTrades that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpNPCCorporationTradesFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationTradesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindUniqueOrThrowArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Find the first CrpNPCCorporationTrades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationTradesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindFirstOrThrowArgs>
    ): Prisma__crpNPCCorporationTradesClient<crpNPCCorporationTradesGetPayload<T>>

    /**
     * Count the number of CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesCountArgs} args - Arguments to filter CrpNPCCorporationTrades to count.
     * @example
     * // Count the number of CrpNPCCorporationTrades
     * const count = await prisma.crpNPCCorporationTrades.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationTrades we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationTradesCountArgs>(
      args?: Subset<T, crpNPCCorporationTradesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationTradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationTradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationTradesAggregateArgs>(args: Subset<T, CrpNPCCorporationTradesAggregateArgs>): PrismaPromise<GetCrpNPCCorporationTradesAggregateType<T>>

    /**
     * Group by CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationTradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpNPCCorporationTradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpNPCCorporationTradesGroupByArgs['orderBy'] }
        : { orderBy?: CrpNPCCorporationTradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpNPCCorporationTradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationTradesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationTrades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpNPCCorporationTradesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpNPCCorporationTrades base type for findUnique actions
   */
  export type crpNPCCorporationTradesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     * 
    **/
    where: crpNPCCorporationTradesWhereUniqueInput
  }

  /**
   * crpNPCCorporationTrades: findUnique
   */
  export interface crpNPCCorporationTradesFindUniqueArgs extends crpNPCCorporationTradesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationTrades base type for findFirst actions
   */
  export type crpNPCCorporationTradesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     * 
    **/
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationTradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationTrades.
     * 
    **/
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationTrades.
     * 
    **/
    distinct?: Enumerable<CrpNPCCorporationTradesScalarFieldEnum>
  }

  /**
   * crpNPCCorporationTrades: findFirst
   */
  export interface crpNPCCorporationTradesFindFirstArgs extends crpNPCCorporationTradesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporationTrades findMany
   */
  export type crpNPCCorporationTradesFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     * 
    **/
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationTradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationTrades.
     * 
    **/
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpNPCCorporationTradesScalarFieldEnum>
  }


  /**
   * crpNPCCorporationTrades create
   */
  export type crpNPCCorporationTradesCreateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * The data needed to create a crpNPCCorporationTrades.
     * 
    **/
    data: XOR<crpNPCCorporationTradesCreateInput, crpNPCCorporationTradesUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationTrades createMany
   */
  export type crpNPCCorporationTradesCreateManyArgs = {
    /**
     * The data used to create many crpNPCCorporationTrades.
     * 
    **/
    data: Enumerable<crpNPCCorporationTradesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationTrades update
   */
  export type crpNPCCorporationTradesUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * The data needed to update a crpNPCCorporationTrades.
     * 
    **/
    data: XOR<crpNPCCorporationTradesUpdateInput, crpNPCCorporationTradesUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationTrades to update.
     * 
    **/
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades updateMany
   */
  export type crpNPCCorporationTradesUpdateManyArgs = {
    /**
     * The data used to update crpNPCCorporationTrades.
     * 
    **/
    data: XOR<crpNPCCorporationTradesUpdateManyMutationInput, crpNPCCorporationTradesUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationTrades to update
     * 
    **/
    where?: crpNPCCorporationTradesWhereInput
  }


  /**
   * crpNPCCorporationTrades upsert
   */
  export type crpNPCCorporationTradesUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * The filter to search for the crpNPCCorporationTrades to update in case it exists.
     * 
    **/
    where: crpNPCCorporationTradesWhereUniqueInput
    /**
     * In case the crpNPCCorporationTrades found by the `where` argument doesn't exist, create a new crpNPCCorporationTrades with this data.
     * 
    **/
    create: XOR<crpNPCCorporationTradesCreateInput, crpNPCCorporationTradesUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationTrades was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpNPCCorporationTradesUpdateInput, crpNPCCorporationTradesUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationTrades delete
   */
  export type crpNPCCorporationTradesDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
    /**
     * Filter which crpNPCCorporationTrades to delete.
     * 
    **/
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades deleteMany
   */
  export type crpNPCCorporationTradesDeleteManyArgs = {
    /**
     * Filter which crpNPCCorporationTrades to delete
     * 
    **/
    where?: crpNPCCorporationTradesWhereInput
  }


  /**
   * crpNPCCorporationTrades: findUniqueOrThrow
   */
  export type crpNPCCorporationTradesFindUniqueOrThrowArgs = crpNPCCorporationTradesFindUniqueArgsBase
      

  /**
   * crpNPCCorporationTrades: findFirstOrThrow
   */
  export type crpNPCCorporationTradesFindFirstOrThrowArgs = crpNPCCorporationTradesFindFirstArgsBase
      

  /**
   * crpNPCCorporationTrades without action
   */
  export type crpNPCCorporationTradesArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     * 
    **/
    select?: crpNPCCorporationTradesSelect | null
  }



  /**
   * Model crpNPCCorporations
   */


  export type AggregateCrpNPCCorporations = {
    _count: CrpNPCCorporationsCountAggregateOutputType | null
    _avg: CrpNPCCorporationsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationsSumAggregateOutputType | null
    _min: CrpNPCCorporationsMinAggregateOutputType | null
    _max: CrpNPCCorporationsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationsAvgAggregateOutputType = {
    corporationID: number | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    iconID: number | null
  }

  export type CrpNPCCorporationsSumAggregateOutputType = {
    corporationID: number | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    iconID: number | null
  }

  export type CrpNPCCorporationsMinAggregateOutputType = {
    corporationID: number | null
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
  }

  export type CrpNPCCorporationsMaxAggregateOutputType = {
    corporationID: number | null
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
  }

  export type CrpNPCCorporationsCountAggregateOutputType = {
    corporationID: number
    size: number
    extent: number
    solarSystemID: number
    investorID1: number
    investorShares1: number
    investorID2: number
    investorShares2: number
    investorID3: number
    investorShares3: number
    investorID4: number
    investorShares4: number
    friendID: number
    enemyID: number
    publicShares: number
    initialPrice: number
    minSecurity: number
    scattered: number
    fringe: number
    corridor: number
    hub: number
    border: number
    factionID: number
    sizeFactor: number
    stationCount: number
    stationSystemCount: number
    description: number
    iconID: number
    _all: number
  }


  export type CrpNPCCorporationsAvgAggregateInputType = {
    corporationID?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    iconID?: true
  }

  export type CrpNPCCorporationsSumAggregateInputType = {
    corporationID?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    iconID?: true
  }

  export type CrpNPCCorporationsMinAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
  }

  export type CrpNPCCorporationsMaxAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
  }

  export type CrpNPCCorporationsCountAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
    _all?: true
  }

  export type CrpNPCCorporationsAggregateArgs = {
    /**
     * Filter which crpNPCCorporations to aggregate.
     * 
    **/
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporations
    **/
    _count?: true | CrpNPCCorporationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationsAggregateType<T extends CrpNPCCorporationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporations[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporations[P]>
  }




  export type CrpNPCCorporationsGroupByArgs = {
    where?: crpNPCCorporationsWhereInput
    orderBy?: Enumerable<crpNPCCorporationsOrderByWithAggregationInput>
    by: Array<CrpNPCCorporationsScalarFieldEnum>
    having?: crpNPCCorporationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationsCountAggregateInputType | true
    _avg?: CrpNPCCorporationsAvgAggregateInputType
    _sum?: CrpNPCCorporationsSumAggregateInputType
    _min?: CrpNPCCorporationsMinAggregateInputType
    _max?: CrpNPCCorporationsMaxAggregateInputType
  }


  export type CrpNPCCorporationsGroupByOutputType = {
    corporationID: number
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
    _count: CrpNPCCorporationsCountAggregateOutputType | null
    _avg: CrpNPCCorporationsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationsSumAggregateOutputType | null
    _min: CrpNPCCorporationsMinAggregateOutputType | null
    _max: CrpNPCCorporationsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationsGroupByPayload<T extends CrpNPCCorporationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpNPCCorporationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationsSelect = {
    corporationID?: boolean
    size?: boolean
    extent?: boolean
    solarSystemID?: boolean
    investorID1?: boolean
    investorShares1?: boolean
    investorID2?: boolean
    investorShares2?: boolean
    investorID3?: boolean
    investorShares3?: boolean
    investorID4?: boolean
    investorShares4?: boolean
    friendID?: boolean
    enemyID?: boolean
    publicShares?: boolean
    initialPrice?: boolean
    minSecurity?: boolean
    scattered?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    factionID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    description?: boolean
    iconID?: boolean
  }


  export type crpNPCCorporationsGetPayload<S extends boolean | null | undefined | crpNPCCorporationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpNPCCorporations :
    S extends undefined ? never :
    S extends { include: any } & (crpNPCCorporationsArgs | crpNPCCorporationsFindManyArgs)
    ? crpNPCCorporations 
    : S extends { select: any } & (crpNPCCorporationsArgs | crpNPCCorporationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpNPCCorporations ? crpNPCCorporations[P] : never
  } 
      : crpNPCCorporations


  type crpNPCCorporationsCountArgs = Merge<
    Omit<crpNPCCorporationsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationsCountAggregateInputType | true
    }
  >

  export interface crpNPCCorporationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpNPCCorporations that matches the filter.
     * @param {crpNPCCorporationsFindUniqueArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpNPCCorporationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpNPCCorporations'> extends True ? Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>> : Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T> | null, null>

    /**
     * Find the first CrpNPCCorporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindFirstArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpNPCCorporationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpNPCCorporations'> extends True ? Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>> : Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T> | null, null>

    /**
     * Find zero or more CrpNPCCorporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany()
     * 
     * // Get first 10 CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationsWithCorporationIDOnly = await prisma.crpNPCCorporations.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationsFindManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationsFindManyArgs>
    ): PrismaPromise<Array<crpNPCCorporationsGetPayload<T>>>

    /**
     * Create a CrpNPCCorporations.
     * @param {crpNPCCorporationsCreateArgs} args - Arguments to create a CrpNPCCorporations.
     * @example
     * // Create one CrpNPCCorporations
     * const CrpNPCCorporations = await prisma.crpNPCCorporations.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporations
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationsCreateArgs>(
      args: SelectSubset<T, crpNPCCorporationsCreateArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Create many CrpNPCCorporations.
     *     @param {crpNPCCorporationsCreateManyArgs} args - Arguments to create many CrpNPCCorporations.
     *     @example
     *     // Create many CrpNPCCorporations
     *     const crpNPCCorporations = await prisma.crpNPCCorporations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationsCreateManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporations.
     * @param {crpNPCCorporationsDeleteArgs} args - Arguments to delete one CrpNPCCorporations.
     * @example
     * // Delete one CrpNPCCorporations
     * const CrpNPCCorporations = await prisma.crpNPCCorporations.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporations
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationsDeleteArgs>(
      args: SelectSubset<T, crpNPCCorporationsDeleteArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Update one CrpNPCCorporations.
     * @param {crpNPCCorporationsUpdateArgs} args - Arguments to update one CrpNPCCorporations.
     * @example
     * // Update one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationsUpdateArgs>(
      args: SelectSubset<T, crpNPCCorporationsUpdateArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Delete zero or more CrpNPCCorporations.
     * @param {crpNPCCorporationsDeleteManyArgs} args - Arguments to filter CrpNPCCorporations to delete.
     * @example
     * // Delete a few CrpNPCCorporations
     * const { count } = await prisma.crpNPCCorporations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationsDeleteManyArgs>(
      args?: SelectSubset<T, crpNPCCorporationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationsUpdateManyArgs>(
      args: SelectSubset<T, crpNPCCorporationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporations.
     * @param {crpNPCCorporationsUpsertArgs} args - Arguments to update or create a CrpNPCCorporations.
     * @example
     * // Update or create a CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporations we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationsUpsertArgs>(
      args: SelectSubset<T, crpNPCCorporationsUpsertArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Find one CrpNPCCorporations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpNPCCorporationsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationsFindUniqueOrThrowArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Find the first CrpNPCCorporations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpNPCCorporationsFindFirstOrThrowArgs>
    ): Prisma__crpNPCCorporationsClient<crpNPCCorporationsGetPayload<T>>

    /**
     * Count the number of CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsCountArgs} args - Arguments to filter CrpNPCCorporations to count.
     * @example
     * // Count the number of CrpNPCCorporations
     * const count = await prisma.crpNPCCorporations.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporations we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationsCountArgs>(
      args?: Subset<T, crpNPCCorporationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationsAggregateArgs>(args: Subset<T, CrpNPCCorporationsAggregateArgs>): PrismaPromise<GetCrpNPCCorporationsAggregateType<T>>

    /**
     * Group by CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpNPCCorporationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpNPCCorporationsGroupByArgs['orderBy'] }
        : { orderBy?: CrpNPCCorporationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpNPCCorporationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpNPCCorporationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpNPCCorporations base type for findUnique actions
   */
  export type crpNPCCorporationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     * 
    **/
    where: crpNPCCorporationsWhereUniqueInput
  }

  /**
   * crpNPCCorporations: findUnique
   */
  export interface crpNPCCorporationsFindUniqueArgs extends crpNPCCorporationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporations base type for findFirst actions
   */
  export type crpNPCCorporationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     * 
    **/
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporations.
     * 
    **/
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporations.
     * 
    **/
    distinct?: Enumerable<CrpNPCCorporationsScalarFieldEnum>
  }

  /**
   * crpNPCCorporations: findFirst
   */
  export interface crpNPCCorporationsFindFirstArgs extends crpNPCCorporationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCCorporations findMany
   */
  export type crpNPCCorporationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     * 
    **/
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCCorporationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporations.
     * 
    **/
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpNPCCorporationsScalarFieldEnum>
  }


  /**
   * crpNPCCorporations create
   */
  export type crpNPCCorporationsCreateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * The data needed to create a crpNPCCorporations.
     * 
    **/
    data: XOR<crpNPCCorporationsCreateInput, crpNPCCorporationsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporations createMany
   */
  export type crpNPCCorporationsCreateManyArgs = {
    /**
     * The data used to create many crpNPCCorporations.
     * 
    **/
    data: Enumerable<crpNPCCorporationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporations update
   */
  export type crpNPCCorporationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * The data needed to update a crpNPCCorporations.
     * 
    **/
    data: XOR<crpNPCCorporationsUpdateInput, crpNPCCorporationsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporations to update.
     * 
    **/
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations updateMany
   */
  export type crpNPCCorporationsUpdateManyArgs = {
    /**
     * The data used to update crpNPCCorporations.
     * 
    **/
    data: XOR<crpNPCCorporationsUpdateManyMutationInput, crpNPCCorporationsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporations to update
     * 
    **/
    where?: crpNPCCorporationsWhereInput
  }


  /**
   * crpNPCCorporations upsert
   */
  export type crpNPCCorporationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * The filter to search for the crpNPCCorporations to update in case it exists.
     * 
    **/
    where: crpNPCCorporationsWhereUniqueInput
    /**
     * In case the crpNPCCorporations found by the `where` argument doesn't exist, create a new crpNPCCorporations with this data.
     * 
    **/
    create: XOR<crpNPCCorporationsCreateInput, crpNPCCorporationsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpNPCCorporationsUpdateInput, crpNPCCorporationsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporations delete
   */
  export type crpNPCCorporationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
    /**
     * Filter which crpNPCCorporations to delete.
     * 
    **/
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations deleteMany
   */
  export type crpNPCCorporationsDeleteManyArgs = {
    /**
     * Filter which crpNPCCorporations to delete
     * 
    **/
    where?: crpNPCCorporationsWhereInput
  }


  /**
   * crpNPCCorporations: findUniqueOrThrow
   */
  export type crpNPCCorporationsFindUniqueOrThrowArgs = crpNPCCorporationsFindUniqueArgsBase
      

  /**
   * crpNPCCorporations: findFirstOrThrow
   */
  export type crpNPCCorporationsFindFirstOrThrowArgs = crpNPCCorporationsFindFirstArgsBase
      

  /**
   * crpNPCCorporations without action
   */
  export type crpNPCCorporationsArgs = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     * 
    **/
    select?: crpNPCCorporationsSelect | null
  }



  /**
   * Model crpNPCDivisions
   */


  export type AggregateCrpNPCDivisions = {
    _count: CrpNPCDivisionsCountAggregateOutputType | null
    _avg: CrpNPCDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCDivisionsSumAggregateOutputType | null
    _min: CrpNPCDivisionsMinAggregateOutputType | null
    _max: CrpNPCDivisionsMaxAggregateOutputType | null
  }

  export type CrpNPCDivisionsAvgAggregateOutputType = {
    divisionID: number | null
  }

  export type CrpNPCDivisionsSumAggregateOutputType = {
    divisionID: number | null
  }

  export type CrpNPCDivisionsMinAggregateOutputType = {
    divisionID: number | null
    divisionName: string | null
    description: string | null
    leaderType: string | null
  }

  export type CrpNPCDivisionsMaxAggregateOutputType = {
    divisionID: number | null
    divisionName: string | null
    description: string | null
    leaderType: string | null
  }

  export type CrpNPCDivisionsCountAggregateOutputType = {
    divisionID: number
    divisionName: number
    description: number
    leaderType: number
    _all: number
  }


  export type CrpNPCDivisionsAvgAggregateInputType = {
    divisionID?: true
  }

  export type CrpNPCDivisionsSumAggregateInputType = {
    divisionID?: true
  }

  export type CrpNPCDivisionsMinAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
  }

  export type CrpNPCDivisionsMaxAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
  }

  export type CrpNPCDivisionsCountAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
    _all?: true
  }

  export type CrpNPCDivisionsAggregateArgs = {
    /**
     * Filter which crpNPCDivisions to aggregate.
     * 
    **/
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCDivisions
    **/
    _count?: true | CrpNPCDivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCDivisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCDivisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCDivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCDivisionsMaxAggregateInputType
  }

  export type GetCrpNPCDivisionsAggregateType<T extends CrpNPCDivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCDivisions[P]>
      : GetScalarType<T[P], AggregateCrpNPCDivisions[P]>
  }




  export type CrpNPCDivisionsGroupByArgs = {
    where?: crpNPCDivisionsWhereInput
    orderBy?: Enumerable<crpNPCDivisionsOrderByWithAggregationInput>
    by: Array<CrpNPCDivisionsScalarFieldEnum>
    having?: crpNPCDivisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCDivisionsCountAggregateInputType | true
    _avg?: CrpNPCDivisionsAvgAggregateInputType
    _sum?: CrpNPCDivisionsSumAggregateInputType
    _min?: CrpNPCDivisionsMinAggregateInputType
    _max?: CrpNPCDivisionsMaxAggregateInputType
  }


  export type CrpNPCDivisionsGroupByOutputType = {
    divisionID: number
    divisionName: string | null
    description: string | null
    leaderType: string | null
    _count: CrpNPCDivisionsCountAggregateOutputType | null
    _avg: CrpNPCDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCDivisionsSumAggregateOutputType | null
    _min: CrpNPCDivisionsMinAggregateOutputType | null
    _max: CrpNPCDivisionsMaxAggregateOutputType | null
  }

  type GetCrpNPCDivisionsGroupByPayload<T extends CrpNPCDivisionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrpNPCDivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCDivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCDivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCDivisionsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCDivisionsSelect = {
    divisionID?: boolean
    divisionName?: boolean
    description?: boolean
    leaderType?: boolean
  }


  export type crpNPCDivisionsGetPayload<S extends boolean | null | undefined | crpNPCDivisionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? crpNPCDivisions :
    S extends undefined ? never :
    S extends { include: any } & (crpNPCDivisionsArgs | crpNPCDivisionsFindManyArgs)
    ? crpNPCDivisions 
    : S extends { select: any } & (crpNPCDivisionsArgs | crpNPCDivisionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof crpNPCDivisions ? crpNPCDivisions[P] : never
  } 
      : crpNPCDivisions


  type crpNPCDivisionsCountArgs = Merge<
    Omit<crpNPCDivisionsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCDivisionsCountAggregateInputType | true
    }
  >

  export interface crpNPCDivisionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CrpNPCDivisions that matches the filter.
     * @param {crpNPCDivisionsFindUniqueArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCDivisionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, crpNPCDivisionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'crpNPCDivisions'> extends True ? Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>> : Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T> | null, null>

    /**
     * Find the first CrpNPCDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindFirstArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCDivisionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, crpNPCDivisionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'crpNPCDivisions'> extends True ? Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>> : Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T> | null, null>

    /**
     * Find zero or more CrpNPCDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany()
     * 
     * // Get first 10 CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany({ take: 10 })
     * 
     * // Only select the `divisionID`
     * const crpNPCDivisionsWithDivisionIDOnly = await prisma.crpNPCDivisions.findMany({ select: { divisionID: true } })
     * 
    **/
    findMany<T extends crpNPCDivisionsFindManyArgs>(
      args?: SelectSubset<T, crpNPCDivisionsFindManyArgs>
    ): PrismaPromise<Array<crpNPCDivisionsGetPayload<T>>>

    /**
     * Create a CrpNPCDivisions.
     * @param {crpNPCDivisionsCreateArgs} args - Arguments to create a CrpNPCDivisions.
     * @example
     * // Create one CrpNPCDivisions
     * const CrpNPCDivisions = await prisma.crpNPCDivisions.create({
     *   data: {
     *     // ... data to create a CrpNPCDivisions
     *   }
     * })
     * 
    **/
    create<T extends crpNPCDivisionsCreateArgs>(
      args: SelectSubset<T, crpNPCDivisionsCreateArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Create many CrpNPCDivisions.
     *     @param {crpNPCDivisionsCreateManyArgs} args - Arguments to create many CrpNPCDivisions.
     *     @example
     *     // Create many CrpNPCDivisions
     *     const crpNPCDivisions = await prisma.crpNPCDivisions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCDivisionsCreateManyArgs>(
      args?: SelectSubset<T, crpNPCDivisionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCDivisions.
     * @param {crpNPCDivisionsDeleteArgs} args - Arguments to delete one CrpNPCDivisions.
     * @example
     * // Delete one CrpNPCDivisions
     * const CrpNPCDivisions = await prisma.crpNPCDivisions.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCDivisions
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCDivisionsDeleteArgs>(
      args: SelectSubset<T, crpNPCDivisionsDeleteArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Update one CrpNPCDivisions.
     * @param {crpNPCDivisionsUpdateArgs} args - Arguments to update one CrpNPCDivisions.
     * @example
     * // Update one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCDivisionsUpdateArgs>(
      args: SelectSubset<T, crpNPCDivisionsUpdateArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Delete zero or more CrpNPCDivisions.
     * @param {crpNPCDivisionsDeleteManyArgs} args - Arguments to filter CrpNPCDivisions to delete.
     * @example
     * // Delete a few CrpNPCDivisions
     * const { count } = await prisma.crpNPCDivisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCDivisionsDeleteManyArgs>(
      args?: SelectSubset<T, crpNPCDivisionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCDivisionsUpdateManyArgs>(
      args: SelectSubset<T, crpNPCDivisionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCDivisions.
     * @param {crpNPCDivisionsUpsertArgs} args - Arguments to update or create a CrpNPCDivisions.
     * @example
     * // Update or create a CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.upsert({
     *   create: {
     *     // ... data to create a CrpNPCDivisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCDivisions we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCDivisionsUpsertArgs>(
      args: SelectSubset<T, crpNPCDivisionsUpsertArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Find one CrpNPCDivisions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {crpNPCDivisionsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCDivisionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, crpNPCDivisionsFindUniqueOrThrowArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Find the first CrpNPCDivisions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCDivisionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, crpNPCDivisionsFindFirstOrThrowArgs>
    ): Prisma__crpNPCDivisionsClient<crpNPCDivisionsGetPayload<T>>

    /**
     * Count the number of CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsCountArgs} args - Arguments to filter CrpNPCDivisions to count.
     * @example
     * // Count the number of CrpNPCDivisions
     * const count = await prisma.crpNPCDivisions.count({
     *   where: {
     *     // ... the filter for the CrpNPCDivisions we want to count
     *   }
     * })
    **/
    count<T extends crpNPCDivisionsCountArgs>(
      args?: Subset<T, crpNPCDivisionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCDivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCDivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCDivisionsAggregateArgs>(args: Subset<T, CrpNPCDivisionsAggregateArgs>): PrismaPromise<GetCrpNPCDivisionsAggregateType<T>>

    /**
     * Group by CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCDivisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrpNPCDivisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrpNPCDivisionsGroupByArgs['orderBy'] }
        : { orderBy?: CrpNPCDivisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrpNPCDivisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCDivisionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCDivisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__crpNPCDivisionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * crpNPCDivisions base type for findUnique actions
   */
  export type crpNPCDivisionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     * 
    **/
    where: crpNPCDivisionsWhereUniqueInput
  }

  /**
   * crpNPCDivisions: findUnique
   */
  export interface crpNPCDivisionsFindUniqueArgs extends crpNPCDivisionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCDivisions base type for findFirst actions
   */
  export type crpNPCDivisionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     * 
    **/
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCDivisions.
     * 
    **/
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCDivisions.
     * 
    **/
    distinct?: Enumerable<CrpNPCDivisionsScalarFieldEnum>
  }

  /**
   * crpNPCDivisions: findFirst
   */
  export interface crpNPCDivisionsFindFirstArgs extends crpNPCDivisionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * crpNPCDivisions findMany
   */
  export type crpNPCDivisionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     * 
    **/
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     * 
    **/
    orderBy?: Enumerable<crpNPCDivisionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCDivisions.
     * 
    **/
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrpNPCDivisionsScalarFieldEnum>
  }


  /**
   * crpNPCDivisions create
   */
  export type crpNPCDivisionsCreateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * The data needed to create a crpNPCDivisions.
     * 
    **/
    data: XOR<crpNPCDivisionsCreateInput, crpNPCDivisionsUncheckedCreateInput>
  }


  /**
   * crpNPCDivisions createMany
   */
  export type crpNPCDivisionsCreateManyArgs = {
    /**
     * The data used to create many crpNPCDivisions.
     * 
    **/
    data: Enumerable<crpNPCDivisionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * crpNPCDivisions update
   */
  export type crpNPCDivisionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * The data needed to update a crpNPCDivisions.
     * 
    **/
    data: XOR<crpNPCDivisionsUpdateInput, crpNPCDivisionsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCDivisions to update.
     * 
    **/
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions updateMany
   */
  export type crpNPCDivisionsUpdateManyArgs = {
    /**
     * The data used to update crpNPCDivisions.
     * 
    **/
    data: XOR<crpNPCDivisionsUpdateManyMutationInput, crpNPCDivisionsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCDivisions to update
     * 
    **/
    where?: crpNPCDivisionsWhereInput
  }


  /**
   * crpNPCDivisions upsert
   */
  export type crpNPCDivisionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * The filter to search for the crpNPCDivisions to update in case it exists.
     * 
    **/
    where: crpNPCDivisionsWhereUniqueInput
    /**
     * In case the crpNPCDivisions found by the `where` argument doesn't exist, create a new crpNPCDivisions with this data.
     * 
    **/
    create: XOR<crpNPCDivisionsCreateInput, crpNPCDivisionsUncheckedCreateInput>
    /**
     * In case the crpNPCDivisions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<crpNPCDivisionsUpdateInput, crpNPCDivisionsUncheckedUpdateInput>
  }


  /**
   * crpNPCDivisions delete
   */
  export type crpNPCDivisionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
    /**
     * Filter which crpNPCDivisions to delete.
     * 
    **/
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions deleteMany
   */
  export type crpNPCDivisionsDeleteManyArgs = {
    /**
     * Filter which crpNPCDivisions to delete
     * 
    **/
    where?: crpNPCDivisionsWhereInput
  }


  /**
   * crpNPCDivisions: findUniqueOrThrow
   */
  export type crpNPCDivisionsFindUniqueOrThrowArgs = crpNPCDivisionsFindUniqueArgsBase
      

  /**
   * crpNPCDivisions: findFirstOrThrow
   */
  export type crpNPCDivisionsFindFirstOrThrowArgs = crpNPCDivisionsFindFirstArgsBase
      

  /**
   * crpNPCDivisions without action
   */
  export type crpNPCDivisionsArgs = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     * 
    **/
    select?: crpNPCDivisionsSelect | null
  }



  /**
   * Model dgmAttributeCategories
   */


  export type AggregateDgmAttributeCategories = {
    _count: DgmAttributeCategoriesCountAggregateOutputType | null
    _avg: DgmAttributeCategoriesAvgAggregateOutputType | null
    _sum: DgmAttributeCategoriesSumAggregateOutputType | null
    _min: DgmAttributeCategoriesMinAggregateOutputType | null
    _max: DgmAttributeCategoriesMaxAggregateOutputType | null
  }

  export type DgmAttributeCategoriesAvgAggregateOutputType = {
    categoryID: number | null
  }

  export type DgmAttributeCategoriesSumAggregateOutputType = {
    categoryID: number | null
  }

  export type DgmAttributeCategoriesMinAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    categoryDescription: string | null
  }

  export type DgmAttributeCategoriesMaxAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    categoryDescription: string | null
  }

  export type DgmAttributeCategoriesCountAggregateOutputType = {
    categoryID: number
    categoryName: number
    categoryDescription: number
    _all: number
  }


  export type DgmAttributeCategoriesAvgAggregateInputType = {
    categoryID?: true
  }

  export type DgmAttributeCategoriesSumAggregateInputType = {
    categoryID?: true
  }

  export type DgmAttributeCategoriesMinAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
  }

  export type DgmAttributeCategoriesMaxAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
  }

  export type DgmAttributeCategoriesCountAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
    _all?: true
  }

  export type DgmAttributeCategoriesAggregateArgs = {
    /**
     * Filter which dgmAttributeCategories to aggregate.
     * 
    **/
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmAttributeCategories
    **/
    _count?: true | DgmAttributeCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmAttributeCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmAttributeCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmAttributeCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmAttributeCategoriesMaxAggregateInputType
  }

  export type GetDgmAttributeCategoriesAggregateType<T extends DgmAttributeCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmAttributeCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmAttributeCategories[P]>
      : GetScalarType<T[P], AggregateDgmAttributeCategories[P]>
  }




  export type DgmAttributeCategoriesGroupByArgs = {
    where?: dgmAttributeCategoriesWhereInput
    orderBy?: Enumerable<dgmAttributeCategoriesOrderByWithAggregationInput>
    by: Array<DgmAttributeCategoriesScalarFieldEnum>
    having?: dgmAttributeCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmAttributeCategoriesCountAggregateInputType | true
    _avg?: DgmAttributeCategoriesAvgAggregateInputType
    _sum?: DgmAttributeCategoriesSumAggregateInputType
    _min?: DgmAttributeCategoriesMinAggregateInputType
    _max?: DgmAttributeCategoriesMaxAggregateInputType
  }


  export type DgmAttributeCategoriesGroupByOutputType = {
    categoryID: number
    categoryName: string | null
    categoryDescription: string | null
    _count: DgmAttributeCategoriesCountAggregateOutputType | null
    _avg: DgmAttributeCategoriesAvgAggregateOutputType | null
    _sum: DgmAttributeCategoriesSumAggregateOutputType | null
    _min: DgmAttributeCategoriesMinAggregateOutputType | null
    _max: DgmAttributeCategoriesMaxAggregateOutputType | null
  }

  type GetDgmAttributeCategoriesGroupByPayload<T extends DgmAttributeCategoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmAttributeCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmAttributeCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmAttributeCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmAttributeCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type dgmAttributeCategoriesSelect = {
    categoryID?: boolean
    categoryName?: boolean
    categoryDescription?: boolean
  }


  export type dgmAttributeCategoriesGetPayload<S extends boolean | null | undefined | dgmAttributeCategoriesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmAttributeCategories :
    S extends undefined ? never :
    S extends { include: any } & (dgmAttributeCategoriesArgs | dgmAttributeCategoriesFindManyArgs)
    ? dgmAttributeCategories 
    : S extends { select: any } & (dgmAttributeCategoriesArgs | dgmAttributeCategoriesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmAttributeCategories ? dgmAttributeCategories[P] : never
  } 
      : dgmAttributeCategories


  type dgmAttributeCategoriesCountArgs = Merge<
    Omit<dgmAttributeCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: DgmAttributeCategoriesCountAggregateInputType | true
    }
  >

  export interface dgmAttributeCategoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmAttributeCategories that matches the filter.
     * @param {dgmAttributeCategoriesFindUniqueArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmAttributeCategoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmAttributeCategoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmAttributeCategories'> extends True ? Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>> : Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T> | null, null>

    /**
     * Find the first DgmAttributeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindFirstArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmAttributeCategoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmAttributeCategories'> extends True ? Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>> : Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T> | null, null>

    /**
     * Find zero or more DgmAttributeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany()
     * 
     * // Get first 10 DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany({ take: 10 })
     * 
     * // Only select the `categoryID`
     * const dgmAttributeCategoriesWithCategoryIDOnly = await prisma.dgmAttributeCategories.findMany({ select: { categoryID: true } })
     * 
    **/
    findMany<T extends dgmAttributeCategoriesFindManyArgs>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindManyArgs>
    ): PrismaPromise<Array<dgmAttributeCategoriesGetPayload<T>>>

    /**
     * Create a DgmAttributeCategories.
     * @param {dgmAttributeCategoriesCreateArgs} args - Arguments to create a DgmAttributeCategories.
     * @example
     * // Create one DgmAttributeCategories
     * const DgmAttributeCategories = await prisma.dgmAttributeCategories.create({
     *   data: {
     *     // ... data to create a DgmAttributeCategories
     *   }
     * })
     * 
    **/
    create<T extends dgmAttributeCategoriesCreateArgs>(
      args: SelectSubset<T, dgmAttributeCategoriesCreateArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Create many DgmAttributeCategories.
     *     @param {dgmAttributeCategoriesCreateManyArgs} args - Arguments to create many DgmAttributeCategories.
     *     @example
     *     // Create many DgmAttributeCategories
     *     const dgmAttributeCategories = await prisma.dgmAttributeCategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmAttributeCategoriesCreateManyArgs>(
      args?: SelectSubset<T, dgmAttributeCategoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmAttributeCategories.
     * @param {dgmAttributeCategoriesDeleteArgs} args - Arguments to delete one DgmAttributeCategories.
     * @example
     * // Delete one DgmAttributeCategories
     * const DgmAttributeCategories = await prisma.dgmAttributeCategories.delete({
     *   where: {
     *     // ... filter to delete one DgmAttributeCategories
     *   }
     * })
     * 
    **/
    delete<T extends dgmAttributeCategoriesDeleteArgs>(
      args: SelectSubset<T, dgmAttributeCategoriesDeleteArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Update one DgmAttributeCategories.
     * @param {dgmAttributeCategoriesUpdateArgs} args - Arguments to update one DgmAttributeCategories.
     * @example
     * // Update one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmAttributeCategoriesUpdateArgs>(
      args: SelectSubset<T, dgmAttributeCategoriesUpdateArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Delete zero or more DgmAttributeCategories.
     * @param {dgmAttributeCategoriesDeleteManyArgs} args - Arguments to filter DgmAttributeCategories to delete.
     * @example
     * // Delete a few DgmAttributeCategories
     * const { count } = await prisma.dgmAttributeCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmAttributeCategoriesDeleteManyArgs>(
      args?: SelectSubset<T, dgmAttributeCategoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmAttributeCategoriesUpdateManyArgs>(
      args: SelectSubset<T, dgmAttributeCategoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmAttributeCategories.
     * @param {dgmAttributeCategoriesUpsertArgs} args - Arguments to update or create a DgmAttributeCategories.
     * @example
     * // Update or create a DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.upsert({
     *   create: {
     *     // ... data to create a DgmAttributeCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmAttributeCategories we want to update
     *   }
     * })
    **/
    upsert<T extends dgmAttributeCategoriesUpsertArgs>(
      args: SelectSubset<T, dgmAttributeCategoriesUpsertArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Find one DgmAttributeCategories that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmAttributeCategoriesFindUniqueOrThrowArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmAttributeCategoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindUniqueOrThrowArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Find the first DgmAttributeCategories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindFirstOrThrowArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmAttributeCategoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindFirstOrThrowArgs>
    ): Prisma__dgmAttributeCategoriesClient<dgmAttributeCategoriesGetPayload<T>>

    /**
     * Count the number of DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesCountArgs} args - Arguments to filter DgmAttributeCategories to count.
     * @example
     * // Count the number of DgmAttributeCategories
     * const count = await prisma.dgmAttributeCategories.count({
     *   where: {
     *     // ... the filter for the DgmAttributeCategories we want to count
     *   }
     * })
    **/
    count<T extends dgmAttributeCategoriesCountArgs>(
      args?: Subset<T, dgmAttributeCategoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmAttributeCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmAttributeCategoriesAggregateArgs>(args: Subset<T, DgmAttributeCategoriesAggregateArgs>): PrismaPromise<GetDgmAttributeCategoriesAggregateType<T>>

    /**
     * Group by DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmAttributeCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmAttributeCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: DgmAttributeCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmAttributeCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmAttributeCategoriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmAttributeCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmAttributeCategoriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmAttributeCategories base type for findUnique actions
   */
  export type dgmAttributeCategoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     * 
    **/
    where: dgmAttributeCategoriesWhereUniqueInput
  }

  /**
   * dgmAttributeCategories: findUnique
   */
  export interface dgmAttributeCategoriesFindUniqueArgs extends dgmAttributeCategoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmAttributeCategories base type for findFirst actions
   */
  export type dgmAttributeCategoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     * 
    **/
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeCategories.
     * 
    **/
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeCategories.
     * 
    **/
    distinct?: Enumerable<DgmAttributeCategoriesScalarFieldEnum>
  }

  /**
   * dgmAttributeCategories: findFirst
   */
  export interface dgmAttributeCategoriesFindFirstArgs extends dgmAttributeCategoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmAttributeCategories findMany
   */
  export type dgmAttributeCategoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     * 
    **/
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmAttributeCategories.
     * 
    **/
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmAttributeCategoriesScalarFieldEnum>
  }


  /**
   * dgmAttributeCategories create
   */
  export type dgmAttributeCategoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * The data needed to create a dgmAttributeCategories.
     * 
    **/
    data: XOR<dgmAttributeCategoriesCreateInput, dgmAttributeCategoriesUncheckedCreateInput>
  }


  /**
   * dgmAttributeCategories createMany
   */
  export type dgmAttributeCategoriesCreateManyArgs = {
    /**
     * The data used to create many dgmAttributeCategories.
     * 
    **/
    data: Enumerable<dgmAttributeCategoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmAttributeCategories update
   */
  export type dgmAttributeCategoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * The data needed to update a dgmAttributeCategories.
     * 
    **/
    data: XOR<dgmAttributeCategoriesUpdateInput, dgmAttributeCategoriesUncheckedUpdateInput>
    /**
     * Choose, which dgmAttributeCategories to update.
     * 
    **/
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories updateMany
   */
  export type dgmAttributeCategoriesUpdateManyArgs = {
    /**
     * The data used to update dgmAttributeCategories.
     * 
    **/
    data: XOR<dgmAttributeCategoriesUpdateManyMutationInput, dgmAttributeCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which dgmAttributeCategories to update
     * 
    **/
    where?: dgmAttributeCategoriesWhereInput
  }


  /**
   * dgmAttributeCategories upsert
   */
  export type dgmAttributeCategoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * The filter to search for the dgmAttributeCategories to update in case it exists.
     * 
    **/
    where: dgmAttributeCategoriesWhereUniqueInput
    /**
     * In case the dgmAttributeCategories found by the `where` argument doesn't exist, create a new dgmAttributeCategories with this data.
     * 
    **/
    create: XOR<dgmAttributeCategoriesCreateInput, dgmAttributeCategoriesUncheckedCreateInput>
    /**
     * In case the dgmAttributeCategories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmAttributeCategoriesUpdateInput, dgmAttributeCategoriesUncheckedUpdateInput>
  }


  /**
   * dgmAttributeCategories delete
   */
  export type dgmAttributeCategoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
    /**
     * Filter which dgmAttributeCategories to delete.
     * 
    **/
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories deleteMany
   */
  export type dgmAttributeCategoriesDeleteManyArgs = {
    /**
     * Filter which dgmAttributeCategories to delete
     * 
    **/
    where?: dgmAttributeCategoriesWhereInput
  }


  /**
   * dgmAttributeCategories: findUniqueOrThrow
   */
  export type dgmAttributeCategoriesFindUniqueOrThrowArgs = dgmAttributeCategoriesFindUniqueArgsBase
      

  /**
   * dgmAttributeCategories: findFirstOrThrow
   */
  export type dgmAttributeCategoriesFindFirstOrThrowArgs = dgmAttributeCategoriesFindFirstArgsBase
      

  /**
   * dgmAttributeCategories without action
   */
  export type dgmAttributeCategoriesArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     * 
    **/
    select?: dgmAttributeCategoriesSelect | null
  }



  /**
   * Model dgmAttributeTypes
   */


  export type AggregateDgmAttributeTypes = {
    _count: DgmAttributeTypesCountAggregateOutputType | null
    _avg: DgmAttributeTypesAvgAggregateOutputType | null
    _sum: DgmAttributeTypesSumAggregateOutputType | null
    _min: DgmAttributeTypesMinAggregateOutputType | null
    _max: DgmAttributeTypesMaxAggregateOutputType | null
  }

  export type DgmAttributeTypesAvgAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
    defaultValue: number | null
    unitID: number | null
    categoryID: number | null
  }

  export type DgmAttributeTypesSumAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
    defaultValue: number | null
    unitID: number | null
    categoryID: number | null
  }

  export type DgmAttributeTypesMinAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
  }

  export type DgmAttributeTypesMaxAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
  }

  export type DgmAttributeTypesCountAggregateOutputType = {
    attributeID: number
    attributeName: number
    description: number
    iconID: number
    defaultValue: number
    published: number
    displayName: number
    unitID: number
    stackable: number
    highIsGood: number
    categoryID: number
    _all: number
  }


  export type DgmAttributeTypesAvgAggregateInputType = {
    attributeID?: true
    iconID?: true
    defaultValue?: true
    unitID?: true
    categoryID?: true
  }

  export type DgmAttributeTypesSumAggregateInputType = {
    attributeID?: true
    iconID?: true
    defaultValue?: true
    unitID?: true
    categoryID?: true
  }

  export type DgmAttributeTypesMinAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
  }

  export type DgmAttributeTypesMaxAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
  }

  export type DgmAttributeTypesCountAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
    _all?: true
  }

  export type DgmAttributeTypesAggregateArgs = {
    /**
     * Filter which dgmAttributeTypes to aggregate.
     * 
    **/
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmAttributeTypes
    **/
    _count?: true | DgmAttributeTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmAttributeTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmAttributeTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmAttributeTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmAttributeTypesMaxAggregateInputType
  }

  export type GetDgmAttributeTypesAggregateType<T extends DgmAttributeTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmAttributeTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmAttributeTypes[P]>
      : GetScalarType<T[P], AggregateDgmAttributeTypes[P]>
  }




  export type DgmAttributeTypesGroupByArgs = {
    where?: dgmAttributeTypesWhereInput
    orderBy?: Enumerable<dgmAttributeTypesOrderByWithAggregationInput>
    by: Array<DgmAttributeTypesScalarFieldEnum>
    having?: dgmAttributeTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmAttributeTypesCountAggregateInputType | true
    _avg?: DgmAttributeTypesAvgAggregateInputType
    _sum?: DgmAttributeTypesSumAggregateInputType
    _min?: DgmAttributeTypesMinAggregateInputType
    _max?: DgmAttributeTypesMaxAggregateInputType
  }


  export type DgmAttributeTypesGroupByOutputType = {
    attributeID: number
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
    _count: DgmAttributeTypesCountAggregateOutputType | null
    _avg: DgmAttributeTypesAvgAggregateOutputType | null
    _sum: DgmAttributeTypesSumAggregateOutputType | null
    _min: DgmAttributeTypesMinAggregateOutputType | null
    _max: DgmAttributeTypesMaxAggregateOutputType | null
  }

  type GetDgmAttributeTypesGroupByPayload<T extends DgmAttributeTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmAttributeTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmAttributeTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmAttributeTypesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmAttributeTypesGroupByOutputType[P]>
        }
      >
    >


  export type dgmAttributeTypesSelect = {
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    defaultValue?: boolean
    published?: boolean
    displayName?: boolean
    unitID?: boolean
    stackable?: boolean
    highIsGood?: boolean
    categoryID?: boolean
  }


  export type dgmAttributeTypesGetPayload<S extends boolean | null | undefined | dgmAttributeTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmAttributeTypes :
    S extends undefined ? never :
    S extends { include: any } & (dgmAttributeTypesArgs | dgmAttributeTypesFindManyArgs)
    ? dgmAttributeTypes 
    : S extends { select: any } & (dgmAttributeTypesArgs | dgmAttributeTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmAttributeTypes ? dgmAttributeTypes[P] : never
  } 
      : dgmAttributeTypes


  type dgmAttributeTypesCountArgs = Merge<
    Omit<dgmAttributeTypesFindManyArgs, 'select' | 'include'> & {
      select?: DgmAttributeTypesCountAggregateInputType | true
    }
  >

  export interface dgmAttributeTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmAttributeTypes that matches the filter.
     * @param {dgmAttributeTypesFindUniqueArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmAttributeTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmAttributeTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmAttributeTypes'> extends True ? Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>> : Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T> | null, null>

    /**
     * Find the first DgmAttributeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindFirstArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmAttributeTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmAttributeTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmAttributeTypes'> extends True ? Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>> : Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T> | null, null>

    /**
     * Find zero or more DgmAttributeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany()
     * 
     * // Get first 10 DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany({ take: 10 })
     * 
     * // Only select the `attributeID`
     * const dgmAttributeTypesWithAttributeIDOnly = await prisma.dgmAttributeTypes.findMany({ select: { attributeID: true } })
     * 
    **/
    findMany<T extends dgmAttributeTypesFindManyArgs>(
      args?: SelectSubset<T, dgmAttributeTypesFindManyArgs>
    ): PrismaPromise<Array<dgmAttributeTypesGetPayload<T>>>

    /**
     * Create a DgmAttributeTypes.
     * @param {dgmAttributeTypesCreateArgs} args - Arguments to create a DgmAttributeTypes.
     * @example
     * // Create one DgmAttributeTypes
     * const DgmAttributeTypes = await prisma.dgmAttributeTypes.create({
     *   data: {
     *     // ... data to create a DgmAttributeTypes
     *   }
     * })
     * 
    **/
    create<T extends dgmAttributeTypesCreateArgs>(
      args: SelectSubset<T, dgmAttributeTypesCreateArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Create many DgmAttributeTypes.
     *     @param {dgmAttributeTypesCreateManyArgs} args - Arguments to create many DgmAttributeTypes.
     *     @example
     *     // Create many DgmAttributeTypes
     *     const dgmAttributeTypes = await prisma.dgmAttributeTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmAttributeTypesCreateManyArgs>(
      args?: SelectSubset<T, dgmAttributeTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmAttributeTypes.
     * @param {dgmAttributeTypesDeleteArgs} args - Arguments to delete one DgmAttributeTypes.
     * @example
     * // Delete one DgmAttributeTypes
     * const DgmAttributeTypes = await prisma.dgmAttributeTypes.delete({
     *   where: {
     *     // ... filter to delete one DgmAttributeTypes
     *   }
     * })
     * 
    **/
    delete<T extends dgmAttributeTypesDeleteArgs>(
      args: SelectSubset<T, dgmAttributeTypesDeleteArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Update one DgmAttributeTypes.
     * @param {dgmAttributeTypesUpdateArgs} args - Arguments to update one DgmAttributeTypes.
     * @example
     * // Update one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmAttributeTypesUpdateArgs>(
      args: SelectSubset<T, dgmAttributeTypesUpdateArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Delete zero or more DgmAttributeTypes.
     * @param {dgmAttributeTypesDeleteManyArgs} args - Arguments to filter DgmAttributeTypes to delete.
     * @example
     * // Delete a few DgmAttributeTypes
     * const { count } = await prisma.dgmAttributeTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmAttributeTypesDeleteManyArgs>(
      args?: SelectSubset<T, dgmAttributeTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmAttributeTypesUpdateManyArgs>(
      args: SelectSubset<T, dgmAttributeTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmAttributeTypes.
     * @param {dgmAttributeTypesUpsertArgs} args - Arguments to update or create a DgmAttributeTypes.
     * @example
     * // Update or create a DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.upsert({
     *   create: {
     *     // ... data to create a DgmAttributeTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmAttributeTypes we want to update
     *   }
     * })
    **/
    upsert<T extends dgmAttributeTypesUpsertArgs>(
      args: SelectSubset<T, dgmAttributeTypesUpsertArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Find one DgmAttributeTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmAttributeTypesFindUniqueOrThrowArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmAttributeTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmAttributeTypesFindUniqueOrThrowArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Find the first DgmAttributeTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindFirstOrThrowArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmAttributeTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmAttributeTypesFindFirstOrThrowArgs>
    ): Prisma__dgmAttributeTypesClient<dgmAttributeTypesGetPayload<T>>

    /**
     * Count the number of DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesCountArgs} args - Arguments to filter DgmAttributeTypes to count.
     * @example
     * // Count the number of DgmAttributeTypes
     * const count = await prisma.dgmAttributeTypes.count({
     *   where: {
     *     // ... the filter for the DgmAttributeTypes we want to count
     *   }
     * })
    **/
    count<T extends dgmAttributeTypesCountArgs>(
      args?: Subset<T, dgmAttributeTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmAttributeTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmAttributeTypesAggregateArgs>(args: Subset<T, DgmAttributeTypesAggregateArgs>): PrismaPromise<GetDgmAttributeTypesAggregateType<T>>

    /**
     * Group by DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmAttributeTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmAttributeTypesGroupByArgs['orderBy'] }
        : { orderBy?: DgmAttributeTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmAttributeTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmAttributeTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmAttributeTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmAttributeTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmAttributeTypes base type for findUnique actions
   */
  export type dgmAttributeTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     * 
    **/
    where: dgmAttributeTypesWhereUniqueInput
  }

  /**
   * dgmAttributeTypes: findUnique
   */
  export interface dgmAttributeTypesFindUniqueArgs extends dgmAttributeTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmAttributeTypes base type for findFirst actions
   */
  export type dgmAttributeTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     * 
    **/
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeTypes.
     * 
    **/
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeTypes.
     * 
    **/
    distinct?: Enumerable<DgmAttributeTypesScalarFieldEnum>
  }

  /**
   * dgmAttributeTypes: findFirst
   */
  export interface dgmAttributeTypesFindFirstArgs extends dgmAttributeTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmAttributeTypes findMany
   */
  export type dgmAttributeTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     * 
    **/
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmAttributeTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmAttributeTypes.
     * 
    **/
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmAttributeTypesScalarFieldEnum>
  }


  /**
   * dgmAttributeTypes create
   */
  export type dgmAttributeTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * The data needed to create a dgmAttributeTypes.
     * 
    **/
    data: XOR<dgmAttributeTypesCreateInput, dgmAttributeTypesUncheckedCreateInput>
  }


  /**
   * dgmAttributeTypes createMany
   */
  export type dgmAttributeTypesCreateManyArgs = {
    /**
     * The data used to create many dgmAttributeTypes.
     * 
    **/
    data: Enumerable<dgmAttributeTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmAttributeTypes update
   */
  export type dgmAttributeTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * The data needed to update a dgmAttributeTypes.
     * 
    **/
    data: XOR<dgmAttributeTypesUpdateInput, dgmAttributeTypesUncheckedUpdateInput>
    /**
     * Choose, which dgmAttributeTypes to update.
     * 
    **/
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes updateMany
   */
  export type dgmAttributeTypesUpdateManyArgs = {
    /**
     * The data used to update dgmAttributeTypes.
     * 
    **/
    data: XOR<dgmAttributeTypesUpdateManyMutationInput, dgmAttributeTypesUncheckedUpdateManyInput>
    /**
     * Filter which dgmAttributeTypes to update
     * 
    **/
    where?: dgmAttributeTypesWhereInput
  }


  /**
   * dgmAttributeTypes upsert
   */
  export type dgmAttributeTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * The filter to search for the dgmAttributeTypes to update in case it exists.
     * 
    **/
    where: dgmAttributeTypesWhereUniqueInput
    /**
     * In case the dgmAttributeTypes found by the `where` argument doesn't exist, create a new dgmAttributeTypes with this data.
     * 
    **/
    create: XOR<dgmAttributeTypesCreateInput, dgmAttributeTypesUncheckedCreateInput>
    /**
     * In case the dgmAttributeTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmAttributeTypesUpdateInput, dgmAttributeTypesUncheckedUpdateInput>
  }


  /**
   * dgmAttributeTypes delete
   */
  export type dgmAttributeTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
    /**
     * Filter which dgmAttributeTypes to delete.
     * 
    **/
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes deleteMany
   */
  export type dgmAttributeTypesDeleteManyArgs = {
    /**
     * Filter which dgmAttributeTypes to delete
     * 
    **/
    where?: dgmAttributeTypesWhereInput
  }


  /**
   * dgmAttributeTypes: findUniqueOrThrow
   */
  export type dgmAttributeTypesFindUniqueOrThrowArgs = dgmAttributeTypesFindUniqueArgsBase
      

  /**
   * dgmAttributeTypes: findFirstOrThrow
   */
  export type dgmAttributeTypesFindFirstOrThrowArgs = dgmAttributeTypesFindFirstArgsBase
      

  /**
   * dgmAttributeTypes without action
   */
  export type dgmAttributeTypesArgs = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     * 
    **/
    select?: dgmAttributeTypesSelect | null
  }



  /**
   * Model dgmEffects
   */


  export type AggregateDgmEffects = {
    _count: DgmEffectsCountAggregateOutputType | null
    _avg: DgmEffectsAvgAggregateOutputType | null
    _sum: DgmEffectsSumAggregateOutputType | null
    _min: DgmEffectsMinAggregateOutputType | null
    _max: DgmEffectsMaxAggregateOutputType | null
  }

  export type DgmEffectsAvgAggregateOutputType = {
    effectID: number | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    iconID: number | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    distribution: number | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
  }

  export type DgmEffectsSumAggregateOutputType = {
    effectID: number | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    iconID: number | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    distribution: number | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
  }

  export type DgmEffectsMinAggregateOutputType = {
    effectID: number | null
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
  }

  export type DgmEffectsMaxAggregateOutputType = {
    effectID: number | null
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
  }

  export type DgmEffectsCountAggregateOutputType = {
    effectID: number
    effectName: number
    effectCategory: number
    preExpression: number
    postExpression: number
    description: number
    guid: number
    iconID: number
    isOffensive: number
    isAssistance: number
    durationAttributeID: number
    trackingSpeedAttributeID: number
    dischargeAttributeID: number
    rangeAttributeID: number
    falloffAttributeID: number
    disallowAutoRepeat: number
    published: number
    displayName: number
    isWarpSafe: number
    rangeChance: number
    electronicChance: number
    propulsionChance: number
    distribution: number
    sfxName: number
    npcUsageChanceAttributeID: number
    npcActivationChanceAttributeID: number
    fittingUsageChanceAttributeID: number
    modifierInfo: number
    _all: number
  }


  export type DgmEffectsAvgAggregateInputType = {
    effectID?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    iconID?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    distribution?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
  }

  export type DgmEffectsSumAggregateInputType = {
    effectID?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    iconID?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    distribution?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
  }

  export type DgmEffectsMinAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
  }

  export type DgmEffectsMaxAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
  }

  export type DgmEffectsCountAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
    _all?: true
  }

  export type DgmEffectsAggregateArgs = {
    /**
     * Filter which dgmEffects to aggregate.
     * 
    **/
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmEffects
    **/
    _count?: true | DgmEffectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmEffectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmEffectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmEffectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmEffectsMaxAggregateInputType
  }

  export type GetDgmEffectsAggregateType<T extends DgmEffectsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmEffects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmEffects[P]>
      : GetScalarType<T[P], AggregateDgmEffects[P]>
  }




  export type DgmEffectsGroupByArgs = {
    where?: dgmEffectsWhereInput
    orderBy?: Enumerable<dgmEffectsOrderByWithAggregationInput>
    by: Array<DgmEffectsScalarFieldEnum>
    having?: dgmEffectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmEffectsCountAggregateInputType | true
    _avg?: DgmEffectsAvgAggregateInputType
    _sum?: DgmEffectsSumAggregateInputType
    _min?: DgmEffectsMinAggregateInputType
    _max?: DgmEffectsMaxAggregateInputType
  }


  export type DgmEffectsGroupByOutputType = {
    effectID: number
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
    _count: DgmEffectsCountAggregateOutputType | null
    _avg: DgmEffectsAvgAggregateOutputType | null
    _sum: DgmEffectsSumAggregateOutputType | null
    _min: DgmEffectsMinAggregateOutputType | null
    _max: DgmEffectsMaxAggregateOutputType | null
  }

  type GetDgmEffectsGroupByPayload<T extends DgmEffectsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmEffectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmEffectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmEffectsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmEffectsGroupByOutputType[P]>
        }
      >
    >


  export type dgmEffectsSelect = {
    effectID?: boolean
    effectName?: boolean
    effectCategory?: boolean
    preExpression?: boolean
    postExpression?: boolean
    description?: boolean
    guid?: boolean
    iconID?: boolean
    isOffensive?: boolean
    isAssistance?: boolean
    durationAttributeID?: boolean
    trackingSpeedAttributeID?: boolean
    dischargeAttributeID?: boolean
    rangeAttributeID?: boolean
    falloffAttributeID?: boolean
    disallowAutoRepeat?: boolean
    published?: boolean
    displayName?: boolean
    isWarpSafe?: boolean
    rangeChance?: boolean
    electronicChance?: boolean
    propulsionChance?: boolean
    distribution?: boolean
    sfxName?: boolean
    npcUsageChanceAttributeID?: boolean
    npcActivationChanceAttributeID?: boolean
    fittingUsageChanceAttributeID?: boolean
    modifierInfo?: boolean
  }


  export type dgmEffectsGetPayload<S extends boolean | null | undefined | dgmEffectsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmEffects :
    S extends undefined ? never :
    S extends { include: any } & (dgmEffectsArgs | dgmEffectsFindManyArgs)
    ? dgmEffects 
    : S extends { select: any } & (dgmEffectsArgs | dgmEffectsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmEffects ? dgmEffects[P] : never
  } 
      : dgmEffects


  type dgmEffectsCountArgs = Merge<
    Omit<dgmEffectsFindManyArgs, 'select' | 'include'> & {
      select?: DgmEffectsCountAggregateInputType | true
    }
  >

  export interface dgmEffectsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmEffects that matches the filter.
     * @param {dgmEffectsFindUniqueArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmEffectsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmEffectsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmEffects'> extends True ? Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>> : Prisma__dgmEffectsClient<dgmEffectsGetPayload<T> | null, null>

    /**
     * Find the first DgmEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindFirstArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmEffectsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmEffectsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmEffects'> extends True ? Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>> : Prisma__dgmEffectsClient<dgmEffectsGetPayload<T> | null, null>

    /**
     * Find zero or more DgmEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findMany()
     * 
     * // Get first 10 DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findMany({ take: 10 })
     * 
     * // Only select the `effectID`
     * const dgmEffectsWithEffectIDOnly = await prisma.dgmEffects.findMany({ select: { effectID: true } })
     * 
    **/
    findMany<T extends dgmEffectsFindManyArgs>(
      args?: SelectSubset<T, dgmEffectsFindManyArgs>
    ): PrismaPromise<Array<dgmEffectsGetPayload<T>>>

    /**
     * Create a DgmEffects.
     * @param {dgmEffectsCreateArgs} args - Arguments to create a DgmEffects.
     * @example
     * // Create one DgmEffects
     * const DgmEffects = await prisma.dgmEffects.create({
     *   data: {
     *     // ... data to create a DgmEffects
     *   }
     * })
     * 
    **/
    create<T extends dgmEffectsCreateArgs>(
      args: SelectSubset<T, dgmEffectsCreateArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Create many DgmEffects.
     *     @param {dgmEffectsCreateManyArgs} args - Arguments to create many DgmEffects.
     *     @example
     *     // Create many DgmEffects
     *     const dgmEffects = await prisma.dgmEffects.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmEffectsCreateManyArgs>(
      args?: SelectSubset<T, dgmEffectsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmEffects.
     * @param {dgmEffectsDeleteArgs} args - Arguments to delete one DgmEffects.
     * @example
     * // Delete one DgmEffects
     * const DgmEffects = await prisma.dgmEffects.delete({
     *   where: {
     *     // ... filter to delete one DgmEffects
     *   }
     * })
     * 
    **/
    delete<T extends dgmEffectsDeleteArgs>(
      args: SelectSubset<T, dgmEffectsDeleteArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Update one DgmEffects.
     * @param {dgmEffectsUpdateArgs} args - Arguments to update one DgmEffects.
     * @example
     * // Update one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmEffectsUpdateArgs>(
      args: SelectSubset<T, dgmEffectsUpdateArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Delete zero or more DgmEffects.
     * @param {dgmEffectsDeleteManyArgs} args - Arguments to filter DgmEffects to delete.
     * @example
     * // Delete a few DgmEffects
     * const { count } = await prisma.dgmEffects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmEffectsDeleteManyArgs>(
      args?: SelectSubset<T, dgmEffectsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmEffects
     * const dgmEffects = await prisma.dgmEffects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmEffectsUpdateManyArgs>(
      args: SelectSubset<T, dgmEffectsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmEffects.
     * @param {dgmEffectsUpsertArgs} args - Arguments to update or create a DgmEffects.
     * @example
     * // Update or create a DgmEffects
     * const dgmEffects = await prisma.dgmEffects.upsert({
     *   create: {
     *     // ... data to create a DgmEffects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmEffects we want to update
     *   }
     * })
    **/
    upsert<T extends dgmEffectsUpsertArgs>(
      args: SelectSubset<T, dgmEffectsUpsertArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Find one DgmEffects that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmEffectsFindUniqueOrThrowArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmEffectsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmEffectsFindUniqueOrThrowArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Find the first DgmEffects that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindFirstOrThrowArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmEffectsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmEffectsFindFirstOrThrowArgs>
    ): Prisma__dgmEffectsClient<dgmEffectsGetPayload<T>>

    /**
     * Count the number of DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsCountArgs} args - Arguments to filter DgmEffects to count.
     * @example
     * // Count the number of DgmEffects
     * const count = await prisma.dgmEffects.count({
     *   where: {
     *     // ... the filter for the DgmEffects we want to count
     *   }
     * })
    **/
    count<T extends dgmEffectsCountArgs>(
      args?: Subset<T, dgmEffectsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmEffectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmEffectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmEffectsAggregateArgs>(args: Subset<T, DgmEffectsAggregateArgs>): PrismaPromise<GetDgmEffectsAggregateType<T>>

    /**
     * Group by DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmEffectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmEffectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmEffectsGroupByArgs['orderBy'] }
        : { orderBy?: DgmEffectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmEffectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmEffectsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmEffects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmEffectsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmEffects base type for findUnique actions
   */
  export type dgmEffectsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * Filter, which dgmEffects to fetch.
     * 
    **/
    where: dgmEffectsWhereUniqueInput
  }

  /**
   * dgmEffects: findUnique
   */
  export interface dgmEffectsFindUniqueArgs extends dgmEffectsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmEffects base type for findFirst actions
   */
  export type dgmEffectsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * Filter, which dgmEffects to fetch.
     * 
    **/
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmEffects.
     * 
    **/
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmEffects.
     * 
    **/
    distinct?: Enumerable<DgmEffectsScalarFieldEnum>
  }

  /**
   * dgmEffects: findFirst
   */
  export interface dgmEffectsFindFirstArgs extends dgmEffectsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmEffects findMany
   */
  export type dgmEffectsFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * Filter, which dgmEffects to fetch.
     * 
    **/
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmEffects.
     * 
    **/
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmEffectsScalarFieldEnum>
  }


  /**
   * dgmEffects create
   */
  export type dgmEffectsCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * The data needed to create a dgmEffects.
     * 
    **/
    data: XOR<dgmEffectsCreateInput, dgmEffectsUncheckedCreateInput>
  }


  /**
   * dgmEffects createMany
   */
  export type dgmEffectsCreateManyArgs = {
    /**
     * The data used to create many dgmEffects.
     * 
    **/
    data: Enumerable<dgmEffectsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmEffects update
   */
  export type dgmEffectsUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * The data needed to update a dgmEffects.
     * 
    **/
    data: XOR<dgmEffectsUpdateInput, dgmEffectsUncheckedUpdateInput>
    /**
     * Choose, which dgmEffects to update.
     * 
    **/
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects updateMany
   */
  export type dgmEffectsUpdateManyArgs = {
    /**
     * The data used to update dgmEffects.
     * 
    **/
    data: XOR<dgmEffectsUpdateManyMutationInput, dgmEffectsUncheckedUpdateManyInput>
    /**
     * Filter which dgmEffects to update
     * 
    **/
    where?: dgmEffectsWhereInput
  }


  /**
   * dgmEffects upsert
   */
  export type dgmEffectsUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * The filter to search for the dgmEffects to update in case it exists.
     * 
    **/
    where: dgmEffectsWhereUniqueInput
    /**
     * In case the dgmEffects found by the `where` argument doesn't exist, create a new dgmEffects with this data.
     * 
    **/
    create: XOR<dgmEffectsCreateInput, dgmEffectsUncheckedCreateInput>
    /**
     * In case the dgmEffects was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmEffectsUpdateInput, dgmEffectsUncheckedUpdateInput>
  }


  /**
   * dgmEffects delete
   */
  export type dgmEffectsDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
    /**
     * Filter which dgmEffects to delete.
     * 
    **/
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects deleteMany
   */
  export type dgmEffectsDeleteManyArgs = {
    /**
     * Filter which dgmEffects to delete
     * 
    **/
    where?: dgmEffectsWhereInput
  }


  /**
   * dgmEffects: findUniqueOrThrow
   */
  export type dgmEffectsFindUniqueOrThrowArgs = dgmEffectsFindUniqueArgsBase
      

  /**
   * dgmEffects: findFirstOrThrow
   */
  export type dgmEffectsFindFirstOrThrowArgs = dgmEffectsFindFirstArgsBase
      

  /**
   * dgmEffects without action
   */
  export type dgmEffectsArgs = {
    /**
     * Select specific fields to fetch from the dgmEffects
     * 
    **/
    select?: dgmEffectsSelect | null
  }



  /**
   * Model dgmExpressions
   */


  export type AggregateDgmExpressions = {
    _count: DgmExpressionsCountAggregateOutputType | null
    _avg: DgmExpressionsAvgAggregateOutputType | null
    _sum: DgmExpressionsSumAggregateOutputType | null
    _min: DgmExpressionsMinAggregateOutputType | null
    _max: DgmExpressionsMaxAggregateOutputType | null
  }

  export type DgmExpressionsAvgAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsSumAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsMinAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsMaxAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsCountAggregateOutputType = {
    expressionID: number
    operandID: number
    arg1: number
    arg2: number
    expressionValue: number
    description: number
    expressionName: number
    expressionTypeID: number
    expressionGroupID: number
    expressionAttributeID: number
    _all: number
  }


  export type DgmExpressionsAvgAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsSumAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsMinAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsMaxAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsCountAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
    _all?: true
  }

  export type DgmExpressionsAggregateArgs = {
    /**
     * Filter which dgmExpressions to aggregate.
     * 
    **/
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmExpressionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmExpressions
    **/
    _count?: true | DgmExpressionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmExpressionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmExpressionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmExpressionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmExpressionsMaxAggregateInputType
  }

  export type GetDgmExpressionsAggregateType<T extends DgmExpressionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmExpressions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmExpressions[P]>
      : GetScalarType<T[P], AggregateDgmExpressions[P]>
  }




  export type DgmExpressionsGroupByArgs = {
    where?: dgmExpressionsWhereInput
    orderBy?: Enumerable<dgmExpressionsOrderByWithAggregationInput>
    by: Array<DgmExpressionsScalarFieldEnum>
    having?: dgmExpressionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmExpressionsCountAggregateInputType | true
    _avg?: DgmExpressionsAvgAggregateInputType
    _sum?: DgmExpressionsSumAggregateInputType
    _min?: DgmExpressionsMinAggregateInputType
    _max?: DgmExpressionsMaxAggregateInputType
  }


  export type DgmExpressionsGroupByOutputType = {
    expressionID: number
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
    _count: DgmExpressionsCountAggregateOutputType | null
    _avg: DgmExpressionsAvgAggregateOutputType | null
    _sum: DgmExpressionsSumAggregateOutputType | null
    _min: DgmExpressionsMinAggregateOutputType | null
    _max: DgmExpressionsMaxAggregateOutputType | null
  }

  type GetDgmExpressionsGroupByPayload<T extends DgmExpressionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmExpressionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmExpressionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmExpressionsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmExpressionsGroupByOutputType[P]>
        }
      >
    >


  export type dgmExpressionsSelect = {
    expressionID?: boolean
    operandID?: boolean
    arg1?: boolean
    arg2?: boolean
    expressionValue?: boolean
    description?: boolean
    expressionName?: boolean
    expressionTypeID?: boolean
    expressionGroupID?: boolean
    expressionAttributeID?: boolean
  }


  export type dgmExpressionsGetPayload<S extends boolean | null | undefined | dgmExpressionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmExpressions :
    S extends undefined ? never :
    S extends { include: any } & (dgmExpressionsArgs | dgmExpressionsFindManyArgs)
    ? dgmExpressions 
    : S extends { select: any } & (dgmExpressionsArgs | dgmExpressionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmExpressions ? dgmExpressions[P] : never
  } 
      : dgmExpressions


  type dgmExpressionsCountArgs = Merge<
    Omit<dgmExpressionsFindManyArgs, 'select' | 'include'> & {
      select?: DgmExpressionsCountAggregateInputType | true
    }
  >

  export interface dgmExpressionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmExpressions that matches the filter.
     * @param {dgmExpressionsFindUniqueArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmExpressionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmExpressionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmExpressions'> extends True ? Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>> : Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T> | null, null>

    /**
     * Find the first DgmExpressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindFirstArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmExpressionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmExpressionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmExpressions'> extends True ? Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>> : Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T> | null, null>

    /**
     * Find zero or more DgmExpressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findMany()
     * 
     * // Get first 10 DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findMany({ take: 10 })
     * 
     * // Only select the `expressionID`
     * const dgmExpressionsWithExpressionIDOnly = await prisma.dgmExpressions.findMany({ select: { expressionID: true } })
     * 
    **/
    findMany<T extends dgmExpressionsFindManyArgs>(
      args?: SelectSubset<T, dgmExpressionsFindManyArgs>
    ): PrismaPromise<Array<dgmExpressionsGetPayload<T>>>

    /**
     * Create a DgmExpressions.
     * @param {dgmExpressionsCreateArgs} args - Arguments to create a DgmExpressions.
     * @example
     * // Create one DgmExpressions
     * const DgmExpressions = await prisma.dgmExpressions.create({
     *   data: {
     *     // ... data to create a DgmExpressions
     *   }
     * })
     * 
    **/
    create<T extends dgmExpressionsCreateArgs>(
      args: SelectSubset<T, dgmExpressionsCreateArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Create many DgmExpressions.
     *     @param {dgmExpressionsCreateManyArgs} args - Arguments to create many DgmExpressions.
     *     @example
     *     // Create many DgmExpressions
     *     const dgmExpressions = await prisma.dgmExpressions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmExpressionsCreateManyArgs>(
      args?: SelectSubset<T, dgmExpressionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmExpressions.
     * @param {dgmExpressionsDeleteArgs} args - Arguments to delete one DgmExpressions.
     * @example
     * // Delete one DgmExpressions
     * const DgmExpressions = await prisma.dgmExpressions.delete({
     *   where: {
     *     // ... filter to delete one DgmExpressions
     *   }
     * })
     * 
    **/
    delete<T extends dgmExpressionsDeleteArgs>(
      args: SelectSubset<T, dgmExpressionsDeleteArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Update one DgmExpressions.
     * @param {dgmExpressionsUpdateArgs} args - Arguments to update one DgmExpressions.
     * @example
     * // Update one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmExpressionsUpdateArgs>(
      args: SelectSubset<T, dgmExpressionsUpdateArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Delete zero or more DgmExpressions.
     * @param {dgmExpressionsDeleteManyArgs} args - Arguments to filter DgmExpressions to delete.
     * @example
     * // Delete a few DgmExpressions
     * const { count } = await prisma.dgmExpressions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmExpressionsDeleteManyArgs>(
      args?: SelectSubset<T, dgmExpressionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmExpressionsUpdateManyArgs>(
      args: SelectSubset<T, dgmExpressionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmExpressions.
     * @param {dgmExpressionsUpsertArgs} args - Arguments to update or create a DgmExpressions.
     * @example
     * // Update or create a DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.upsert({
     *   create: {
     *     // ... data to create a DgmExpressions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmExpressions we want to update
     *   }
     * })
    **/
    upsert<T extends dgmExpressionsUpsertArgs>(
      args: SelectSubset<T, dgmExpressionsUpsertArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Find one DgmExpressions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmExpressionsFindUniqueOrThrowArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmExpressionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmExpressionsFindUniqueOrThrowArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Find the first DgmExpressions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindFirstOrThrowArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmExpressionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmExpressionsFindFirstOrThrowArgs>
    ): Prisma__dgmExpressionsClient<dgmExpressionsGetPayload<T>>

    /**
     * Count the number of DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsCountArgs} args - Arguments to filter DgmExpressions to count.
     * @example
     * // Count the number of DgmExpressions
     * const count = await prisma.dgmExpressions.count({
     *   where: {
     *     // ... the filter for the DgmExpressions we want to count
     *   }
     * })
    **/
    count<T extends dgmExpressionsCountArgs>(
      args?: Subset<T, dgmExpressionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmExpressionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmExpressionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmExpressionsAggregateArgs>(args: Subset<T, DgmExpressionsAggregateArgs>): PrismaPromise<GetDgmExpressionsAggregateType<T>>

    /**
     * Group by DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmExpressionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmExpressionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmExpressionsGroupByArgs['orderBy'] }
        : { orderBy?: DgmExpressionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmExpressionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmExpressionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmExpressions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmExpressionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmExpressions base type for findUnique actions
   */
  export type dgmExpressionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * Filter, which dgmExpressions to fetch.
     * 
    **/
    where: dgmExpressionsWhereUniqueInput
  }

  /**
   * dgmExpressions: findUnique
   */
  export interface dgmExpressionsFindUniqueArgs extends dgmExpressionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmExpressions base type for findFirst actions
   */
  export type dgmExpressionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * Filter, which dgmExpressions to fetch.
     * 
    **/
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmExpressionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmExpressions.
     * 
    **/
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmExpressions.
     * 
    **/
    distinct?: Enumerable<DgmExpressionsScalarFieldEnum>
  }

  /**
   * dgmExpressions: findFirst
   */
  export interface dgmExpressionsFindFirstArgs extends dgmExpressionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmExpressions findMany
   */
  export type dgmExpressionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * Filter, which dgmExpressions to fetch.
     * 
    **/
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmExpressionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmExpressions.
     * 
    **/
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmExpressionsScalarFieldEnum>
  }


  /**
   * dgmExpressions create
   */
  export type dgmExpressionsCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * The data needed to create a dgmExpressions.
     * 
    **/
    data: XOR<dgmExpressionsCreateInput, dgmExpressionsUncheckedCreateInput>
  }


  /**
   * dgmExpressions createMany
   */
  export type dgmExpressionsCreateManyArgs = {
    /**
     * The data used to create many dgmExpressions.
     * 
    **/
    data: Enumerable<dgmExpressionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmExpressions update
   */
  export type dgmExpressionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * The data needed to update a dgmExpressions.
     * 
    **/
    data: XOR<dgmExpressionsUpdateInput, dgmExpressionsUncheckedUpdateInput>
    /**
     * Choose, which dgmExpressions to update.
     * 
    **/
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions updateMany
   */
  export type dgmExpressionsUpdateManyArgs = {
    /**
     * The data used to update dgmExpressions.
     * 
    **/
    data: XOR<dgmExpressionsUpdateManyMutationInput, dgmExpressionsUncheckedUpdateManyInput>
    /**
     * Filter which dgmExpressions to update
     * 
    **/
    where?: dgmExpressionsWhereInput
  }


  /**
   * dgmExpressions upsert
   */
  export type dgmExpressionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * The filter to search for the dgmExpressions to update in case it exists.
     * 
    **/
    where: dgmExpressionsWhereUniqueInput
    /**
     * In case the dgmExpressions found by the `where` argument doesn't exist, create a new dgmExpressions with this data.
     * 
    **/
    create: XOR<dgmExpressionsCreateInput, dgmExpressionsUncheckedCreateInput>
    /**
     * In case the dgmExpressions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmExpressionsUpdateInput, dgmExpressionsUncheckedUpdateInput>
  }


  /**
   * dgmExpressions delete
   */
  export type dgmExpressionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
    /**
     * Filter which dgmExpressions to delete.
     * 
    **/
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions deleteMany
   */
  export type dgmExpressionsDeleteManyArgs = {
    /**
     * Filter which dgmExpressions to delete
     * 
    **/
    where?: dgmExpressionsWhereInput
  }


  /**
   * dgmExpressions: findUniqueOrThrow
   */
  export type dgmExpressionsFindUniqueOrThrowArgs = dgmExpressionsFindUniqueArgsBase
      

  /**
   * dgmExpressions: findFirstOrThrow
   */
  export type dgmExpressionsFindFirstOrThrowArgs = dgmExpressionsFindFirstArgsBase
      

  /**
   * dgmExpressions without action
   */
  export type dgmExpressionsArgs = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     * 
    **/
    select?: dgmExpressionsSelect | null
  }



  /**
   * Model dgmTypeAttributes
   */


  export type AggregateDgmTypeAttributes = {
    _count: DgmTypeAttributesCountAggregateOutputType | null
    _avg: DgmTypeAttributesAvgAggregateOutputType | null
    _sum: DgmTypeAttributesSumAggregateOutputType | null
    _min: DgmTypeAttributesMinAggregateOutputType | null
    _max: DgmTypeAttributesMaxAggregateOutputType | null
  }

  export type DgmTypeAttributesAvgAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesSumAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesMinAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesMaxAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesCountAggregateOutputType = {
    typeID: number
    attributeID: number
    valueInt: number
    valueFloat: number
    _all: number
  }


  export type DgmTypeAttributesAvgAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesSumAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesMinAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesMaxAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesCountAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
    _all?: true
  }

  export type DgmTypeAttributesAggregateArgs = {
    /**
     * Filter which dgmTypeAttributes to aggregate.
     * 
    **/
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmTypeAttributes
    **/
    _count?: true | DgmTypeAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmTypeAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmTypeAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmTypeAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmTypeAttributesMaxAggregateInputType
  }

  export type GetDgmTypeAttributesAggregateType<T extends DgmTypeAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmTypeAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmTypeAttributes[P]>
      : GetScalarType<T[P], AggregateDgmTypeAttributes[P]>
  }




  export type DgmTypeAttributesGroupByArgs = {
    where?: dgmTypeAttributesWhereInput
    orderBy?: Enumerable<dgmTypeAttributesOrderByWithAggregationInput>
    by: Array<DgmTypeAttributesScalarFieldEnum>
    having?: dgmTypeAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmTypeAttributesCountAggregateInputType | true
    _avg?: DgmTypeAttributesAvgAggregateInputType
    _sum?: DgmTypeAttributesSumAggregateInputType
    _min?: DgmTypeAttributesMinAggregateInputType
    _max?: DgmTypeAttributesMaxAggregateInputType
  }


  export type DgmTypeAttributesGroupByOutputType = {
    typeID: number
    attributeID: number
    valueInt: number | null
    valueFloat: number | null
    _count: DgmTypeAttributesCountAggregateOutputType | null
    _avg: DgmTypeAttributesAvgAggregateOutputType | null
    _sum: DgmTypeAttributesSumAggregateOutputType | null
    _min: DgmTypeAttributesMinAggregateOutputType | null
    _max: DgmTypeAttributesMaxAggregateOutputType | null
  }

  type GetDgmTypeAttributesGroupByPayload<T extends DgmTypeAttributesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmTypeAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmTypeAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmTypeAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmTypeAttributesGroupByOutputType[P]>
        }
      >
    >


  export type dgmTypeAttributesSelect = {
    typeID?: boolean
    attributeID?: boolean
    valueInt?: boolean
    valueFloat?: boolean
  }


  export type dgmTypeAttributesGetPayload<S extends boolean | null | undefined | dgmTypeAttributesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmTypeAttributes :
    S extends undefined ? never :
    S extends { include: any } & (dgmTypeAttributesArgs | dgmTypeAttributesFindManyArgs)
    ? dgmTypeAttributes 
    : S extends { select: any } & (dgmTypeAttributesArgs | dgmTypeAttributesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmTypeAttributes ? dgmTypeAttributes[P] : never
  } 
      : dgmTypeAttributes


  type dgmTypeAttributesCountArgs = Merge<
    Omit<dgmTypeAttributesFindManyArgs, 'select' | 'include'> & {
      select?: DgmTypeAttributesCountAggregateInputType | true
    }
  >

  export interface dgmTypeAttributesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmTypeAttributes that matches the filter.
     * @param {dgmTypeAttributesFindUniqueArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmTypeAttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmTypeAttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmTypeAttributes'> extends True ? Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>> : Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T> | null, null>

    /**
     * Find the first DgmTypeAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindFirstArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmTypeAttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmTypeAttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmTypeAttributes'> extends True ? Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>> : Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T> | null, null>

    /**
     * Find zero or more DgmTypeAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany()
     * 
     * // Get first 10 DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const dgmTypeAttributesWithTypeIDOnly = await prisma.dgmTypeAttributes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends dgmTypeAttributesFindManyArgs>(
      args?: SelectSubset<T, dgmTypeAttributesFindManyArgs>
    ): PrismaPromise<Array<dgmTypeAttributesGetPayload<T>>>

    /**
     * Create a DgmTypeAttributes.
     * @param {dgmTypeAttributesCreateArgs} args - Arguments to create a DgmTypeAttributes.
     * @example
     * // Create one DgmTypeAttributes
     * const DgmTypeAttributes = await prisma.dgmTypeAttributes.create({
     *   data: {
     *     // ... data to create a DgmTypeAttributes
     *   }
     * })
     * 
    **/
    create<T extends dgmTypeAttributesCreateArgs>(
      args: SelectSubset<T, dgmTypeAttributesCreateArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Create many DgmTypeAttributes.
     *     @param {dgmTypeAttributesCreateManyArgs} args - Arguments to create many DgmTypeAttributes.
     *     @example
     *     // Create many DgmTypeAttributes
     *     const dgmTypeAttributes = await prisma.dgmTypeAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmTypeAttributesCreateManyArgs>(
      args?: SelectSubset<T, dgmTypeAttributesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmTypeAttributes.
     * @param {dgmTypeAttributesDeleteArgs} args - Arguments to delete one DgmTypeAttributes.
     * @example
     * // Delete one DgmTypeAttributes
     * const DgmTypeAttributes = await prisma.dgmTypeAttributes.delete({
     *   where: {
     *     // ... filter to delete one DgmTypeAttributes
     *   }
     * })
     * 
    **/
    delete<T extends dgmTypeAttributesDeleteArgs>(
      args: SelectSubset<T, dgmTypeAttributesDeleteArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Update one DgmTypeAttributes.
     * @param {dgmTypeAttributesUpdateArgs} args - Arguments to update one DgmTypeAttributes.
     * @example
     * // Update one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmTypeAttributesUpdateArgs>(
      args: SelectSubset<T, dgmTypeAttributesUpdateArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Delete zero or more DgmTypeAttributes.
     * @param {dgmTypeAttributesDeleteManyArgs} args - Arguments to filter DgmTypeAttributes to delete.
     * @example
     * // Delete a few DgmTypeAttributes
     * const { count } = await prisma.dgmTypeAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmTypeAttributesDeleteManyArgs>(
      args?: SelectSubset<T, dgmTypeAttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmTypeAttributesUpdateManyArgs>(
      args: SelectSubset<T, dgmTypeAttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmTypeAttributes.
     * @param {dgmTypeAttributesUpsertArgs} args - Arguments to update or create a DgmTypeAttributes.
     * @example
     * // Update or create a DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.upsert({
     *   create: {
     *     // ... data to create a DgmTypeAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmTypeAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends dgmTypeAttributesUpsertArgs>(
      args: SelectSubset<T, dgmTypeAttributesUpsertArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Find one DgmTypeAttributes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmTypeAttributesFindUniqueOrThrowArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmTypeAttributesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmTypeAttributesFindUniqueOrThrowArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Find the first DgmTypeAttributes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindFirstOrThrowArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmTypeAttributesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmTypeAttributesFindFirstOrThrowArgs>
    ): Prisma__dgmTypeAttributesClient<dgmTypeAttributesGetPayload<T>>

    /**
     * Count the number of DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesCountArgs} args - Arguments to filter DgmTypeAttributes to count.
     * @example
     * // Count the number of DgmTypeAttributes
     * const count = await prisma.dgmTypeAttributes.count({
     *   where: {
     *     // ... the filter for the DgmTypeAttributes we want to count
     *   }
     * })
    **/
    count<T extends dgmTypeAttributesCountArgs>(
      args?: Subset<T, dgmTypeAttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmTypeAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmTypeAttributesAggregateArgs>(args: Subset<T, DgmTypeAttributesAggregateArgs>): PrismaPromise<GetDgmTypeAttributesAggregateType<T>>

    /**
     * Group by DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmTypeAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmTypeAttributesGroupByArgs['orderBy'] }
        : { orderBy?: DgmTypeAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmTypeAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmTypeAttributesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmTypeAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmTypeAttributesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmTypeAttributes base type for findUnique actions
   */
  export type dgmTypeAttributesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     * 
    **/
    where: dgmTypeAttributesWhereUniqueInput
  }

  /**
   * dgmTypeAttributes: findUnique
   */
  export interface dgmTypeAttributesFindUniqueArgs extends dgmTypeAttributesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmTypeAttributes base type for findFirst actions
   */
  export type dgmTypeAttributesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     * 
    **/
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeAttributes.
     * 
    **/
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeAttributes.
     * 
    **/
    distinct?: Enumerable<DgmTypeAttributesScalarFieldEnum>
  }

  /**
   * dgmTypeAttributes: findFirst
   */
  export interface dgmTypeAttributesFindFirstArgs extends dgmTypeAttributesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmTypeAttributes findMany
   */
  export type dgmTypeAttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     * 
    **/
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmTypeAttributes.
     * 
    **/
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmTypeAttributesScalarFieldEnum>
  }


  /**
   * dgmTypeAttributes create
   */
  export type dgmTypeAttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * The data needed to create a dgmTypeAttributes.
     * 
    **/
    data: XOR<dgmTypeAttributesCreateInput, dgmTypeAttributesUncheckedCreateInput>
  }


  /**
   * dgmTypeAttributes createMany
   */
  export type dgmTypeAttributesCreateManyArgs = {
    /**
     * The data used to create many dgmTypeAttributes.
     * 
    **/
    data: Enumerable<dgmTypeAttributesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmTypeAttributes update
   */
  export type dgmTypeAttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * The data needed to update a dgmTypeAttributes.
     * 
    **/
    data: XOR<dgmTypeAttributesUpdateInput, dgmTypeAttributesUncheckedUpdateInput>
    /**
     * Choose, which dgmTypeAttributes to update.
     * 
    **/
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes updateMany
   */
  export type dgmTypeAttributesUpdateManyArgs = {
    /**
     * The data used to update dgmTypeAttributes.
     * 
    **/
    data: XOR<dgmTypeAttributesUpdateManyMutationInput, dgmTypeAttributesUncheckedUpdateManyInput>
    /**
     * Filter which dgmTypeAttributes to update
     * 
    **/
    where?: dgmTypeAttributesWhereInput
  }


  /**
   * dgmTypeAttributes upsert
   */
  export type dgmTypeAttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * The filter to search for the dgmTypeAttributes to update in case it exists.
     * 
    **/
    where: dgmTypeAttributesWhereUniqueInput
    /**
     * In case the dgmTypeAttributes found by the `where` argument doesn't exist, create a new dgmTypeAttributes with this data.
     * 
    **/
    create: XOR<dgmTypeAttributesCreateInput, dgmTypeAttributesUncheckedCreateInput>
    /**
     * In case the dgmTypeAttributes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmTypeAttributesUpdateInput, dgmTypeAttributesUncheckedUpdateInput>
  }


  /**
   * dgmTypeAttributes delete
   */
  export type dgmTypeAttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
    /**
     * Filter which dgmTypeAttributes to delete.
     * 
    **/
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes deleteMany
   */
  export type dgmTypeAttributesDeleteManyArgs = {
    /**
     * Filter which dgmTypeAttributes to delete
     * 
    **/
    where?: dgmTypeAttributesWhereInput
  }


  /**
   * dgmTypeAttributes: findUniqueOrThrow
   */
  export type dgmTypeAttributesFindUniqueOrThrowArgs = dgmTypeAttributesFindUniqueArgsBase
      

  /**
   * dgmTypeAttributes: findFirstOrThrow
   */
  export type dgmTypeAttributesFindFirstOrThrowArgs = dgmTypeAttributesFindFirstArgsBase
      

  /**
   * dgmTypeAttributes without action
   */
  export type dgmTypeAttributesArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     * 
    **/
    select?: dgmTypeAttributesSelect | null
  }



  /**
   * Model dgmTypeEffects
   */


  export type AggregateDgmTypeEffects = {
    _count: DgmTypeEffectsCountAggregateOutputType | null
    _avg: DgmTypeEffectsAvgAggregateOutputType | null
    _sum: DgmTypeEffectsSumAggregateOutputType | null
    _min: DgmTypeEffectsMinAggregateOutputType | null
    _max: DgmTypeEffectsMaxAggregateOutputType | null
  }

  export type DgmTypeEffectsAvgAggregateOutputType = {
    typeID: number | null
    effectID: number | null
  }

  export type DgmTypeEffectsSumAggregateOutputType = {
    typeID: number | null
    effectID: number | null
  }

  export type DgmTypeEffectsMinAggregateOutputType = {
    typeID: number | null
    effectID: number | null
    isDefault: boolean | null
  }

  export type DgmTypeEffectsMaxAggregateOutputType = {
    typeID: number | null
    effectID: number | null
    isDefault: boolean | null
  }

  export type DgmTypeEffectsCountAggregateOutputType = {
    typeID: number
    effectID: number
    isDefault: number
    _all: number
  }


  export type DgmTypeEffectsAvgAggregateInputType = {
    typeID?: true
    effectID?: true
  }

  export type DgmTypeEffectsSumAggregateInputType = {
    typeID?: true
    effectID?: true
  }

  export type DgmTypeEffectsMinAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
  }

  export type DgmTypeEffectsMaxAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
  }

  export type DgmTypeEffectsCountAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
    _all?: true
  }

  export type DgmTypeEffectsAggregateArgs = {
    /**
     * Filter which dgmTypeEffects to aggregate.
     * 
    **/
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmTypeEffects
    **/
    _count?: true | DgmTypeEffectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmTypeEffectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmTypeEffectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmTypeEffectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmTypeEffectsMaxAggregateInputType
  }

  export type GetDgmTypeEffectsAggregateType<T extends DgmTypeEffectsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmTypeEffects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmTypeEffects[P]>
      : GetScalarType<T[P], AggregateDgmTypeEffects[P]>
  }




  export type DgmTypeEffectsGroupByArgs = {
    where?: dgmTypeEffectsWhereInput
    orderBy?: Enumerable<dgmTypeEffectsOrderByWithAggregationInput>
    by: Array<DgmTypeEffectsScalarFieldEnum>
    having?: dgmTypeEffectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmTypeEffectsCountAggregateInputType | true
    _avg?: DgmTypeEffectsAvgAggregateInputType
    _sum?: DgmTypeEffectsSumAggregateInputType
    _min?: DgmTypeEffectsMinAggregateInputType
    _max?: DgmTypeEffectsMaxAggregateInputType
  }


  export type DgmTypeEffectsGroupByOutputType = {
    typeID: number
    effectID: number
    isDefault: boolean | null
    _count: DgmTypeEffectsCountAggregateOutputType | null
    _avg: DgmTypeEffectsAvgAggregateOutputType | null
    _sum: DgmTypeEffectsSumAggregateOutputType | null
    _min: DgmTypeEffectsMinAggregateOutputType | null
    _max: DgmTypeEffectsMaxAggregateOutputType | null
  }

  type GetDgmTypeEffectsGroupByPayload<T extends DgmTypeEffectsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DgmTypeEffectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmTypeEffectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmTypeEffectsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmTypeEffectsGroupByOutputType[P]>
        }
      >
    >


  export type dgmTypeEffectsSelect = {
    typeID?: boolean
    effectID?: boolean
    isDefault?: boolean
  }


  export type dgmTypeEffectsGetPayload<S extends boolean | null | undefined | dgmTypeEffectsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? dgmTypeEffects :
    S extends undefined ? never :
    S extends { include: any } & (dgmTypeEffectsArgs | dgmTypeEffectsFindManyArgs)
    ? dgmTypeEffects 
    : S extends { select: any } & (dgmTypeEffectsArgs | dgmTypeEffectsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof dgmTypeEffects ? dgmTypeEffects[P] : never
  } 
      : dgmTypeEffects


  type dgmTypeEffectsCountArgs = Merge<
    Omit<dgmTypeEffectsFindManyArgs, 'select' | 'include'> & {
      select?: DgmTypeEffectsCountAggregateInputType | true
    }
  >

  export interface dgmTypeEffectsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DgmTypeEffects that matches the filter.
     * @param {dgmTypeEffectsFindUniqueArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmTypeEffectsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dgmTypeEffectsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dgmTypeEffects'> extends True ? Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>> : Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T> | null, null>

    /**
     * Find the first DgmTypeEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindFirstArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmTypeEffectsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dgmTypeEffectsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dgmTypeEffects'> extends True ? Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>> : Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T> | null, null>

    /**
     * Find zero or more DgmTypeEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany()
     * 
     * // Get first 10 DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const dgmTypeEffectsWithTypeIDOnly = await prisma.dgmTypeEffects.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends dgmTypeEffectsFindManyArgs>(
      args?: SelectSubset<T, dgmTypeEffectsFindManyArgs>
    ): PrismaPromise<Array<dgmTypeEffectsGetPayload<T>>>

    /**
     * Create a DgmTypeEffects.
     * @param {dgmTypeEffectsCreateArgs} args - Arguments to create a DgmTypeEffects.
     * @example
     * // Create one DgmTypeEffects
     * const DgmTypeEffects = await prisma.dgmTypeEffects.create({
     *   data: {
     *     // ... data to create a DgmTypeEffects
     *   }
     * })
     * 
    **/
    create<T extends dgmTypeEffectsCreateArgs>(
      args: SelectSubset<T, dgmTypeEffectsCreateArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Create many DgmTypeEffects.
     *     @param {dgmTypeEffectsCreateManyArgs} args - Arguments to create many DgmTypeEffects.
     *     @example
     *     // Create many DgmTypeEffects
     *     const dgmTypeEffects = await prisma.dgmTypeEffects.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmTypeEffectsCreateManyArgs>(
      args?: SelectSubset<T, dgmTypeEffectsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DgmTypeEffects.
     * @param {dgmTypeEffectsDeleteArgs} args - Arguments to delete one DgmTypeEffects.
     * @example
     * // Delete one DgmTypeEffects
     * const DgmTypeEffects = await prisma.dgmTypeEffects.delete({
     *   where: {
     *     // ... filter to delete one DgmTypeEffects
     *   }
     * })
     * 
    **/
    delete<T extends dgmTypeEffectsDeleteArgs>(
      args: SelectSubset<T, dgmTypeEffectsDeleteArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Update one DgmTypeEffects.
     * @param {dgmTypeEffectsUpdateArgs} args - Arguments to update one DgmTypeEffects.
     * @example
     * // Update one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmTypeEffectsUpdateArgs>(
      args: SelectSubset<T, dgmTypeEffectsUpdateArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Delete zero or more DgmTypeEffects.
     * @param {dgmTypeEffectsDeleteManyArgs} args - Arguments to filter DgmTypeEffects to delete.
     * @example
     * // Delete a few DgmTypeEffects
     * const { count } = await prisma.dgmTypeEffects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmTypeEffectsDeleteManyArgs>(
      args?: SelectSubset<T, dgmTypeEffectsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmTypeEffectsUpdateManyArgs>(
      args: SelectSubset<T, dgmTypeEffectsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmTypeEffects.
     * @param {dgmTypeEffectsUpsertArgs} args - Arguments to update or create a DgmTypeEffects.
     * @example
     * // Update or create a DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.upsert({
     *   create: {
     *     // ... data to create a DgmTypeEffects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmTypeEffects we want to update
     *   }
     * })
    **/
    upsert<T extends dgmTypeEffectsUpsertArgs>(
      args: SelectSubset<T, dgmTypeEffectsUpsertArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Find one DgmTypeEffects that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {dgmTypeEffectsFindUniqueOrThrowArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmTypeEffectsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, dgmTypeEffectsFindUniqueOrThrowArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Find the first DgmTypeEffects that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindFirstOrThrowArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmTypeEffectsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, dgmTypeEffectsFindFirstOrThrowArgs>
    ): Prisma__dgmTypeEffectsClient<dgmTypeEffectsGetPayload<T>>

    /**
     * Count the number of DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsCountArgs} args - Arguments to filter DgmTypeEffects to count.
     * @example
     * // Count the number of DgmTypeEffects
     * const count = await prisma.dgmTypeEffects.count({
     *   where: {
     *     // ... the filter for the DgmTypeEffects we want to count
     *   }
     * })
    **/
    count<T extends dgmTypeEffectsCountArgs>(
      args?: Subset<T, dgmTypeEffectsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmTypeEffectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeEffectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmTypeEffectsAggregateArgs>(args: Subset<T, DgmTypeEffectsAggregateArgs>): PrismaPromise<GetDgmTypeEffectsAggregateType<T>>

    /**
     * Group by DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeEffectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DgmTypeEffectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DgmTypeEffectsGroupByArgs['orderBy'] }
        : { orderBy?: DgmTypeEffectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DgmTypeEffectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmTypeEffectsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmTypeEffects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dgmTypeEffectsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dgmTypeEffects base type for findUnique actions
   */
  export type dgmTypeEffectsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     * 
    **/
    where: dgmTypeEffectsWhereUniqueInput
  }

  /**
   * dgmTypeEffects: findUnique
   */
  export interface dgmTypeEffectsFindUniqueArgs extends dgmTypeEffectsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmTypeEffects base type for findFirst actions
   */
  export type dgmTypeEffectsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     * 
    **/
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeEffects.
     * 
    **/
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeEffects.
     * 
    **/
    distinct?: Enumerable<DgmTypeEffectsScalarFieldEnum>
  }

  /**
   * dgmTypeEffects: findFirst
   */
  export interface dgmTypeEffectsFindFirstArgs extends dgmTypeEffectsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dgmTypeEffects findMany
   */
  export type dgmTypeEffectsFindManyArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     * 
    **/
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     * 
    **/
    orderBy?: Enumerable<dgmTypeEffectsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmTypeEffects.
     * 
    **/
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DgmTypeEffectsScalarFieldEnum>
  }


  /**
   * dgmTypeEffects create
   */
  export type dgmTypeEffectsCreateArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * The data needed to create a dgmTypeEffects.
     * 
    **/
    data: XOR<dgmTypeEffectsCreateInput, dgmTypeEffectsUncheckedCreateInput>
  }


  /**
   * dgmTypeEffects createMany
   */
  export type dgmTypeEffectsCreateManyArgs = {
    /**
     * The data used to create many dgmTypeEffects.
     * 
    **/
    data: Enumerable<dgmTypeEffectsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dgmTypeEffects update
   */
  export type dgmTypeEffectsUpdateArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * The data needed to update a dgmTypeEffects.
     * 
    **/
    data: XOR<dgmTypeEffectsUpdateInput, dgmTypeEffectsUncheckedUpdateInput>
    /**
     * Choose, which dgmTypeEffects to update.
     * 
    **/
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects updateMany
   */
  export type dgmTypeEffectsUpdateManyArgs = {
    /**
     * The data used to update dgmTypeEffects.
     * 
    **/
    data: XOR<dgmTypeEffectsUpdateManyMutationInput, dgmTypeEffectsUncheckedUpdateManyInput>
    /**
     * Filter which dgmTypeEffects to update
     * 
    **/
    where?: dgmTypeEffectsWhereInput
  }


  /**
   * dgmTypeEffects upsert
   */
  export type dgmTypeEffectsUpsertArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * The filter to search for the dgmTypeEffects to update in case it exists.
     * 
    **/
    where: dgmTypeEffectsWhereUniqueInput
    /**
     * In case the dgmTypeEffects found by the `where` argument doesn't exist, create a new dgmTypeEffects with this data.
     * 
    **/
    create: XOR<dgmTypeEffectsCreateInput, dgmTypeEffectsUncheckedCreateInput>
    /**
     * In case the dgmTypeEffects was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dgmTypeEffectsUpdateInput, dgmTypeEffectsUncheckedUpdateInput>
  }


  /**
   * dgmTypeEffects delete
   */
  export type dgmTypeEffectsDeleteArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
    /**
     * Filter which dgmTypeEffects to delete.
     * 
    **/
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects deleteMany
   */
  export type dgmTypeEffectsDeleteManyArgs = {
    /**
     * Filter which dgmTypeEffects to delete
     * 
    **/
    where?: dgmTypeEffectsWhereInput
  }


  /**
   * dgmTypeEffects: findUniqueOrThrow
   */
  export type dgmTypeEffectsFindUniqueOrThrowArgs = dgmTypeEffectsFindUniqueArgsBase
      

  /**
   * dgmTypeEffects: findFirstOrThrow
   */
  export type dgmTypeEffectsFindFirstOrThrowArgs = dgmTypeEffectsFindFirstArgsBase
      

  /**
   * dgmTypeEffects without action
   */
  export type dgmTypeEffectsArgs = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     * 
    **/
    select?: dgmTypeEffectsSelect | null
  }



  /**
   * Model eveGraphics
   */


  export type AggregateEveGraphics = {
    _count: EveGraphicsCountAggregateOutputType | null
    _avg: EveGraphicsAvgAggregateOutputType | null
    _sum: EveGraphicsSumAggregateOutputType | null
    _min: EveGraphicsMinAggregateOutputType | null
    _max: EveGraphicsMaxAggregateOutputType | null
  }

  export type EveGraphicsAvgAggregateOutputType = {
    graphicID: number | null
  }

  export type EveGraphicsSumAggregateOutputType = {
    graphicID: number | null
  }

  export type EveGraphicsMinAggregateOutputType = {
    graphicID: number | null
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
  }

  export type EveGraphicsMaxAggregateOutputType = {
    graphicID: number | null
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
  }

  export type EveGraphicsCountAggregateOutputType = {
    graphicID: number
    sofFactionName: number
    graphicFile: number
    sofHullName: number
    sofRaceName: number
    description: number
    _all: number
  }


  export type EveGraphicsAvgAggregateInputType = {
    graphicID?: true
  }

  export type EveGraphicsSumAggregateInputType = {
    graphicID?: true
  }

  export type EveGraphicsMinAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
  }

  export type EveGraphicsMaxAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
  }

  export type EveGraphicsCountAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
    _all?: true
  }

  export type EveGraphicsAggregateArgs = {
    /**
     * Filter which eveGraphics to aggregate.
     * 
    **/
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<eveGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveGraphics
    **/
    _count?: true | EveGraphicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveGraphicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveGraphicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveGraphicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveGraphicsMaxAggregateInputType
  }

  export type GetEveGraphicsAggregateType<T extends EveGraphicsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveGraphics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveGraphics[P]>
      : GetScalarType<T[P], AggregateEveGraphics[P]>
  }




  export type EveGraphicsGroupByArgs = {
    where?: eveGraphicsWhereInput
    orderBy?: Enumerable<eveGraphicsOrderByWithAggregationInput>
    by: Array<EveGraphicsScalarFieldEnum>
    having?: eveGraphicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveGraphicsCountAggregateInputType | true
    _avg?: EveGraphicsAvgAggregateInputType
    _sum?: EveGraphicsSumAggregateInputType
    _min?: EveGraphicsMinAggregateInputType
    _max?: EveGraphicsMaxAggregateInputType
  }


  export type EveGraphicsGroupByOutputType = {
    graphicID: number
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
    _count: EveGraphicsCountAggregateOutputType | null
    _avg: EveGraphicsAvgAggregateOutputType | null
    _sum: EveGraphicsSumAggregateOutputType | null
    _min: EveGraphicsMinAggregateOutputType | null
    _max: EveGraphicsMaxAggregateOutputType | null
  }

  type GetEveGraphicsGroupByPayload<T extends EveGraphicsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EveGraphicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveGraphicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveGraphicsGroupByOutputType[P]>
            : GetScalarType<T[P], EveGraphicsGroupByOutputType[P]>
        }
      >
    >


  export type eveGraphicsSelect = {
    graphicID?: boolean
    sofFactionName?: boolean
    graphicFile?: boolean
    sofHullName?: boolean
    sofRaceName?: boolean
    description?: boolean
  }


  export type eveGraphicsGetPayload<S extends boolean | null | undefined | eveGraphicsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? eveGraphics :
    S extends undefined ? never :
    S extends { include: any } & (eveGraphicsArgs | eveGraphicsFindManyArgs)
    ? eveGraphics 
    : S extends { select: any } & (eveGraphicsArgs | eveGraphicsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof eveGraphics ? eveGraphics[P] : never
  } 
      : eveGraphics


  type eveGraphicsCountArgs = Merge<
    Omit<eveGraphicsFindManyArgs, 'select' | 'include'> & {
      select?: EveGraphicsCountAggregateInputType | true
    }
  >

  export interface eveGraphicsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EveGraphics that matches the filter.
     * @param {eveGraphicsFindUniqueArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveGraphicsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eveGraphicsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'eveGraphics'> extends True ? Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>> : Prisma__eveGraphicsClient<eveGraphicsGetPayload<T> | null, null>

    /**
     * Find the first EveGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindFirstArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveGraphicsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eveGraphicsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'eveGraphics'> extends True ? Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>> : Prisma__eveGraphicsClient<eveGraphicsGetPayload<T> | null, null>

    /**
     * Find zero or more EveGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findMany()
     * 
     * // Get first 10 EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findMany({ take: 10 })
     * 
     * // Only select the `graphicID`
     * const eveGraphicsWithGraphicIDOnly = await prisma.eveGraphics.findMany({ select: { graphicID: true } })
     * 
    **/
    findMany<T extends eveGraphicsFindManyArgs>(
      args?: SelectSubset<T, eveGraphicsFindManyArgs>
    ): PrismaPromise<Array<eveGraphicsGetPayload<T>>>

    /**
     * Create a EveGraphics.
     * @param {eveGraphicsCreateArgs} args - Arguments to create a EveGraphics.
     * @example
     * // Create one EveGraphics
     * const EveGraphics = await prisma.eveGraphics.create({
     *   data: {
     *     // ... data to create a EveGraphics
     *   }
     * })
     * 
    **/
    create<T extends eveGraphicsCreateArgs>(
      args: SelectSubset<T, eveGraphicsCreateArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Create many EveGraphics.
     *     @param {eveGraphicsCreateManyArgs} args - Arguments to create many EveGraphics.
     *     @example
     *     // Create many EveGraphics
     *     const eveGraphics = await prisma.eveGraphics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveGraphicsCreateManyArgs>(
      args?: SelectSubset<T, eveGraphicsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EveGraphics.
     * @param {eveGraphicsDeleteArgs} args - Arguments to delete one EveGraphics.
     * @example
     * // Delete one EveGraphics
     * const EveGraphics = await prisma.eveGraphics.delete({
     *   where: {
     *     // ... filter to delete one EveGraphics
     *   }
     * })
     * 
    **/
    delete<T extends eveGraphicsDeleteArgs>(
      args: SelectSubset<T, eveGraphicsDeleteArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Update one EveGraphics.
     * @param {eveGraphicsUpdateArgs} args - Arguments to update one EveGraphics.
     * @example
     * // Update one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveGraphicsUpdateArgs>(
      args: SelectSubset<T, eveGraphicsUpdateArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Delete zero or more EveGraphics.
     * @param {eveGraphicsDeleteManyArgs} args - Arguments to filter EveGraphics to delete.
     * @example
     * // Delete a few EveGraphics
     * const { count } = await prisma.eveGraphics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveGraphicsDeleteManyArgs>(
      args?: SelectSubset<T, eveGraphicsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveGraphics
     * const eveGraphics = await prisma.eveGraphics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveGraphicsUpdateManyArgs>(
      args: SelectSubset<T, eveGraphicsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EveGraphics.
     * @param {eveGraphicsUpsertArgs} args - Arguments to update or create a EveGraphics.
     * @example
     * // Update or create a EveGraphics
     * const eveGraphics = await prisma.eveGraphics.upsert({
     *   create: {
     *     // ... data to create a EveGraphics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveGraphics we want to update
     *   }
     * })
    **/
    upsert<T extends eveGraphicsUpsertArgs>(
      args: SelectSubset<T, eveGraphicsUpsertArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Find one EveGraphics that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {eveGraphicsFindUniqueOrThrowArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveGraphicsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, eveGraphicsFindUniqueOrThrowArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Find the first EveGraphics that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindFirstOrThrowArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveGraphicsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, eveGraphicsFindFirstOrThrowArgs>
    ): Prisma__eveGraphicsClient<eveGraphicsGetPayload<T>>

    /**
     * Count the number of EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsCountArgs} args - Arguments to filter EveGraphics to count.
     * @example
     * // Count the number of EveGraphics
     * const count = await prisma.eveGraphics.count({
     *   where: {
     *     // ... the filter for the EveGraphics we want to count
     *   }
     * })
    **/
    count<T extends eveGraphicsCountArgs>(
      args?: Subset<T, eveGraphicsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveGraphicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveGraphicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveGraphicsAggregateArgs>(args: Subset<T, EveGraphicsAggregateArgs>): PrismaPromise<GetEveGraphicsAggregateType<T>>

    /**
     * Group by EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveGraphicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EveGraphicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EveGraphicsGroupByArgs['orderBy'] }
        : { orderBy?: EveGraphicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EveGraphicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveGraphicsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for eveGraphics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eveGraphicsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * eveGraphics base type for findUnique actions
   */
  export type eveGraphicsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * Filter, which eveGraphics to fetch.
     * 
    **/
    where: eveGraphicsWhereUniqueInput
  }

  /**
   * eveGraphics: findUnique
   */
  export interface eveGraphicsFindUniqueArgs extends eveGraphicsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveGraphics base type for findFirst actions
   */
  export type eveGraphicsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * Filter, which eveGraphics to fetch.
     * 
    **/
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<eveGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveGraphics.
     * 
    **/
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveGraphics.
     * 
    **/
    distinct?: Enumerable<EveGraphicsScalarFieldEnum>
  }

  /**
   * eveGraphics: findFirst
   */
  export interface eveGraphicsFindFirstArgs extends eveGraphicsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveGraphics findMany
   */
  export type eveGraphicsFindManyArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * Filter, which eveGraphics to fetch.
     * 
    **/
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<eveGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveGraphics.
     * 
    **/
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EveGraphicsScalarFieldEnum>
  }


  /**
   * eveGraphics create
   */
  export type eveGraphicsCreateArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * The data needed to create a eveGraphics.
     * 
    **/
    data: XOR<eveGraphicsCreateInput, eveGraphicsUncheckedCreateInput>
  }


  /**
   * eveGraphics createMany
   */
  export type eveGraphicsCreateManyArgs = {
    /**
     * The data used to create many eveGraphics.
     * 
    **/
    data: Enumerable<eveGraphicsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * eveGraphics update
   */
  export type eveGraphicsUpdateArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * The data needed to update a eveGraphics.
     * 
    **/
    data: XOR<eveGraphicsUpdateInput, eveGraphicsUncheckedUpdateInput>
    /**
     * Choose, which eveGraphics to update.
     * 
    **/
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics updateMany
   */
  export type eveGraphicsUpdateManyArgs = {
    /**
     * The data used to update eveGraphics.
     * 
    **/
    data: XOR<eveGraphicsUpdateManyMutationInput, eveGraphicsUncheckedUpdateManyInput>
    /**
     * Filter which eveGraphics to update
     * 
    **/
    where?: eveGraphicsWhereInput
  }


  /**
   * eveGraphics upsert
   */
  export type eveGraphicsUpsertArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * The filter to search for the eveGraphics to update in case it exists.
     * 
    **/
    where: eveGraphicsWhereUniqueInput
    /**
     * In case the eveGraphics found by the `where` argument doesn't exist, create a new eveGraphics with this data.
     * 
    **/
    create: XOR<eveGraphicsCreateInput, eveGraphicsUncheckedCreateInput>
    /**
     * In case the eveGraphics was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<eveGraphicsUpdateInput, eveGraphicsUncheckedUpdateInput>
  }


  /**
   * eveGraphics delete
   */
  export type eveGraphicsDeleteArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
    /**
     * Filter which eveGraphics to delete.
     * 
    **/
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics deleteMany
   */
  export type eveGraphicsDeleteManyArgs = {
    /**
     * Filter which eveGraphics to delete
     * 
    **/
    where?: eveGraphicsWhereInput
  }


  /**
   * eveGraphics: findUniqueOrThrow
   */
  export type eveGraphicsFindUniqueOrThrowArgs = eveGraphicsFindUniqueArgsBase
      

  /**
   * eveGraphics: findFirstOrThrow
   */
  export type eveGraphicsFindFirstOrThrowArgs = eveGraphicsFindFirstArgsBase
      

  /**
   * eveGraphics without action
   */
  export type eveGraphicsArgs = {
    /**
     * Select specific fields to fetch from the eveGraphics
     * 
    **/
    select?: eveGraphicsSelect | null
  }



  /**
   * Model eveIcons
   */


  export type AggregateEveIcons = {
    _count: EveIconsCountAggregateOutputType | null
    _avg: EveIconsAvgAggregateOutputType | null
    _sum: EveIconsSumAggregateOutputType | null
    _min: EveIconsMinAggregateOutputType | null
    _max: EveIconsMaxAggregateOutputType | null
  }

  export type EveIconsAvgAggregateOutputType = {
    iconID: number | null
  }

  export type EveIconsSumAggregateOutputType = {
    iconID: number | null
  }

  export type EveIconsMinAggregateOutputType = {
    iconID: number | null
    iconFile: string | null
    description: string | null
  }

  export type EveIconsMaxAggregateOutputType = {
    iconID: number | null
    iconFile: string | null
    description: string | null
  }

  export type EveIconsCountAggregateOutputType = {
    iconID: number
    iconFile: number
    description: number
    _all: number
  }


  export type EveIconsAvgAggregateInputType = {
    iconID?: true
  }

  export type EveIconsSumAggregateInputType = {
    iconID?: true
  }

  export type EveIconsMinAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
  }

  export type EveIconsMaxAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
  }

  export type EveIconsCountAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
    _all?: true
  }

  export type EveIconsAggregateArgs = {
    /**
     * Filter which eveIcons to aggregate.
     * 
    **/
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     * 
    **/
    orderBy?: Enumerable<eveIconsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveIcons
    **/
    _count?: true | EveIconsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveIconsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveIconsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveIconsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveIconsMaxAggregateInputType
  }

  export type GetEveIconsAggregateType<T extends EveIconsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveIcons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveIcons[P]>
      : GetScalarType<T[P], AggregateEveIcons[P]>
  }




  export type EveIconsGroupByArgs = {
    where?: eveIconsWhereInput
    orderBy?: Enumerable<eveIconsOrderByWithAggregationInput>
    by: Array<EveIconsScalarFieldEnum>
    having?: eveIconsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveIconsCountAggregateInputType | true
    _avg?: EveIconsAvgAggregateInputType
    _sum?: EveIconsSumAggregateInputType
    _min?: EveIconsMinAggregateInputType
    _max?: EveIconsMaxAggregateInputType
  }


  export type EveIconsGroupByOutputType = {
    iconID: number
    iconFile: string | null
    description: string | null
    _count: EveIconsCountAggregateOutputType | null
    _avg: EveIconsAvgAggregateOutputType | null
    _sum: EveIconsSumAggregateOutputType | null
    _min: EveIconsMinAggregateOutputType | null
    _max: EveIconsMaxAggregateOutputType | null
  }

  type GetEveIconsGroupByPayload<T extends EveIconsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EveIconsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveIconsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveIconsGroupByOutputType[P]>
            : GetScalarType<T[P], EveIconsGroupByOutputType[P]>
        }
      >
    >


  export type eveIconsSelect = {
    iconID?: boolean
    iconFile?: boolean
    description?: boolean
  }


  export type eveIconsGetPayload<S extends boolean | null | undefined | eveIconsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? eveIcons :
    S extends undefined ? never :
    S extends { include: any } & (eveIconsArgs | eveIconsFindManyArgs)
    ? eveIcons 
    : S extends { select: any } & (eveIconsArgs | eveIconsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof eveIcons ? eveIcons[P] : never
  } 
      : eveIcons


  type eveIconsCountArgs = Merge<
    Omit<eveIconsFindManyArgs, 'select' | 'include'> & {
      select?: EveIconsCountAggregateInputType | true
    }
  >

  export interface eveIconsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EveIcons that matches the filter.
     * @param {eveIconsFindUniqueArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveIconsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eveIconsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'eveIcons'> extends True ? Prisma__eveIconsClient<eveIconsGetPayload<T>> : Prisma__eveIconsClient<eveIconsGetPayload<T> | null, null>

    /**
     * Find the first EveIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindFirstArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveIconsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eveIconsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'eveIcons'> extends True ? Prisma__eveIconsClient<eveIconsGetPayload<T>> : Prisma__eveIconsClient<eveIconsGetPayload<T> | null, null>

    /**
     * Find zero or more EveIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveIcons
     * const eveIcons = await prisma.eveIcons.findMany()
     * 
     * // Get first 10 EveIcons
     * const eveIcons = await prisma.eveIcons.findMany({ take: 10 })
     * 
     * // Only select the `iconID`
     * const eveIconsWithIconIDOnly = await prisma.eveIcons.findMany({ select: { iconID: true } })
     * 
    **/
    findMany<T extends eveIconsFindManyArgs>(
      args?: SelectSubset<T, eveIconsFindManyArgs>
    ): PrismaPromise<Array<eveIconsGetPayload<T>>>

    /**
     * Create a EveIcons.
     * @param {eveIconsCreateArgs} args - Arguments to create a EveIcons.
     * @example
     * // Create one EveIcons
     * const EveIcons = await prisma.eveIcons.create({
     *   data: {
     *     // ... data to create a EveIcons
     *   }
     * })
     * 
    **/
    create<T extends eveIconsCreateArgs>(
      args: SelectSubset<T, eveIconsCreateArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Create many EveIcons.
     *     @param {eveIconsCreateManyArgs} args - Arguments to create many EveIcons.
     *     @example
     *     // Create many EveIcons
     *     const eveIcons = await prisma.eveIcons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveIconsCreateManyArgs>(
      args?: SelectSubset<T, eveIconsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EveIcons.
     * @param {eveIconsDeleteArgs} args - Arguments to delete one EveIcons.
     * @example
     * // Delete one EveIcons
     * const EveIcons = await prisma.eveIcons.delete({
     *   where: {
     *     // ... filter to delete one EveIcons
     *   }
     * })
     * 
    **/
    delete<T extends eveIconsDeleteArgs>(
      args: SelectSubset<T, eveIconsDeleteArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Update one EveIcons.
     * @param {eveIconsUpdateArgs} args - Arguments to update one EveIcons.
     * @example
     * // Update one EveIcons
     * const eveIcons = await prisma.eveIcons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveIconsUpdateArgs>(
      args: SelectSubset<T, eveIconsUpdateArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Delete zero or more EveIcons.
     * @param {eveIconsDeleteManyArgs} args - Arguments to filter EveIcons to delete.
     * @example
     * // Delete a few EveIcons
     * const { count } = await prisma.eveIcons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveIconsDeleteManyArgs>(
      args?: SelectSubset<T, eveIconsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveIcons
     * const eveIcons = await prisma.eveIcons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveIconsUpdateManyArgs>(
      args: SelectSubset<T, eveIconsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EveIcons.
     * @param {eveIconsUpsertArgs} args - Arguments to update or create a EveIcons.
     * @example
     * // Update or create a EveIcons
     * const eveIcons = await prisma.eveIcons.upsert({
     *   create: {
     *     // ... data to create a EveIcons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveIcons we want to update
     *   }
     * })
    **/
    upsert<T extends eveIconsUpsertArgs>(
      args: SelectSubset<T, eveIconsUpsertArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Find one EveIcons that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {eveIconsFindUniqueOrThrowArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveIconsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, eveIconsFindUniqueOrThrowArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Find the first EveIcons that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindFirstOrThrowArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveIconsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, eveIconsFindFirstOrThrowArgs>
    ): Prisma__eveIconsClient<eveIconsGetPayload<T>>

    /**
     * Count the number of EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsCountArgs} args - Arguments to filter EveIcons to count.
     * @example
     * // Count the number of EveIcons
     * const count = await prisma.eveIcons.count({
     *   where: {
     *     // ... the filter for the EveIcons we want to count
     *   }
     * })
    **/
    count<T extends eveIconsCountArgs>(
      args?: Subset<T, eveIconsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveIconsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveIconsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveIconsAggregateArgs>(args: Subset<T, EveIconsAggregateArgs>): PrismaPromise<GetEveIconsAggregateType<T>>

    /**
     * Group by EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveIconsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EveIconsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EveIconsGroupByArgs['orderBy'] }
        : { orderBy?: EveIconsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EveIconsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveIconsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for eveIcons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eveIconsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * eveIcons base type for findUnique actions
   */
  export type eveIconsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * Filter, which eveIcons to fetch.
     * 
    **/
    where: eveIconsWhereUniqueInput
  }

  /**
   * eveIcons: findUnique
   */
  export interface eveIconsFindUniqueArgs extends eveIconsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveIcons base type for findFirst actions
   */
  export type eveIconsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * Filter, which eveIcons to fetch.
     * 
    **/
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     * 
    **/
    orderBy?: Enumerable<eveIconsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveIcons.
     * 
    **/
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveIcons.
     * 
    **/
    distinct?: Enumerable<EveIconsScalarFieldEnum>
  }

  /**
   * eveIcons: findFirst
   */
  export interface eveIconsFindFirstArgs extends eveIconsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveIcons findMany
   */
  export type eveIconsFindManyArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * Filter, which eveIcons to fetch.
     * 
    **/
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     * 
    **/
    orderBy?: Enumerable<eveIconsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveIcons.
     * 
    **/
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EveIconsScalarFieldEnum>
  }


  /**
   * eveIcons create
   */
  export type eveIconsCreateArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * The data needed to create a eveIcons.
     * 
    **/
    data: XOR<eveIconsCreateInput, eveIconsUncheckedCreateInput>
  }


  /**
   * eveIcons createMany
   */
  export type eveIconsCreateManyArgs = {
    /**
     * The data used to create many eveIcons.
     * 
    **/
    data: Enumerable<eveIconsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * eveIcons update
   */
  export type eveIconsUpdateArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * The data needed to update a eveIcons.
     * 
    **/
    data: XOR<eveIconsUpdateInput, eveIconsUncheckedUpdateInput>
    /**
     * Choose, which eveIcons to update.
     * 
    **/
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons updateMany
   */
  export type eveIconsUpdateManyArgs = {
    /**
     * The data used to update eveIcons.
     * 
    **/
    data: XOR<eveIconsUpdateManyMutationInput, eveIconsUncheckedUpdateManyInput>
    /**
     * Filter which eveIcons to update
     * 
    **/
    where?: eveIconsWhereInput
  }


  /**
   * eveIcons upsert
   */
  export type eveIconsUpsertArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * The filter to search for the eveIcons to update in case it exists.
     * 
    **/
    where: eveIconsWhereUniqueInput
    /**
     * In case the eveIcons found by the `where` argument doesn't exist, create a new eveIcons with this data.
     * 
    **/
    create: XOR<eveIconsCreateInput, eveIconsUncheckedCreateInput>
    /**
     * In case the eveIcons was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<eveIconsUpdateInput, eveIconsUncheckedUpdateInput>
  }


  /**
   * eveIcons delete
   */
  export type eveIconsDeleteArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
    /**
     * Filter which eveIcons to delete.
     * 
    **/
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons deleteMany
   */
  export type eveIconsDeleteManyArgs = {
    /**
     * Filter which eveIcons to delete
     * 
    **/
    where?: eveIconsWhereInput
  }


  /**
   * eveIcons: findUniqueOrThrow
   */
  export type eveIconsFindUniqueOrThrowArgs = eveIconsFindUniqueArgsBase
      

  /**
   * eveIcons: findFirstOrThrow
   */
  export type eveIconsFindFirstOrThrowArgs = eveIconsFindFirstArgsBase
      

  /**
   * eveIcons without action
   */
  export type eveIconsArgs = {
    /**
     * Select specific fields to fetch from the eveIcons
     * 
    **/
    select?: eveIconsSelect | null
  }



  /**
   * Model eveUnits
   */


  export type AggregateEveUnits = {
    _count: EveUnitsCountAggregateOutputType | null
    _avg: EveUnitsAvgAggregateOutputType | null
    _sum: EveUnitsSumAggregateOutputType | null
    _min: EveUnitsMinAggregateOutputType | null
    _max: EveUnitsMaxAggregateOutputType | null
  }

  export type EveUnitsAvgAggregateOutputType = {
    unitID: number | null
  }

  export type EveUnitsSumAggregateOutputType = {
    unitID: number | null
  }

  export type EveUnitsMinAggregateOutputType = {
    unitID: number | null
    unitName: string | null
    displayName: string | null
    description: string | null
  }

  export type EveUnitsMaxAggregateOutputType = {
    unitID: number | null
    unitName: string | null
    displayName: string | null
    description: string | null
  }

  export type EveUnitsCountAggregateOutputType = {
    unitID: number
    unitName: number
    displayName: number
    description: number
    _all: number
  }


  export type EveUnitsAvgAggregateInputType = {
    unitID?: true
  }

  export type EveUnitsSumAggregateInputType = {
    unitID?: true
  }

  export type EveUnitsMinAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
  }

  export type EveUnitsMaxAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
  }

  export type EveUnitsCountAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
    _all?: true
  }

  export type EveUnitsAggregateArgs = {
    /**
     * Filter which eveUnits to aggregate.
     * 
    **/
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<eveUnitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveUnits
    **/
    _count?: true | EveUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveUnitsMaxAggregateInputType
  }

  export type GetEveUnitsAggregateType<T extends EveUnitsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveUnits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveUnits[P]>
      : GetScalarType<T[P], AggregateEveUnits[P]>
  }




  export type EveUnitsGroupByArgs = {
    where?: eveUnitsWhereInput
    orderBy?: Enumerable<eveUnitsOrderByWithAggregationInput>
    by: Array<EveUnitsScalarFieldEnum>
    having?: eveUnitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveUnitsCountAggregateInputType | true
    _avg?: EveUnitsAvgAggregateInputType
    _sum?: EveUnitsSumAggregateInputType
    _min?: EveUnitsMinAggregateInputType
    _max?: EveUnitsMaxAggregateInputType
  }


  export type EveUnitsGroupByOutputType = {
    unitID: number
    unitName: string | null
    displayName: string | null
    description: string | null
    _count: EveUnitsCountAggregateOutputType | null
    _avg: EveUnitsAvgAggregateOutputType | null
    _sum: EveUnitsSumAggregateOutputType | null
    _min: EveUnitsMinAggregateOutputType | null
    _max: EveUnitsMaxAggregateOutputType | null
  }

  type GetEveUnitsGroupByPayload<T extends EveUnitsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EveUnitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveUnitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveUnitsGroupByOutputType[P]>
            : GetScalarType<T[P], EveUnitsGroupByOutputType[P]>
        }
      >
    >


  export type eveUnitsSelect = {
    unitID?: boolean
    unitName?: boolean
    displayName?: boolean
    description?: boolean
  }


  export type eveUnitsGetPayload<S extends boolean | null | undefined | eveUnitsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? eveUnits :
    S extends undefined ? never :
    S extends { include: any } & (eveUnitsArgs | eveUnitsFindManyArgs)
    ? eveUnits 
    : S extends { select: any } & (eveUnitsArgs | eveUnitsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof eveUnits ? eveUnits[P] : never
  } 
      : eveUnits


  type eveUnitsCountArgs = Merge<
    Omit<eveUnitsFindManyArgs, 'select' | 'include'> & {
      select?: EveUnitsCountAggregateInputType | true
    }
  >

  export interface eveUnitsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EveUnits that matches the filter.
     * @param {eveUnitsFindUniqueArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eveUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'eveUnits'> extends True ? Prisma__eveUnitsClient<eveUnitsGetPayload<T>> : Prisma__eveUnitsClient<eveUnitsGetPayload<T> | null, null>

    /**
     * Find the first EveUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindFirstArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eveUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'eveUnits'> extends True ? Prisma__eveUnitsClient<eveUnitsGetPayload<T>> : Prisma__eveUnitsClient<eveUnitsGetPayload<T> | null, null>

    /**
     * Find zero or more EveUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveUnits
     * const eveUnits = await prisma.eveUnits.findMany()
     * 
     * // Get first 10 EveUnits
     * const eveUnits = await prisma.eveUnits.findMany({ take: 10 })
     * 
     * // Only select the `unitID`
     * const eveUnitsWithUnitIDOnly = await prisma.eveUnits.findMany({ select: { unitID: true } })
     * 
    **/
    findMany<T extends eveUnitsFindManyArgs>(
      args?: SelectSubset<T, eveUnitsFindManyArgs>
    ): PrismaPromise<Array<eveUnitsGetPayload<T>>>

    /**
     * Create a EveUnits.
     * @param {eveUnitsCreateArgs} args - Arguments to create a EveUnits.
     * @example
     * // Create one EveUnits
     * const EveUnits = await prisma.eveUnits.create({
     *   data: {
     *     // ... data to create a EveUnits
     *   }
     * })
     * 
    **/
    create<T extends eveUnitsCreateArgs>(
      args: SelectSubset<T, eveUnitsCreateArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Create many EveUnits.
     *     @param {eveUnitsCreateManyArgs} args - Arguments to create many EveUnits.
     *     @example
     *     // Create many EveUnits
     *     const eveUnits = await prisma.eveUnits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveUnitsCreateManyArgs>(
      args?: SelectSubset<T, eveUnitsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EveUnits.
     * @param {eveUnitsDeleteArgs} args - Arguments to delete one EveUnits.
     * @example
     * // Delete one EveUnits
     * const EveUnits = await prisma.eveUnits.delete({
     *   where: {
     *     // ... filter to delete one EveUnits
     *   }
     * })
     * 
    **/
    delete<T extends eveUnitsDeleteArgs>(
      args: SelectSubset<T, eveUnitsDeleteArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Update one EveUnits.
     * @param {eveUnitsUpdateArgs} args - Arguments to update one EveUnits.
     * @example
     * // Update one EveUnits
     * const eveUnits = await prisma.eveUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveUnitsUpdateArgs>(
      args: SelectSubset<T, eveUnitsUpdateArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Delete zero or more EveUnits.
     * @param {eveUnitsDeleteManyArgs} args - Arguments to filter EveUnits to delete.
     * @example
     * // Delete a few EveUnits
     * const { count } = await prisma.eveUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveUnitsDeleteManyArgs>(
      args?: SelectSubset<T, eveUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveUnits
     * const eveUnits = await prisma.eveUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveUnitsUpdateManyArgs>(
      args: SelectSubset<T, eveUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EveUnits.
     * @param {eveUnitsUpsertArgs} args - Arguments to update or create a EveUnits.
     * @example
     * // Update or create a EveUnits
     * const eveUnits = await prisma.eveUnits.upsert({
     *   create: {
     *     // ... data to create a EveUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveUnits we want to update
     *   }
     * })
    **/
    upsert<T extends eveUnitsUpsertArgs>(
      args: SelectSubset<T, eveUnitsUpsertArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Find one EveUnits that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {eveUnitsFindUniqueOrThrowArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveUnitsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, eveUnitsFindUniqueOrThrowArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Find the first EveUnits that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindFirstOrThrowArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveUnitsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, eveUnitsFindFirstOrThrowArgs>
    ): Prisma__eveUnitsClient<eveUnitsGetPayload<T>>

    /**
     * Count the number of EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsCountArgs} args - Arguments to filter EveUnits to count.
     * @example
     * // Count the number of EveUnits
     * const count = await prisma.eveUnits.count({
     *   where: {
     *     // ... the filter for the EveUnits we want to count
     *   }
     * })
    **/
    count<T extends eveUnitsCountArgs>(
      args?: Subset<T, eveUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveUnitsAggregateArgs>(args: Subset<T, EveUnitsAggregateArgs>): PrismaPromise<GetEveUnitsAggregateType<T>>

    /**
     * Group by EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveUnitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EveUnitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EveUnitsGroupByArgs['orderBy'] }
        : { orderBy?: EveUnitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EveUnitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveUnitsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for eveUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eveUnitsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * eveUnits base type for findUnique actions
   */
  export type eveUnitsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * Filter, which eveUnits to fetch.
     * 
    **/
    where: eveUnitsWhereUniqueInput
  }

  /**
   * eveUnits: findUnique
   */
  export interface eveUnitsFindUniqueArgs extends eveUnitsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveUnits base type for findFirst actions
   */
  export type eveUnitsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * Filter, which eveUnits to fetch.
     * 
    **/
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<eveUnitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveUnits.
     * 
    **/
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveUnits.
     * 
    **/
    distinct?: Enumerable<EveUnitsScalarFieldEnum>
  }

  /**
   * eveUnits: findFirst
   */
  export interface eveUnitsFindFirstArgs extends eveUnitsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eveUnits findMany
   */
  export type eveUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * Filter, which eveUnits to fetch.
     * 
    **/
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<eveUnitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveUnits.
     * 
    **/
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EveUnitsScalarFieldEnum>
  }


  /**
   * eveUnits create
   */
  export type eveUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * The data needed to create a eveUnits.
     * 
    **/
    data: XOR<eveUnitsCreateInput, eveUnitsUncheckedCreateInput>
  }


  /**
   * eveUnits createMany
   */
  export type eveUnitsCreateManyArgs = {
    /**
     * The data used to create many eveUnits.
     * 
    **/
    data: Enumerable<eveUnitsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * eveUnits update
   */
  export type eveUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * The data needed to update a eveUnits.
     * 
    **/
    data: XOR<eveUnitsUpdateInput, eveUnitsUncheckedUpdateInput>
    /**
     * Choose, which eveUnits to update.
     * 
    **/
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits updateMany
   */
  export type eveUnitsUpdateManyArgs = {
    /**
     * The data used to update eveUnits.
     * 
    **/
    data: XOR<eveUnitsUpdateManyMutationInput, eveUnitsUncheckedUpdateManyInput>
    /**
     * Filter which eveUnits to update
     * 
    **/
    where?: eveUnitsWhereInput
  }


  /**
   * eveUnits upsert
   */
  export type eveUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * The filter to search for the eveUnits to update in case it exists.
     * 
    **/
    where: eveUnitsWhereUniqueInput
    /**
     * In case the eveUnits found by the `where` argument doesn't exist, create a new eveUnits with this data.
     * 
    **/
    create: XOR<eveUnitsCreateInput, eveUnitsUncheckedCreateInput>
    /**
     * In case the eveUnits was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<eveUnitsUpdateInput, eveUnitsUncheckedUpdateInput>
  }


  /**
   * eveUnits delete
   */
  export type eveUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
    /**
     * Filter which eveUnits to delete.
     * 
    **/
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits deleteMany
   */
  export type eveUnitsDeleteManyArgs = {
    /**
     * Filter which eveUnits to delete
     * 
    **/
    where?: eveUnitsWhereInput
  }


  /**
   * eveUnits: findUniqueOrThrow
   */
  export type eveUnitsFindUniqueOrThrowArgs = eveUnitsFindUniqueArgsBase
      

  /**
   * eveUnits: findFirstOrThrow
   */
  export type eveUnitsFindFirstOrThrowArgs = eveUnitsFindFirstArgsBase
      

  /**
   * eveUnits without action
   */
  export type eveUnitsArgs = {
    /**
     * Select specific fields to fetch from the eveUnits
     * 
    **/
    select?: eveUnitsSelect | null
  }



  /**
   * Model industryActivity
   */


  export type AggregateIndustryActivity = {
    _count: IndustryActivityCountAggregateOutputType | null
    _avg: IndustryActivityAvgAggregateOutputType | null
    _sum: IndustryActivitySumAggregateOutputType | null
    _min: IndustryActivityMinAggregateOutputType | null
    _max: IndustryActivityMaxAggregateOutputType | null
  }

  export type IndustryActivityAvgAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivitySumAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityMinAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityMaxAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityCountAggregateOutputType = {
    typeID: number
    activityID: number
    time: number
    _all: number
  }


  export type IndustryActivityAvgAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivitySumAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityMinAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityMaxAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityCountAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
    _all?: true
  }

  export type IndustryActivityAggregateArgs = {
    /**
     * Filter which industryActivity to aggregate.
     * 
    **/
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<industryActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned industryActivities
    **/
    _count?: true | IndustryActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndustryActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndustryActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryActivityMaxAggregateInputType
  }

  export type GetIndustryActivityAggregateType<T extends IndustryActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustryActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryActivity[P]>
      : GetScalarType<T[P], AggregateIndustryActivity[P]>
  }




  export type IndustryActivityGroupByArgs = {
    where?: industryActivityWhereInput
    orderBy?: Enumerable<industryActivityOrderByWithAggregationInput>
    by: Array<IndustryActivityScalarFieldEnum>
    having?: industryActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryActivityCountAggregateInputType | true
    _avg?: IndustryActivityAvgAggregateInputType
    _sum?: IndustryActivitySumAggregateInputType
    _min?: IndustryActivityMinAggregateInputType
    _max?: IndustryActivityMaxAggregateInputType
  }


  export type IndustryActivityGroupByOutputType = {
    typeID: number
    activityID: number
    time: number | null
    _count: IndustryActivityCountAggregateOutputType | null
    _avg: IndustryActivityAvgAggregateOutputType | null
    _sum: IndustryActivitySumAggregateOutputType | null
    _min: IndustryActivityMinAggregateOutputType | null
    _max: IndustryActivityMaxAggregateOutputType | null
  }

  type GetIndustryActivityGroupByPayload<T extends IndustryActivityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IndustryActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryActivityGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryActivityGroupByOutputType[P]>
        }
      >
    >


  export type industryActivitySelect = {
    typeID?: boolean
    activityID?: boolean
    time?: boolean
  }


  export type industryActivityGetPayload<S extends boolean | null | undefined | industryActivityArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? industryActivity :
    S extends undefined ? never :
    S extends { include: any } & (industryActivityArgs | industryActivityFindManyArgs)
    ? industryActivity 
    : S extends { select: any } & (industryActivityArgs | industryActivityFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof industryActivity ? industryActivity[P] : never
  } 
      : industryActivity


  type industryActivityCountArgs = Merge<
    Omit<industryActivityFindManyArgs, 'select' | 'include'> & {
      select?: IndustryActivityCountAggregateInputType | true
    }
  >

  export interface industryActivityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one IndustryActivity that matches the filter.
     * @param {industryActivityFindUniqueArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends industryActivityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, industryActivityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'industryActivity'> extends True ? Prisma__industryActivityClient<industryActivityGetPayload<T>> : Prisma__industryActivityClient<industryActivityGetPayload<T> | null, null>

    /**
     * Find the first IndustryActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindFirstArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends industryActivityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, industryActivityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'industryActivity'> extends True ? Prisma__industryActivityClient<industryActivityGetPayload<T>> : Prisma__industryActivityClient<industryActivityGetPayload<T> | null, null>

    /**
     * Find zero or more IndustryActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryActivities
     * const industryActivities = await prisma.industryActivity.findMany()
     * 
     * // Get first 10 IndustryActivities
     * const industryActivities = await prisma.industryActivity.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const industryActivityWithTypeIDOnly = await prisma.industryActivity.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends industryActivityFindManyArgs>(
      args?: SelectSubset<T, industryActivityFindManyArgs>
    ): PrismaPromise<Array<industryActivityGetPayload<T>>>

    /**
     * Create a IndustryActivity.
     * @param {industryActivityCreateArgs} args - Arguments to create a IndustryActivity.
     * @example
     * // Create one IndustryActivity
     * const IndustryActivity = await prisma.industryActivity.create({
     *   data: {
     *     // ... data to create a IndustryActivity
     *   }
     * })
     * 
    **/
    create<T extends industryActivityCreateArgs>(
      args: SelectSubset<T, industryActivityCreateArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Create many IndustryActivities.
     *     @param {industryActivityCreateManyArgs} args - Arguments to create many IndustryActivities.
     *     @example
     *     // Create many IndustryActivities
     *     const industryActivity = await prisma.industryActivity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends industryActivityCreateManyArgs>(
      args?: SelectSubset<T, industryActivityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IndustryActivity.
     * @param {industryActivityDeleteArgs} args - Arguments to delete one IndustryActivity.
     * @example
     * // Delete one IndustryActivity
     * const IndustryActivity = await prisma.industryActivity.delete({
     *   where: {
     *     // ... filter to delete one IndustryActivity
     *   }
     * })
     * 
    **/
    delete<T extends industryActivityDeleteArgs>(
      args: SelectSubset<T, industryActivityDeleteArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Update one IndustryActivity.
     * @param {industryActivityUpdateArgs} args - Arguments to update one IndustryActivity.
     * @example
     * // Update one IndustryActivity
     * const industryActivity = await prisma.industryActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends industryActivityUpdateArgs>(
      args: SelectSubset<T, industryActivityUpdateArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Delete zero or more IndustryActivities.
     * @param {industryActivityDeleteManyArgs} args - Arguments to filter IndustryActivities to delete.
     * @example
     * // Delete a few IndustryActivities
     * const { count } = await prisma.industryActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends industryActivityDeleteManyArgs>(
      args?: SelectSubset<T, industryActivityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndustryActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryActivities
     * const industryActivity = await prisma.industryActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends industryActivityUpdateManyArgs>(
      args: SelectSubset<T, industryActivityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IndustryActivity.
     * @param {industryActivityUpsertArgs} args - Arguments to update or create a IndustryActivity.
     * @example
     * // Update or create a IndustryActivity
     * const industryActivity = await prisma.industryActivity.upsert({
     *   create: {
     *     // ... data to create a IndustryActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryActivity we want to update
     *   }
     * })
    **/
    upsert<T extends industryActivityUpsertArgs>(
      args: SelectSubset<T, industryActivityUpsertArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Find one IndustryActivity that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {industryActivityFindUniqueOrThrowArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends industryActivityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, industryActivityFindUniqueOrThrowArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Find the first IndustryActivity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindFirstOrThrowArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends industryActivityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, industryActivityFindFirstOrThrowArgs>
    ): Prisma__industryActivityClient<industryActivityGetPayload<T>>

    /**
     * Count the number of IndustryActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityCountArgs} args - Arguments to filter IndustryActivities to count.
     * @example
     * // Count the number of IndustryActivities
     * const count = await prisma.industryActivity.count({
     *   where: {
     *     // ... the filter for the IndustryActivities we want to count
     *   }
     * })
    **/
    count<T extends industryActivityCountArgs>(
      args?: Subset<T, industryActivityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndustryActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryActivityAggregateArgs>(args: Subset<T, IndustryActivityAggregateArgs>): PrismaPromise<GetIndustryActivityAggregateType<T>>

    /**
     * Group by IndustryActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryActivityGroupByArgs['orderBy'] }
        : { orderBy?: IndustryActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryActivityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for industryActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__industryActivityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * industryActivity base type for findUnique actions
   */
  export type industryActivityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * Filter, which industryActivity to fetch.
     * 
    **/
    where: industryActivityWhereUniqueInput
  }

  /**
   * industryActivity: findUnique
   */
  export interface industryActivityFindUniqueArgs extends industryActivityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * industryActivity base type for findFirst actions
   */
  export type industryActivityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * Filter, which industryActivity to fetch.
     * 
    **/
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<industryActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryActivities.
     * 
    **/
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryActivities.
     * 
    **/
    distinct?: Enumerable<IndustryActivityScalarFieldEnum>
  }

  /**
   * industryActivity: findFirst
   */
  export interface industryActivityFindFirstArgs extends industryActivityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * industryActivity findMany
   */
  export type industryActivityFindManyArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * Filter, which industryActivities to fetch.
     * 
    **/
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<industryActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing industryActivities.
     * 
    **/
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IndustryActivityScalarFieldEnum>
  }


  /**
   * industryActivity create
   */
  export type industryActivityCreateArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * The data needed to create a industryActivity.
     * 
    **/
    data: XOR<industryActivityCreateInput, industryActivityUncheckedCreateInput>
  }


  /**
   * industryActivity createMany
   */
  export type industryActivityCreateManyArgs = {
    /**
     * The data used to create many industryActivities.
     * 
    **/
    data: Enumerable<industryActivityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * industryActivity update
   */
  export type industryActivityUpdateArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * The data needed to update a industryActivity.
     * 
    **/
    data: XOR<industryActivityUpdateInput, industryActivityUncheckedUpdateInput>
    /**
     * Choose, which industryActivity to update.
     * 
    **/
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity updateMany
   */
  export type industryActivityUpdateManyArgs = {
    /**
     * The data used to update industryActivities.
     * 
    **/
    data: XOR<industryActivityUpdateManyMutationInput, industryActivityUncheckedUpdateManyInput>
    /**
     * Filter which industryActivities to update
     * 
    **/
    where?: industryActivityWhereInput
  }


  /**
   * industryActivity upsert
   */
  export type industryActivityUpsertArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * The filter to search for the industryActivity to update in case it exists.
     * 
    **/
    where: industryActivityWhereUniqueInput
    /**
     * In case the industryActivity found by the `where` argument doesn't exist, create a new industryActivity with this data.
     * 
    **/
    create: XOR<industryActivityCreateInput, industryActivityUncheckedCreateInput>
    /**
     * In case the industryActivity was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<industryActivityUpdateInput, industryActivityUncheckedUpdateInput>
  }


  /**
   * industryActivity delete
   */
  export type industryActivityDeleteArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
    /**
     * Filter which industryActivity to delete.
     * 
    **/
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity deleteMany
   */
  export type industryActivityDeleteManyArgs = {
    /**
     * Filter which industryActivities to delete
     * 
    **/
    where?: industryActivityWhereInput
  }


  /**
   * industryActivity: findUniqueOrThrow
   */
  export type industryActivityFindUniqueOrThrowArgs = industryActivityFindUniqueArgsBase
      

  /**
   * industryActivity: findFirstOrThrow
   */
  export type industryActivityFindFirstOrThrowArgs = industryActivityFindFirstArgsBase
      

  /**
   * industryActivity without action
   */
  export type industryActivityArgs = {
    /**
     * Select specific fields to fetch from the industryActivity
     * 
    **/
    select?: industryActivitySelect | null
  }



  /**
   * Model industryBlueprints
   */


  export type AggregateIndustryBlueprints = {
    _count: IndustryBlueprintsCountAggregateOutputType | null
    _avg: IndustryBlueprintsAvgAggregateOutputType | null
    _sum: IndustryBlueprintsSumAggregateOutputType | null
    _min: IndustryBlueprintsMinAggregateOutputType | null
    _max: IndustryBlueprintsMaxAggregateOutputType | null
  }

  export type IndustryBlueprintsAvgAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsSumAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsMinAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsMaxAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsCountAggregateOutputType = {
    typeID: number
    maxProductionLimit: number
    _all: number
  }


  export type IndustryBlueprintsAvgAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsSumAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsMinAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsMaxAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsCountAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
    _all?: true
  }

  export type IndustryBlueprintsAggregateArgs = {
    /**
     * Filter which industryBlueprints to aggregate.
     * 
    **/
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     * 
    **/
    orderBy?: Enumerable<industryBlueprintsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned industryBlueprints
    **/
    _count?: true | IndustryBlueprintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndustryBlueprintsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndustryBlueprintsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryBlueprintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryBlueprintsMaxAggregateInputType
  }

  export type GetIndustryBlueprintsAggregateType<T extends IndustryBlueprintsAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustryBlueprints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryBlueprints[P]>
      : GetScalarType<T[P], AggregateIndustryBlueprints[P]>
  }




  export type IndustryBlueprintsGroupByArgs = {
    where?: industryBlueprintsWhereInput
    orderBy?: Enumerable<industryBlueprintsOrderByWithAggregationInput>
    by: Array<IndustryBlueprintsScalarFieldEnum>
    having?: industryBlueprintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryBlueprintsCountAggregateInputType | true
    _avg?: IndustryBlueprintsAvgAggregateInputType
    _sum?: IndustryBlueprintsSumAggregateInputType
    _min?: IndustryBlueprintsMinAggregateInputType
    _max?: IndustryBlueprintsMaxAggregateInputType
  }


  export type IndustryBlueprintsGroupByOutputType = {
    typeID: number
    maxProductionLimit: number | null
    _count: IndustryBlueprintsCountAggregateOutputType | null
    _avg: IndustryBlueprintsAvgAggregateOutputType | null
    _sum: IndustryBlueprintsSumAggregateOutputType | null
    _min: IndustryBlueprintsMinAggregateOutputType | null
    _max: IndustryBlueprintsMaxAggregateOutputType | null
  }

  type GetIndustryBlueprintsGroupByPayload<T extends IndustryBlueprintsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IndustryBlueprintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryBlueprintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryBlueprintsGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryBlueprintsGroupByOutputType[P]>
        }
      >
    >


  export type industryBlueprintsSelect = {
    typeID?: boolean
    maxProductionLimit?: boolean
  }


  export type industryBlueprintsGetPayload<S extends boolean | null | undefined | industryBlueprintsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? industryBlueprints :
    S extends undefined ? never :
    S extends { include: any } & (industryBlueprintsArgs | industryBlueprintsFindManyArgs)
    ? industryBlueprints 
    : S extends { select: any } & (industryBlueprintsArgs | industryBlueprintsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof industryBlueprints ? industryBlueprints[P] : never
  } 
      : industryBlueprints


  type industryBlueprintsCountArgs = Merge<
    Omit<industryBlueprintsFindManyArgs, 'select' | 'include'> & {
      select?: IndustryBlueprintsCountAggregateInputType | true
    }
  >

  export interface industryBlueprintsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one IndustryBlueprints that matches the filter.
     * @param {industryBlueprintsFindUniqueArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends industryBlueprintsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, industryBlueprintsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'industryBlueprints'> extends True ? Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>> : Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T> | null, null>

    /**
     * Find the first IndustryBlueprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindFirstArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends industryBlueprintsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, industryBlueprintsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'industryBlueprints'> extends True ? Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>> : Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T> | null, null>

    /**
     * Find zero or more IndustryBlueprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findMany()
     * 
     * // Get first 10 IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const industryBlueprintsWithTypeIDOnly = await prisma.industryBlueprints.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends industryBlueprintsFindManyArgs>(
      args?: SelectSubset<T, industryBlueprintsFindManyArgs>
    ): PrismaPromise<Array<industryBlueprintsGetPayload<T>>>

    /**
     * Create a IndustryBlueprints.
     * @param {industryBlueprintsCreateArgs} args - Arguments to create a IndustryBlueprints.
     * @example
     * // Create one IndustryBlueprints
     * const IndustryBlueprints = await prisma.industryBlueprints.create({
     *   data: {
     *     // ... data to create a IndustryBlueprints
     *   }
     * })
     * 
    **/
    create<T extends industryBlueprintsCreateArgs>(
      args: SelectSubset<T, industryBlueprintsCreateArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Create many IndustryBlueprints.
     *     @param {industryBlueprintsCreateManyArgs} args - Arguments to create many IndustryBlueprints.
     *     @example
     *     // Create many IndustryBlueprints
     *     const industryBlueprints = await prisma.industryBlueprints.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends industryBlueprintsCreateManyArgs>(
      args?: SelectSubset<T, industryBlueprintsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IndustryBlueprints.
     * @param {industryBlueprintsDeleteArgs} args - Arguments to delete one IndustryBlueprints.
     * @example
     * // Delete one IndustryBlueprints
     * const IndustryBlueprints = await prisma.industryBlueprints.delete({
     *   where: {
     *     // ... filter to delete one IndustryBlueprints
     *   }
     * })
     * 
    **/
    delete<T extends industryBlueprintsDeleteArgs>(
      args: SelectSubset<T, industryBlueprintsDeleteArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Update one IndustryBlueprints.
     * @param {industryBlueprintsUpdateArgs} args - Arguments to update one IndustryBlueprints.
     * @example
     * // Update one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends industryBlueprintsUpdateArgs>(
      args: SelectSubset<T, industryBlueprintsUpdateArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Delete zero or more IndustryBlueprints.
     * @param {industryBlueprintsDeleteManyArgs} args - Arguments to filter IndustryBlueprints to delete.
     * @example
     * // Delete a few IndustryBlueprints
     * const { count } = await prisma.industryBlueprints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends industryBlueprintsDeleteManyArgs>(
      args?: SelectSubset<T, industryBlueprintsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends industryBlueprintsUpdateManyArgs>(
      args: SelectSubset<T, industryBlueprintsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IndustryBlueprints.
     * @param {industryBlueprintsUpsertArgs} args - Arguments to update or create a IndustryBlueprints.
     * @example
     * // Update or create a IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.upsert({
     *   create: {
     *     // ... data to create a IndustryBlueprints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryBlueprints we want to update
     *   }
     * })
    **/
    upsert<T extends industryBlueprintsUpsertArgs>(
      args: SelectSubset<T, industryBlueprintsUpsertArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Find one IndustryBlueprints that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {industryBlueprintsFindUniqueOrThrowArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends industryBlueprintsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, industryBlueprintsFindUniqueOrThrowArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Find the first IndustryBlueprints that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindFirstOrThrowArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends industryBlueprintsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, industryBlueprintsFindFirstOrThrowArgs>
    ): Prisma__industryBlueprintsClient<industryBlueprintsGetPayload<T>>

    /**
     * Count the number of IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsCountArgs} args - Arguments to filter IndustryBlueprints to count.
     * @example
     * // Count the number of IndustryBlueprints
     * const count = await prisma.industryBlueprints.count({
     *   where: {
     *     // ... the filter for the IndustryBlueprints we want to count
     *   }
     * })
    **/
    count<T extends industryBlueprintsCountArgs>(
      args?: Subset<T, industryBlueprintsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryBlueprintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryBlueprintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryBlueprintsAggregateArgs>(args: Subset<T, IndustryBlueprintsAggregateArgs>): PrismaPromise<GetIndustryBlueprintsAggregateType<T>>

    /**
     * Group by IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryBlueprintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryBlueprintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryBlueprintsGroupByArgs['orderBy'] }
        : { orderBy?: IndustryBlueprintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryBlueprintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryBlueprintsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for industryBlueprints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__industryBlueprintsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * industryBlueprints base type for findUnique actions
   */
  export type industryBlueprintsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * Filter, which industryBlueprints to fetch.
     * 
    **/
    where: industryBlueprintsWhereUniqueInput
  }

  /**
   * industryBlueprints: findUnique
   */
  export interface industryBlueprintsFindUniqueArgs extends industryBlueprintsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * industryBlueprints base type for findFirst actions
   */
  export type industryBlueprintsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * Filter, which industryBlueprints to fetch.
     * 
    **/
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     * 
    **/
    orderBy?: Enumerable<industryBlueprintsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryBlueprints.
     * 
    **/
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryBlueprints.
     * 
    **/
    distinct?: Enumerable<IndustryBlueprintsScalarFieldEnum>
  }

  /**
   * industryBlueprints: findFirst
   */
  export interface industryBlueprintsFindFirstArgs extends industryBlueprintsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * industryBlueprints findMany
   */
  export type industryBlueprintsFindManyArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * Filter, which industryBlueprints to fetch.
     * 
    **/
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     * 
    **/
    orderBy?: Enumerable<industryBlueprintsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing industryBlueprints.
     * 
    **/
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IndustryBlueprintsScalarFieldEnum>
  }


  /**
   * industryBlueprints create
   */
  export type industryBlueprintsCreateArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * The data needed to create a industryBlueprints.
     * 
    **/
    data: XOR<industryBlueprintsCreateInput, industryBlueprintsUncheckedCreateInput>
  }


  /**
   * industryBlueprints createMany
   */
  export type industryBlueprintsCreateManyArgs = {
    /**
     * The data used to create many industryBlueprints.
     * 
    **/
    data: Enumerable<industryBlueprintsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * industryBlueprints update
   */
  export type industryBlueprintsUpdateArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * The data needed to update a industryBlueprints.
     * 
    **/
    data: XOR<industryBlueprintsUpdateInput, industryBlueprintsUncheckedUpdateInput>
    /**
     * Choose, which industryBlueprints to update.
     * 
    **/
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints updateMany
   */
  export type industryBlueprintsUpdateManyArgs = {
    /**
     * The data used to update industryBlueprints.
     * 
    **/
    data: XOR<industryBlueprintsUpdateManyMutationInput, industryBlueprintsUncheckedUpdateManyInput>
    /**
     * Filter which industryBlueprints to update
     * 
    **/
    where?: industryBlueprintsWhereInput
  }


  /**
   * industryBlueprints upsert
   */
  export type industryBlueprintsUpsertArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * The filter to search for the industryBlueprints to update in case it exists.
     * 
    **/
    where: industryBlueprintsWhereUniqueInput
    /**
     * In case the industryBlueprints found by the `where` argument doesn't exist, create a new industryBlueprints with this data.
     * 
    **/
    create: XOR<industryBlueprintsCreateInput, industryBlueprintsUncheckedCreateInput>
    /**
     * In case the industryBlueprints was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<industryBlueprintsUpdateInput, industryBlueprintsUncheckedUpdateInput>
  }


  /**
   * industryBlueprints delete
   */
  export type industryBlueprintsDeleteArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
    /**
     * Filter which industryBlueprints to delete.
     * 
    **/
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints deleteMany
   */
  export type industryBlueprintsDeleteManyArgs = {
    /**
     * Filter which industryBlueprints to delete
     * 
    **/
    where?: industryBlueprintsWhereInput
  }


  /**
   * industryBlueprints: findUniqueOrThrow
   */
  export type industryBlueprintsFindUniqueOrThrowArgs = industryBlueprintsFindUniqueArgsBase
      

  /**
   * industryBlueprints: findFirstOrThrow
   */
  export type industryBlueprintsFindFirstOrThrowArgs = industryBlueprintsFindFirstArgsBase
      

  /**
   * industryBlueprints without action
   */
  export type industryBlueprintsArgs = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     * 
    **/
    select?: industryBlueprintsSelect | null
  }



  /**
   * Model invCategories
   */


  export type AggregateInvCategories = {
    _count: InvCategoriesCountAggregateOutputType | null
    _avg: InvCategoriesAvgAggregateOutputType | null
    _sum: InvCategoriesSumAggregateOutputType | null
    _min: InvCategoriesMinAggregateOutputType | null
    _max: InvCategoriesMaxAggregateOutputType | null
  }

  export type InvCategoriesAvgAggregateOutputType = {
    categoryID: number | null
    iconID: number | null
  }

  export type InvCategoriesSumAggregateOutputType = {
    categoryID: number | null
    iconID: number | null
  }

  export type InvCategoriesMinAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    iconID: number | null
    published: boolean | null
  }

  export type InvCategoriesMaxAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    iconID: number | null
    published: boolean | null
  }

  export type InvCategoriesCountAggregateOutputType = {
    categoryID: number
    categoryName: number
    iconID: number
    published: number
    _all: number
  }


  export type InvCategoriesAvgAggregateInputType = {
    categoryID?: true
    iconID?: true
  }

  export type InvCategoriesSumAggregateInputType = {
    categoryID?: true
    iconID?: true
  }

  export type InvCategoriesMinAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
  }

  export type InvCategoriesMaxAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
  }

  export type InvCategoriesCountAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
    _all?: true
  }

  export type InvCategoriesAggregateArgs = {
    /**
     * Filter which invCategories to aggregate.
     * 
    **/
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<invCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invCategories
    **/
    _count?: true | InvCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvCategoriesMaxAggregateInputType
  }

  export type GetInvCategoriesAggregateType<T extends InvCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvCategories[P]>
      : GetScalarType<T[P], AggregateInvCategories[P]>
  }




  export type InvCategoriesGroupByArgs = {
    where?: invCategoriesWhereInput
    orderBy?: Enumerable<invCategoriesOrderByWithAggregationInput>
    by: Array<InvCategoriesScalarFieldEnum>
    having?: invCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvCategoriesCountAggregateInputType | true
    _avg?: InvCategoriesAvgAggregateInputType
    _sum?: InvCategoriesSumAggregateInputType
    _min?: InvCategoriesMinAggregateInputType
    _max?: InvCategoriesMaxAggregateInputType
  }


  export type InvCategoriesGroupByOutputType = {
    categoryID: number
    categoryName: string | null
    iconID: number | null
    published: boolean | null
    _count: InvCategoriesCountAggregateOutputType | null
    _avg: InvCategoriesAvgAggregateOutputType | null
    _sum: InvCategoriesSumAggregateOutputType | null
    _min: InvCategoriesMinAggregateOutputType | null
    _max: InvCategoriesMaxAggregateOutputType | null
  }

  type GetInvCategoriesGroupByPayload<T extends InvCategoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], InvCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type invCategoriesSelect = {
    categoryID?: boolean
    categoryName?: boolean
    iconID?: boolean
    published?: boolean
  }


  export type invCategoriesGetPayload<S extends boolean | null | undefined | invCategoriesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invCategories :
    S extends undefined ? never :
    S extends { include: any } & (invCategoriesArgs | invCategoriesFindManyArgs)
    ? invCategories 
    : S extends { select: any } & (invCategoriesArgs | invCategoriesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invCategories ? invCategories[P] : never
  } 
      : invCategories


  type invCategoriesCountArgs = Merge<
    Omit<invCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: InvCategoriesCountAggregateInputType | true
    }
  >

  export interface invCategoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvCategories that matches the filter.
     * @param {invCategoriesFindUniqueArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invCategoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invCategoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invCategories'> extends True ? Prisma__invCategoriesClient<invCategoriesGetPayload<T>> : Prisma__invCategoriesClient<invCategoriesGetPayload<T> | null, null>

    /**
     * Find the first InvCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindFirstArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invCategoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invCategoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invCategories'> extends True ? Prisma__invCategoriesClient<invCategoriesGetPayload<T>> : Prisma__invCategoriesClient<invCategoriesGetPayload<T> | null, null>

    /**
     * Find zero or more InvCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvCategories
     * const invCategories = await prisma.invCategories.findMany()
     * 
     * // Get first 10 InvCategories
     * const invCategories = await prisma.invCategories.findMany({ take: 10 })
     * 
     * // Only select the `categoryID`
     * const invCategoriesWithCategoryIDOnly = await prisma.invCategories.findMany({ select: { categoryID: true } })
     * 
    **/
    findMany<T extends invCategoriesFindManyArgs>(
      args?: SelectSubset<T, invCategoriesFindManyArgs>
    ): PrismaPromise<Array<invCategoriesGetPayload<T>>>

    /**
     * Create a InvCategories.
     * @param {invCategoriesCreateArgs} args - Arguments to create a InvCategories.
     * @example
     * // Create one InvCategories
     * const InvCategories = await prisma.invCategories.create({
     *   data: {
     *     // ... data to create a InvCategories
     *   }
     * })
     * 
    **/
    create<T extends invCategoriesCreateArgs>(
      args: SelectSubset<T, invCategoriesCreateArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Create many InvCategories.
     *     @param {invCategoriesCreateManyArgs} args - Arguments to create many InvCategories.
     *     @example
     *     // Create many InvCategories
     *     const invCategories = await prisma.invCategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invCategoriesCreateManyArgs>(
      args?: SelectSubset<T, invCategoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvCategories.
     * @param {invCategoriesDeleteArgs} args - Arguments to delete one InvCategories.
     * @example
     * // Delete one InvCategories
     * const InvCategories = await prisma.invCategories.delete({
     *   where: {
     *     // ... filter to delete one InvCategories
     *   }
     * })
     * 
    **/
    delete<T extends invCategoriesDeleteArgs>(
      args: SelectSubset<T, invCategoriesDeleteArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Update one InvCategories.
     * @param {invCategoriesUpdateArgs} args - Arguments to update one InvCategories.
     * @example
     * // Update one InvCategories
     * const invCategories = await prisma.invCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invCategoriesUpdateArgs>(
      args: SelectSubset<T, invCategoriesUpdateArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Delete zero or more InvCategories.
     * @param {invCategoriesDeleteManyArgs} args - Arguments to filter InvCategories to delete.
     * @example
     * // Delete a few InvCategories
     * const { count } = await prisma.invCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invCategoriesDeleteManyArgs>(
      args?: SelectSubset<T, invCategoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvCategories
     * const invCategories = await prisma.invCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invCategoriesUpdateManyArgs>(
      args: SelectSubset<T, invCategoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvCategories.
     * @param {invCategoriesUpsertArgs} args - Arguments to update or create a InvCategories.
     * @example
     * // Update or create a InvCategories
     * const invCategories = await prisma.invCategories.upsert({
     *   create: {
     *     // ... data to create a InvCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvCategories we want to update
     *   }
     * })
    **/
    upsert<T extends invCategoriesUpsertArgs>(
      args: SelectSubset<T, invCategoriesUpsertArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Find one InvCategories that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invCategoriesFindUniqueOrThrowArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invCategoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invCategoriesFindUniqueOrThrowArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Find the first InvCategories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindFirstOrThrowArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invCategoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invCategoriesFindFirstOrThrowArgs>
    ): Prisma__invCategoriesClient<invCategoriesGetPayload<T>>

    /**
     * Count the number of InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesCountArgs} args - Arguments to filter InvCategories to count.
     * @example
     * // Count the number of InvCategories
     * const count = await prisma.invCategories.count({
     *   where: {
     *     // ... the filter for the InvCategories we want to count
     *   }
     * })
    **/
    count<T extends invCategoriesCountArgs>(
      args?: Subset<T, invCategoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvCategoriesAggregateArgs>(args: Subset<T, InvCategoriesAggregateArgs>): PrismaPromise<GetInvCategoriesAggregateType<T>>

    /**
     * Group by InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: InvCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvCategoriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invCategoriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invCategories base type for findUnique actions
   */
  export type invCategoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * Filter, which invCategories to fetch.
     * 
    **/
    where: invCategoriesWhereUniqueInput
  }

  /**
   * invCategories: findUnique
   */
  export interface invCategoriesFindUniqueArgs extends invCategoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invCategories base type for findFirst actions
   */
  export type invCategoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * Filter, which invCategories to fetch.
     * 
    **/
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<invCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invCategories.
     * 
    **/
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invCategories.
     * 
    **/
    distinct?: Enumerable<InvCategoriesScalarFieldEnum>
  }

  /**
   * invCategories: findFirst
   */
  export interface invCategoriesFindFirstArgs extends invCategoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invCategories findMany
   */
  export type invCategoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * Filter, which invCategories to fetch.
     * 
    **/
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<invCategoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invCategories.
     * 
    **/
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvCategoriesScalarFieldEnum>
  }


  /**
   * invCategories create
   */
  export type invCategoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * The data needed to create a invCategories.
     * 
    **/
    data: XOR<invCategoriesCreateInput, invCategoriesUncheckedCreateInput>
  }


  /**
   * invCategories createMany
   */
  export type invCategoriesCreateManyArgs = {
    /**
     * The data used to create many invCategories.
     * 
    **/
    data: Enumerable<invCategoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invCategories update
   */
  export type invCategoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * The data needed to update a invCategories.
     * 
    **/
    data: XOR<invCategoriesUpdateInput, invCategoriesUncheckedUpdateInput>
    /**
     * Choose, which invCategories to update.
     * 
    **/
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories updateMany
   */
  export type invCategoriesUpdateManyArgs = {
    /**
     * The data used to update invCategories.
     * 
    **/
    data: XOR<invCategoriesUpdateManyMutationInput, invCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which invCategories to update
     * 
    **/
    where?: invCategoriesWhereInput
  }


  /**
   * invCategories upsert
   */
  export type invCategoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * The filter to search for the invCategories to update in case it exists.
     * 
    **/
    where: invCategoriesWhereUniqueInput
    /**
     * In case the invCategories found by the `where` argument doesn't exist, create a new invCategories with this data.
     * 
    **/
    create: XOR<invCategoriesCreateInput, invCategoriesUncheckedCreateInput>
    /**
     * In case the invCategories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invCategoriesUpdateInput, invCategoriesUncheckedUpdateInput>
  }


  /**
   * invCategories delete
   */
  export type invCategoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
    /**
     * Filter which invCategories to delete.
     * 
    **/
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories deleteMany
   */
  export type invCategoriesDeleteManyArgs = {
    /**
     * Filter which invCategories to delete
     * 
    **/
    where?: invCategoriesWhereInput
  }


  /**
   * invCategories: findUniqueOrThrow
   */
  export type invCategoriesFindUniqueOrThrowArgs = invCategoriesFindUniqueArgsBase
      

  /**
   * invCategories: findFirstOrThrow
   */
  export type invCategoriesFindFirstOrThrowArgs = invCategoriesFindFirstArgsBase
      

  /**
   * invCategories without action
   */
  export type invCategoriesArgs = {
    /**
     * Select specific fields to fetch from the invCategories
     * 
    **/
    select?: invCategoriesSelect | null
  }



  /**
   * Model invContrabandTypes
   */


  export type AggregateInvContrabandTypes = {
    _count: InvContrabandTypesCountAggregateOutputType | null
    _avg: InvContrabandTypesAvgAggregateOutputType | null
    _sum: InvContrabandTypesSumAggregateOutputType | null
    _min: InvContrabandTypesMinAggregateOutputType | null
    _max: InvContrabandTypesMaxAggregateOutputType | null
  }

  export type InvContrabandTypesAvgAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesSumAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesMinAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesMaxAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesCountAggregateOutputType = {
    factionID: number
    typeID: number
    standingLoss: number
    confiscateMinSec: number
    fineByValue: number
    attackMinSec: number
    _all: number
  }


  export type InvContrabandTypesAvgAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesSumAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesMinAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesMaxAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesCountAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
    _all?: true
  }

  export type InvContrabandTypesAggregateArgs = {
    /**
     * Filter which invContrabandTypes to aggregate.
     * 
    **/
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invContrabandTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invContrabandTypes
    **/
    _count?: true | InvContrabandTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvContrabandTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvContrabandTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvContrabandTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvContrabandTypesMaxAggregateInputType
  }

  export type GetInvContrabandTypesAggregateType<T extends InvContrabandTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvContrabandTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvContrabandTypes[P]>
      : GetScalarType<T[P], AggregateInvContrabandTypes[P]>
  }




  export type InvContrabandTypesGroupByArgs = {
    where?: invContrabandTypesWhereInput
    orderBy?: Enumerable<invContrabandTypesOrderByWithAggregationInput>
    by: Array<InvContrabandTypesScalarFieldEnum>
    having?: invContrabandTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvContrabandTypesCountAggregateInputType | true
    _avg?: InvContrabandTypesAvgAggregateInputType
    _sum?: InvContrabandTypesSumAggregateInputType
    _min?: InvContrabandTypesMinAggregateInputType
    _max?: InvContrabandTypesMaxAggregateInputType
  }


  export type InvContrabandTypesGroupByOutputType = {
    factionID: number
    typeID: number
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
    _count: InvContrabandTypesCountAggregateOutputType | null
    _avg: InvContrabandTypesAvgAggregateOutputType | null
    _sum: InvContrabandTypesSumAggregateOutputType | null
    _min: InvContrabandTypesMinAggregateOutputType | null
    _max: InvContrabandTypesMaxAggregateOutputType | null
  }

  type GetInvContrabandTypesGroupByPayload<T extends InvContrabandTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvContrabandTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvContrabandTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvContrabandTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvContrabandTypesGroupByOutputType[P]>
        }
      >
    >


  export type invContrabandTypesSelect = {
    factionID?: boolean
    typeID?: boolean
    standingLoss?: boolean
    confiscateMinSec?: boolean
    fineByValue?: boolean
    attackMinSec?: boolean
  }


  export type invContrabandTypesGetPayload<S extends boolean | null | undefined | invContrabandTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invContrabandTypes :
    S extends undefined ? never :
    S extends { include: any } & (invContrabandTypesArgs | invContrabandTypesFindManyArgs)
    ? invContrabandTypes 
    : S extends { select: any } & (invContrabandTypesArgs | invContrabandTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invContrabandTypes ? invContrabandTypes[P] : never
  } 
      : invContrabandTypes


  type invContrabandTypesCountArgs = Merge<
    Omit<invContrabandTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvContrabandTypesCountAggregateInputType | true
    }
  >

  export interface invContrabandTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvContrabandTypes that matches the filter.
     * @param {invContrabandTypesFindUniqueArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invContrabandTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invContrabandTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invContrabandTypes'> extends True ? Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>> : Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T> | null, null>

    /**
     * Find the first InvContrabandTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindFirstArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invContrabandTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invContrabandTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invContrabandTypes'> extends True ? Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>> : Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T> | null, null>

    /**
     * Find zero or more InvContrabandTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findMany()
     * 
     * // Get first 10 InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findMany({ take: 10 })
     * 
     * // Only select the `factionID`
     * const invContrabandTypesWithFactionIDOnly = await prisma.invContrabandTypes.findMany({ select: { factionID: true } })
     * 
    **/
    findMany<T extends invContrabandTypesFindManyArgs>(
      args?: SelectSubset<T, invContrabandTypesFindManyArgs>
    ): PrismaPromise<Array<invContrabandTypesGetPayload<T>>>

    /**
     * Create a InvContrabandTypes.
     * @param {invContrabandTypesCreateArgs} args - Arguments to create a InvContrabandTypes.
     * @example
     * // Create one InvContrabandTypes
     * const InvContrabandTypes = await prisma.invContrabandTypes.create({
     *   data: {
     *     // ... data to create a InvContrabandTypes
     *   }
     * })
     * 
    **/
    create<T extends invContrabandTypesCreateArgs>(
      args: SelectSubset<T, invContrabandTypesCreateArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Create many InvContrabandTypes.
     *     @param {invContrabandTypesCreateManyArgs} args - Arguments to create many InvContrabandTypes.
     *     @example
     *     // Create many InvContrabandTypes
     *     const invContrabandTypes = await prisma.invContrabandTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invContrabandTypesCreateManyArgs>(
      args?: SelectSubset<T, invContrabandTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvContrabandTypes.
     * @param {invContrabandTypesDeleteArgs} args - Arguments to delete one InvContrabandTypes.
     * @example
     * // Delete one InvContrabandTypes
     * const InvContrabandTypes = await prisma.invContrabandTypes.delete({
     *   where: {
     *     // ... filter to delete one InvContrabandTypes
     *   }
     * })
     * 
    **/
    delete<T extends invContrabandTypesDeleteArgs>(
      args: SelectSubset<T, invContrabandTypesDeleteArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Update one InvContrabandTypes.
     * @param {invContrabandTypesUpdateArgs} args - Arguments to update one InvContrabandTypes.
     * @example
     * // Update one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invContrabandTypesUpdateArgs>(
      args: SelectSubset<T, invContrabandTypesUpdateArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Delete zero or more InvContrabandTypes.
     * @param {invContrabandTypesDeleteManyArgs} args - Arguments to filter InvContrabandTypes to delete.
     * @example
     * // Delete a few InvContrabandTypes
     * const { count } = await prisma.invContrabandTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invContrabandTypesDeleteManyArgs>(
      args?: SelectSubset<T, invContrabandTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invContrabandTypesUpdateManyArgs>(
      args: SelectSubset<T, invContrabandTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvContrabandTypes.
     * @param {invContrabandTypesUpsertArgs} args - Arguments to update or create a InvContrabandTypes.
     * @example
     * // Update or create a InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.upsert({
     *   create: {
     *     // ... data to create a InvContrabandTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvContrabandTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invContrabandTypesUpsertArgs>(
      args: SelectSubset<T, invContrabandTypesUpsertArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Find one InvContrabandTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invContrabandTypesFindUniqueOrThrowArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invContrabandTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invContrabandTypesFindUniqueOrThrowArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Find the first InvContrabandTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindFirstOrThrowArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invContrabandTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invContrabandTypesFindFirstOrThrowArgs>
    ): Prisma__invContrabandTypesClient<invContrabandTypesGetPayload<T>>

    /**
     * Count the number of InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesCountArgs} args - Arguments to filter InvContrabandTypes to count.
     * @example
     * // Count the number of InvContrabandTypes
     * const count = await prisma.invContrabandTypes.count({
     *   where: {
     *     // ... the filter for the InvContrabandTypes we want to count
     *   }
     * })
    **/
    count<T extends invContrabandTypesCountArgs>(
      args?: Subset<T, invContrabandTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvContrabandTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvContrabandTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvContrabandTypesAggregateArgs>(args: Subset<T, InvContrabandTypesAggregateArgs>): PrismaPromise<GetInvContrabandTypesAggregateType<T>>

    /**
     * Group by InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvContrabandTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvContrabandTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvContrabandTypesGroupByArgs['orderBy'] }
        : { orderBy?: InvContrabandTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvContrabandTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvContrabandTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invContrabandTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invContrabandTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invContrabandTypes base type for findUnique actions
   */
  export type invContrabandTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * Filter, which invContrabandTypes to fetch.
     * 
    **/
    where: invContrabandTypesWhereUniqueInput
  }

  /**
   * invContrabandTypes: findUnique
   */
  export interface invContrabandTypesFindUniqueArgs extends invContrabandTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invContrabandTypes base type for findFirst actions
   */
  export type invContrabandTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * Filter, which invContrabandTypes to fetch.
     * 
    **/
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invContrabandTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invContrabandTypes.
     * 
    **/
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invContrabandTypes.
     * 
    **/
    distinct?: Enumerable<InvContrabandTypesScalarFieldEnum>
  }

  /**
   * invContrabandTypes: findFirst
   */
  export interface invContrabandTypesFindFirstArgs extends invContrabandTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invContrabandTypes findMany
   */
  export type invContrabandTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * Filter, which invContrabandTypes to fetch.
     * 
    **/
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invContrabandTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invContrabandTypes.
     * 
    **/
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvContrabandTypesScalarFieldEnum>
  }


  /**
   * invContrabandTypes create
   */
  export type invContrabandTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * The data needed to create a invContrabandTypes.
     * 
    **/
    data: XOR<invContrabandTypesCreateInput, invContrabandTypesUncheckedCreateInput>
  }


  /**
   * invContrabandTypes createMany
   */
  export type invContrabandTypesCreateManyArgs = {
    /**
     * The data used to create many invContrabandTypes.
     * 
    **/
    data: Enumerable<invContrabandTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invContrabandTypes update
   */
  export type invContrabandTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * The data needed to update a invContrabandTypes.
     * 
    **/
    data: XOR<invContrabandTypesUpdateInput, invContrabandTypesUncheckedUpdateInput>
    /**
     * Choose, which invContrabandTypes to update.
     * 
    **/
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes updateMany
   */
  export type invContrabandTypesUpdateManyArgs = {
    /**
     * The data used to update invContrabandTypes.
     * 
    **/
    data: XOR<invContrabandTypesUpdateManyMutationInput, invContrabandTypesUncheckedUpdateManyInput>
    /**
     * Filter which invContrabandTypes to update
     * 
    **/
    where?: invContrabandTypesWhereInput
  }


  /**
   * invContrabandTypes upsert
   */
  export type invContrabandTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * The filter to search for the invContrabandTypes to update in case it exists.
     * 
    **/
    where: invContrabandTypesWhereUniqueInput
    /**
     * In case the invContrabandTypes found by the `where` argument doesn't exist, create a new invContrabandTypes with this data.
     * 
    **/
    create: XOR<invContrabandTypesCreateInput, invContrabandTypesUncheckedCreateInput>
    /**
     * In case the invContrabandTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invContrabandTypesUpdateInput, invContrabandTypesUncheckedUpdateInput>
  }


  /**
   * invContrabandTypes delete
   */
  export type invContrabandTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
    /**
     * Filter which invContrabandTypes to delete.
     * 
    **/
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes deleteMany
   */
  export type invContrabandTypesDeleteManyArgs = {
    /**
     * Filter which invContrabandTypes to delete
     * 
    **/
    where?: invContrabandTypesWhereInput
  }


  /**
   * invContrabandTypes: findUniqueOrThrow
   */
  export type invContrabandTypesFindUniqueOrThrowArgs = invContrabandTypesFindUniqueArgsBase
      

  /**
   * invContrabandTypes: findFirstOrThrow
   */
  export type invContrabandTypesFindFirstOrThrowArgs = invContrabandTypesFindFirstArgsBase
      

  /**
   * invContrabandTypes without action
   */
  export type invContrabandTypesArgs = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     * 
    **/
    select?: invContrabandTypesSelect | null
  }



  /**
   * Model invControlTowerResourcePurposes
   */


  export type AggregateInvControlTowerResourcePurposes = {
    _count: InvControlTowerResourcePurposesCountAggregateOutputType | null
    _avg: InvControlTowerResourcePurposesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcePurposesSumAggregateOutputType | null
    _min: InvControlTowerResourcePurposesMinAggregateOutputType | null
    _max: InvControlTowerResourcePurposesMaxAggregateOutputType | null
  }

  export type InvControlTowerResourcePurposesAvgAggregateOutputType = {
    purpose: number | null
  }

  export type InvControlTowerResourcePurposesSumAggregateOutputType = {
    purpose: number | null
  }

  export type InvControlTowerResourcePurposesMinAggregateOutputType = {
    purpose: number | null
    purposeText: string | null
  }

  export type InvControlTowerResourcePurposesMaxAggregateOutputType = {
    purpose: number | null
    purposeText: string | null
  }

  export type InvControlTowerResourcePurposesCountAggregateOutputType = {
    purpose: number
    purposeText: number
    _all: number
  }


  export type InvControlTowerResourcePurposesAvgAggregateInputType = {
    purpose?: true
  }

  export type InvControlTowerResourcePurposesSumAggregateInputType = {
    purpose?: true
  }

  export type InvControlTowerResourcePurposesMinAggregateInputType = {
    purpose?: true
    purposeText?: true
  }

  export type InvControlTowerResourcePurposesMaxAggregateInputType = {
    purpose?: true
    purposeText?: true
  }

  export type InvControlTowerResourcePurposesCountAggregateInputType = {
    purpose?: true
    purposeText?: true
    _all?: true
  }

  export type InvControlTowerResourcePurposesAggregateArgs = {
    /**
     * Filter which invControlTowerResourcePurposes to aggregate.
     * 
    **/
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcePurposesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invControlTowerResourcePurposes
    **/
    _count?: true | InvControlTowerResourcePurposesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvControlTowerResourcePurposesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvControlTowerResourcePurposesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvControlTowerResourcePurposesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvControlTowerResourcePurposesMaxAggregateInputType
  }

  export type GetInvControlTowerResourcePurposesAggregateType<T extends InvControlTowerResourcePurposesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvControlTowerResourcePurposes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvControlTowerResourcePurposes[P]>
      : GetScalarType<T[P], AggregateInvControlTowerResourcePurposes[P]>
  }




  export type InvControlTowerResourcePurposesGroupByArgs = {
    where?: invControlTowerResourcePurposesWhereInput
    orderBy?: Enumerable<invControlTowerResourcePurposesOrderByWithAggregationInput>
    by: Array<InvControlTowerResourcePurposesScalarFieldEnum>
    having?: invControlTowerResourcePurposesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvControlTowerResourcePurposesCountAggregateInputType | true
    _avg?: InvControlTowerResourcePurposesAvgAggregateInputType
    _sum?: InvControlTowerResourcePurposesSumAggregateInputType
    _min?: InvControlTowerResourcePurposesMinAggregateInputType
    _max?: InvControlTowerResourcePurposesMaxAggregateInputType
  }


  export type InvControlTowerResourcePurposesGroupByOutputType = {
    purpose: number
    purposeText: string | null
    _count: InvControlTowerResourcePurposesCountAggregateOutputType | null
    _avg: InvControlTowerResourcePurposesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcePurposesSumAggregateOutputType | null
    _min: InvControlTowerResourcePurposesMinAggregateOutputType | null
    _max: InvControlTowerResourcePurposesMaxAggregateOutputType | null
  }

  type GetInvControlTowerResourcePurposesGroupByPayload<T extends InvControlTowerResourcePurposesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvControlTowerResourcePurposesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvControlTowerResourcePurposesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvControlTowerResourcePurposesGroupByOutputType[P]>
            : GetScalarType<T[P], InvControlTowerResourcePurposesGroupByOutputType[P]>
        }
      >
    >


  export type invControlTowerResourcePurposesSelect = {
    purpose?: boolean
    purposeText?: boolean
  }


  export type invControlTowerResourcePurposesGetPayload<S extends boolean | null | undefined | invControlTowerResourcePurposesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invControlTowerResourcePurposes :
    S extends undefined ? never :
    S extends { include: any } & (invControlTowerResourcePurposesArgs | invControlTowerResourcePurposesFindManyArgs)
    ? invControlTowerResourcePurposes 
    : S extends { select: any } & (invControlTowerResourcePurposesArgs | invControlTowerResourcePurposesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invControlTowerResourcePurposes ? invControlTowerResourcePurposes[P] : never
  } 
      : invControlTowerResourcePurposes


  type invControlTowerResourcePurposesCountArgs = Merge<
    Omit<invControlTowerResourcePurposesFindManyArgs, 'select' | 'include'> & {
      select?: InvControlTowerResourcePurposesCountAggregateInputType | true
    }
  >

  export interface invControlTowerResourcePurposesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvControlTowerResourcePurposes that matches the filter.
     * @param {invControlTowerResourcePurposesFindUniqueArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invControlTowerResourcePurposesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invControlTowerResourcePurposesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invControlTowerResourcePurposes'> extends True ? Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>> : Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T> | null, null>

    /**
     * Find the first InvControlTowerResourcePurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindFirstArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invControlTowerResourcePurposesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invControlTowerResourcePurposes'> extends True ? Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>> : Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T> | null, null>

    /**
     * Find zero or more InvControlTowerResourcePurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany()
     * 
     * // Get first 10 InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany({ take: 10 })
     * 
     * // Only select the `purpose`
     * const invControlTowerResourcePurposesWithPurposeOnly = await prisma.invControlTowerResourcePurposes.findMany({ select: { purpose: true } })
     * 
    **/
    findMany<T extends invControlTowerResourcePurposesFindManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindManyArgs>
    ): PrismaPromise<Array<invControlTowerResourcePurposesGetPayload<T>>>

    /**
     * Create a InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesCreateArgs} args - Arguments to create a InvControlTowerResourcePurposes.
     * @example
     * // Create one InvControlTowerResourcePurposes
     * const InvControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.create({
     *   data: {
     *     // ... data to create a InvControlTowerResourcePurposes
     *   }
     * })
     * 
    **/
    create<T extends invControlTowerResourcePurposesCreateArgs>(
      args: SelectSubset<T, invControlTowerResourcePurposesCreateArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Create many InvControlTowerResourcePurposes.
     *     @param {invControlTowerResourcePurposesCreateManyArgs} args - Arguments to create many InvControlTowerResourcePurposes.
     *     @example
     *     // Create many InvControlTowerResourcePurposes
     *     const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invControlTowerResourcePurposesCreateManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcePurposesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesDeleteArgs} args - Arguments to delete one InvControlTowerResourcePurposes.
     * @example
     * // Delete one InvControlTowerResourcePurposes
     * const InvControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.delete({
     *   where: {
     *     // ... filter to delete one InvControlTowerResourcePurposes
     *   }
     * })
     * 
    **/
    delete<T extends invControlTowerResourcePurposesDeleteArgs>(
      args: SelectSubset<T, invControlTowerResourcePurposesDeleteArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Update one InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesUpdateArgs} args - Arguments to update one InvControlTowerResourcePurposes.
     * @example
     * // Update one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invControlTowerResourcePurposesUpdateArgs>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpdateArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Delete zero or more InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesDeleteManyArgs} args - Arguments to filter InvControlTowerResourcePurposes to delete.
     * @example
     * // Delete a few InvControlTowerResourcePurposes
     * const { count } = await prisma.invControlTowerResourcePurposes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invControlTowerResourcePurposesDeleteManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcePurposesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invControlTowerResourcePurposesUpdateManyArgs>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesUpsertArgs} args - Arguments to update or create a InvControlTowerResourcePurposes.
     * @example
     * // Update or create a InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.upsert({
     *   create: {
     *     // ... data to create a InvControlTowerResourcePurposes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvControlTowerResourcePurposes we want to update
     *   }
     * })
    **/
    upsert<T extends invControlTowerResourcePurposesUpsertArgs>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpsertArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Find one InvControlTowerResourcePurposes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invControlTowerResourcePurposesFindUniqueOrThrowArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invControlTowerResourcePurposesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindUniqueOrThrowArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Find the first InvControlTowerResourcePurposes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindFirstOrThrowArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invControlTowerResourcePurposesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindFirstOrThrowArgs>
    ): Prisma__invControlTowerResourcePurposesClient<invControlTowerResourcePurposesGetPayload<T>>

    /**
     * Count the number of InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesCountArgs} args - Arguments to filter InvControlTowerResourcePurposes to count.
     * @example
     * // Count the number of InvControlTowerResourcePurposes
     * const count = await prisma.invControlTowerResourcePurposes.count({
     *   where: {
     *     // ... the filter for the InvControlTowerResourcePurposes we want to count
     *   }
     * })
    **/
    count<T extends invControlTowerResourcePurposesCountArgs>(
      args?: Subset<T, invControlTowerResourcePurposesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvControlTowerResourcePurposesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcePurposesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvControlTowerResourcePurposesAggregateArgs>(args: Subset<T, InvControlTowerResourcePurposesAggregateArgs>): PrismaPromise<GetInvControlTowerResourcePurposesAggregateType<T>>

    /**
     * Group by InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcePurposesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvControlTowerResourcePurposesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvControlTowerResourcePurposesGroupByArgs['orderBy'] }
        : { orderBy?: InvControlTowerResourcePurposesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvControlTowerResourcePurposesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvControlTowerResourcePurposesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invControlTowerResourcePurposes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invControlTowerResourcePurposesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invControlTowerResourcePurposes base type for findUnique actions
   */
  export type invControlTowerResourcePurposesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     * 
    **/
    where: invControlTowerResourcePurposesWhereUniqueInput
  }

  /**
   * invControlTowerResourcePurposes: findUnique
   */
  export interface invControlTowerResourcePurposesFindUniqueArgs extends invControlTowerResourcePurposesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invControlTowerResourcePurposes base type for findFirst actions
   */
  export type invControlTowerResourcePurposesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     * 
    **/
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcePurposesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResourcePurposes.
     * 
    **/
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResourcePurposes.
     * 
    **/
    distinct?: Enumerable<InvControlTowerResourcePurposesScalarFieldEnum>
  }

  /**
   * invControlTowerResourcePurposes: findFirst
   */
  export interface invControlTowerResourcePurposesFindFirstArgs extends invControlTowerResourcePurposesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invControlTowerResourcePurposes findMany
   */
  export type invControlTowerResourcePurposesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     * 
    **/
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcePurposesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invControlTowerResourcePurposes.
     * 
    **/
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvControlTowerResourcePurposesScalarFieldEnum>
  }


  /**
   * invControlTowerResourcePurposes create
   */
  export type invControlTowerResourcePurposesCreateArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * The data needed to create a invControlTowerResourcePurposes.
     * 
    **/
    data: XOR<invControlTowerResourcePurposesCreateInput, invControlTowerResourcePurposesUncheckedCreateInput>
  }


  /**
   * invControlTowerResourcePurposes createMany
   */
  export type invControlTowerResourcePurposesCreateManyArgs = {
    /**
     * The data used to create many invControlTowerResourcePurposes.
     * 
    **/
    data: Enumerable<invControlTowerResourcePurposesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invControlTowerResourcePurposes update
   */
  export type invControlTowerResourcePurposesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * The data needed to update a invControlTowerResourcePurposes.
     * 
    **/
    data: XOR<invControlTowerResourcePurposesUpdateInput, invControlTowerResourcePurposesUncheckedUpdateInput>
    /**
     * Choose, which invControlTowerResourcePurposes to update.
     * 
    **/
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes updateMany
   */
  export type invControlTowerResourcePurposesUpdateManyArgs = {
    /**
     * The data used to update invControlTowerResourcePurposes.
     * 
    **/
    data: XOR<invControlTowerResourcePurposesUpdateManyMutationInput, invControlTowerResourcePurposesUncheckedUpdateManyInput>
    /**
     * Filter which invControlTowerResourcePurposes to update
     * 
    **/
    where?: invControlTowerResourcePurposesWhereInput
  }


  /**
   * invControlTowerResourcePurposes upsert
   */
  export type invControlTowerResourcePurposesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * The filter to search for the invControlTowerResourcePurposes to update in case it exists.
     * 
    **/
    where: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * In case the invControlTowerResourcePurposes found by the `where` argument doesn't exist, create a new invControlTowerResourcePurposes with this data.
     * 
    **/
    create: XOR<invControlTowerResourcePurposesCreateInput, invControlTowerResourcePurposesUncheckedCreateInput>
    /**
     * In case the invControlTowerResourcePurposes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invControlTowerResourcePurposesUpdateInput, invControlTowerResourcePurposesUncheckedUpdateInput>
  }


  /**
   * invControlTowerResourcePurposes delete
   */
  export type invControlTowerResourcePurposesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
    /**
     * Filter which invControlTowerResourcePurposes to delete.
     * 
    **/
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes deleteMany
   */
  export type invControlTowerResourcePurposesDeleteManyArgs = {
    /**
     * Filter which invControlTowerResourcePurposes to delete
     * 
    **/
    where?: invControlTowerResourcePurposesWhereInput
  }


  /**
   * invControlTowerResourcePurposes: findUniqueOrThrow
   */
  export type invControlTowerResourcePurposesFindUniqueOrThrowArgs = invControlTowerResourcePurposesFindUniqueArgsBase
      

  /**
   * invControlTowerResourcePurposes: findFirstOrThrow
   */
  export type invControlTowerResourcePurposesFindFirstOrThrowArgs = invControlTowerResourcePurposesFindFirstArgsBase
      

  /**
   * invControlTowerResourcePurposes without action
   */
  export type invControlTowerResourcePurposesArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     * 
    **/
    select?: invControlTowerResourcePurposesSelect | null
  }



  /**
   * Model invControlTowerResources
   */


  export type AggregateInvControlTowerResources = {
    _count: InvControlTowerResourcesCountAggregateOutputType | null
    _avg: InvControlTowerResourcesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcesSumAggregateOutputType | null
    _min: InvControlTowerResourcesMinAggregateOutputType | null
    _max: InvControlTowerResourcesMaxAggregateOutputType | null
  }

  export type InvControlTowerResourcesAvgAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesSumAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesMinAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesMaxAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesCountAggregateOutputType = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose: number
    quantity: number
    minSecurityLevel: number
    factionID: number
    _all: number
  }


  export type InvControlTowerResourcesAvgAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesSumAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesMinAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesMaxAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesCountAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
    _all?: true
  }

  export type InvControlTowerResourcesAggregateArgs = {
    /**
     * Filter which invControlTowerResources to aggregate.
     * 
    **/
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invControlTowerResources
    **/
    _count?: true | InvControlTowerResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvControlTowerResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvControlTowerResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvControlTowerResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvControlTowerResourcesMaxAggregateInputType
  }

  export type GetInvControlTowerResourcesAggregateType<T extends InvControlTowerResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvControlTowerResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvControlTowerResources[P]>
      : GetScalarType<T[P], AggregateInvControlTowerResources[P]>
  }




  export type InvControlTowerResourcesGroupByArgs = {
    where?: invControlTowerResourcesWhereInput
    orderBy?: Enumerable<invControlTowerResourcesOrderByWithAggregationInput>
    by: Array<InvControlTowerResourcesScalarFieldEnum>
    having?: invControlTowerResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvControlTowerResourcesCountAggregateInputType | true
    _avg?: InvControlTowerResourcesAvgAggregateInputType
    _sum?: InvControlTowerResourcesSumAggregateInputType
    _min?: InvControlTowerResourcesMinAggregateInputType
    _max?: InvControlTowerResourcesMaxAggregateInputType
  }


  export type InvControlTowerResourcesGroupByOutputType = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
    _count: InvControlTowerResourcesCountAggregateOutputType | null
    _avg: InvControlTowerResourcesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcesSumAggregateOutputType | null
    _min: InvControlTowerResourcesMinAggregateOutputType | null
    _max: InvControlTowerResourcesMaxAggregateOutputType | null
  }

  type GetInvControlTowerResourcesGroupByPayload<T extends InvControlTowerResourcesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvControlTowerResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvControlTowerResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvControlTowerResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], InvControlTowerResourcesGroupByOutputType[P]>
        }
      >
    >


  export type invControlTowerResourcesSelect = {
    controlTowerTypeID?: boolean
    resourceTypeID?: boolean
    purpose?: boolean
    quantity?: boolean
    minSecurityLevel?: boolean
    factionID?: boolean
  }


  export type invControlTowerResourcesGetPayload<S extends boolean | null | undefined | invControlTowerResourcesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invControlTowerResources :
    S extends undefined ? never :
    S extends { include: any } & (invControlTowerResourcesArgs | invControlTowerResourcesFindManyArgs)
    ? invControlTowerResources 
    : S extends { select: any } & (invControlTowerResourcesArgs | invControlTowerResourcesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invControlTowerResources ? invControlTowerResources[P] : never
  } 
      : invControlTowerResources


  type invControlTowerResourcesCountArgs = Merge<
    Omit<invControlTowerResourcesFindManyArgs, 'select' | 'include'> & {
      select?: InvControlTowerResourcesCountAggregateInputType | true
    }
  >

  export interface invControlTowerResourcesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvControlTowerResources that matches the filter.
     * @param {invControlTowerResourcesFindUniqueArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invControlTowerResourcesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invControlTowerResourcesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invControlTowerResources'> extends True ? Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>> : Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T> | null, null>

    /**
     * Find the first InvControlTowerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindFirstArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invControlTowerResourcesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invControlTowerResourcesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invControlTowerResources'> extends True ? Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>> : Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T> | null, null>

    /**
     * Find zero or more InvControlTowerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findMany()
     * 
     * // Get first 10 InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findMany({ take: 10 })
     * 
     * // Only select the `controlTowerTypeID`
     * const invControlTowerResourcesWithControlTowerTypeIDOnly = await prisma.invControlTowerResources.findMany({ select: { controlTowerTypeID: true } })
     * 
    **/
    findMany<T extends invControlTowerResourcesFindManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcesFindManyArgs>
    ): PrismaPromise<Array<invControlTowerResourcesGetPayload<T>>>

    /**
     * Create a InvControlTowerResources.
     * @param {invControlTowerResourcesCreateArgs} args - Arguments to create a InvControlTowerResources.
     * @example
     * // Create one InvControlTowerResources
     * const InvControlTowerResources = await prisma.invControlTowerResources.create({
     *   data: {
     *     // ... data to create a InvControlTowerResources
     *   }
     * })
     * 
    **/
    create<T extends invControlTowerResourcesCreateArgs>(
      args: SelectSubset<T, invControlTowerResourcesCreateArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Create many InvControlTowerResources.
     *     @param {invControlTowerResourcesCreateManyArgs} args - Arguments to create many InvControlTowerResources.
     *     @example
     *     // Create many InvControlTowerResources
     *     const invControlTowerResources = await prisma.invControlTowerResources.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invControlTowerResourcesCreateManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvControlTowerResources.
     * @param {invControlTowerResourcesDeleteArgs} args - Arguments to delete one InvControlTowerResources.
     * @example
     * // Delete one InvControlTowerResources
     * const InvControlTowerResources = await prisma.invControlTowerResources.delete({
     *   where: {
     *     // ... filter to delete one InvControlTowerResources
     *   }
     * })
     * 
    **/
    delete<T extends invControlTowerResourcesDeleteArgs>(
      args: SelectSubset<T, invControlTowerResourcesDeleteArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Update one InvControlTowerResources.
     * @param {invControlTowerResourcesUpdateArgs} args - Arguments to update one InvControlTowerResources.
     * @example
     * // Update one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invControlTowerResourcesUpdateArgs>(
      args: SelectSubset<T, invControlTowerResourcesUpdateArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Delete zero or more InvControlTowerResources.
     * @param {invControlTowerResourcesDeleteManyArgs} args - Arguments to filter InvControlTowerResources to delete.
     * @example
     * // Delete a few InvControlTowerResources
     * const { count } = await prisma.invControlTowerResources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invControlTowerResourcesDeleteManyArgs>(
      args?: SelectSubset<T, invControlTowerResourcesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invControlTowerResourcesUpdateManyArgs>(
      args: SelectSubset<T, invControlTowerResourcesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvControlTowerResources.
     * @param {invControlTowerResourcesUpsertArgs} args - Arguments to update or create a InvControlTowerResources.
     * @example
     * // Update or create a InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.upsert({
     *   create: {
     *     // ... data to create a InvControlTowerResources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvControlTowerResources we want to update
     *   }
     * })
    **/
    upsert<T extends invControlTowerResourcesUpsertArgs>(
      args: SelectSubset<T, invControlTowerResourcesUpsertArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Find one InvControlTowerResources that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invControlTowerResourcesFindUniqueOrThrowArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invControlTowerResourcesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invControlTowerResourcesFindUniqueOrThrowArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Find the first InvControlTowerResources that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindFirstOrThrowArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invControlTowerResourcesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invControlTowerResourcesFindFirstOrThrowArgs>
    ): Prisma__invControlTowerResourcesClient<invControlTowerResourcesGetPayload<T>>

    /**
     * Count the number of InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesCountArgs} args - Arguments to filter InvControlTowerResources to count.
     * @example
     * // Count the number of InvControlTowerResources
     * const count = await prisma.invControlTowerResources.count({
     *   where: {
     *     // ... the filter for the InvControlTowerResources we want to count
     *   }
     * })
    **/
    count<T extends invControlTowerResourcesCountArgs>(
      args?: Subset<T, invControlTowerResourcesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvControlTowerResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvControlTowerResourcesAggregateArgs>(args: Subset<T, InvControlTowerResourcesAggregateArgs>): PrismaPromise<GetInvControlTowerResourcesAggregateType<T>>

    /**
     * Group by InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvControlTowerResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvControlTowerResourcesGroupByArgs['orderBy'] }
        : { orderBy?: InvControlTowerResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvControlTowerResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvControlTowerResourcesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invControlTowerResources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invControlTowerResourcesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invControlTowerResources base type for findUnique actions
   */
  export type invControlTowerResourcesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * Filter, which invControlTowerResources to fetch.
     * 
    **/
    where: invControlTowerResourcesWhereUniqueInput
  }

  /**
   * invControlTowerResources: findUnique
   */
  export interface invControlTowerResourcesFindUniqueArgs extends invControlTowerResourcesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invControlTowerResources base type for findFirst actions
   */
  export type invControlTowerResourcesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * Filter, which invControlTowerResources to fetch.
     * 
    **/
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResources.
     * 
    **/
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResources.
     * 
    **/
    distinct?: Enumerable<InvControlTowerResourcesScalarFieldEnum>
  }

  /**
   * invControlTowerResources: findFirst
   */
  export interface invControlTowerResourcesFindFirstArgs extends invControlTowerResourcesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invControlTowerResources findMany
   */
  export type invControlTowerResourcesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * Filter, which invControlTowerResources to fetch.
     * 
    **/
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     * 
    **/
    orderBy?: Enumerable<invControlTowerResourcesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invControlTowerResources.
     * 
    **/
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvControlTowerResourcesScalarFieldEnum>
  }


  /**
   * invControlTowerResources create
   */
  export type invControlTowerResourcesCreateArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * The data needed to create a invControlTowerResources.
     * 
    **/
    data: XOR<invControlTowerResourcesCreateInput, invControlTowerResourcesUncheckedCreateInput>
  }


  /**
   * invControlTowerResources createMany
   */
  export type invControlTowerResourcesCreateManyArgs = {
    /**
     * The data used to create many invControlTowerResources.
     * 
    **/
    data: Enumerable<invControlTowerResourcesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invControlTowerResources update
   */
  export type invControlTowerResourcesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * The data needed to update a invControlTowerResources.
     * 
    **/
    data: XOR<invControlTowerResourcesUpdateInput, invControlTowerResourcesUncheckedUpdateInput>
    /**
     * Choose, which invControlTowerResources to update.
     * 
    **/
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources updateMany
   */
  export type invControlTowerResourcesUpdateManyArgs = {
    /**
     * The data used to update invControlTowerResources.
     * 
    **/
    data: XOR<invControlTowerResourcesUpdateManyMutationInput, invControlTowerResourcesUncheckedUpdateManyInput>
    /**
     * Filter which invControlTowerResources to update
     * 
    **/
    where?: invControlTowerResourcesWhereInput
  }


  /**
   * invControlTowerResources upsert
   */
  export type invControlTowerResourcesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * The filter to search for the invControlTowerResources to update in case it exists.
     * 
    **/
    where: invControlTowerResourcesWhereUniqueInput
    /**
     * In case the invControlTowerResources found by the `where` argument doesn't exist, create a new invControlTowerResources with this data.
     * 
    **/
    create: XOR<invControlTowerResourcesCreateInput, invControlTowerResourcesUncheckedCreateInput>
    /**
     * In case the invControlTowerResources was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invControlTowerResourcesUpdateInput, invControlTowerResourcesUncheckedUpdateInput>
  }


  /**
   * invControlTowerResources delete
   */
  export type invControlTowerResourcesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
    /**
     * Filter which invControlTowerResources to delete.
     * 
    **/
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources deleteMany
   */
  export type invControlTowerResourcesDeleteManyArgs = {
    /**
     * Filter which invControlTowerResources to delete
     * 
    **/
    where?: invControlTowerResourcesWhereInput
  }


  /**
   * invControlTowerResources: findUniqueOrThrow
   */
  export type invControlTowerResourcesFindUniqueOrThrowArgs = invControlTowerResourcesFindUniqueArgsBase
      

  /**
   * invControlTowerResources: findFirstOrThrow
   */
  export type invControlTowerResourcesFindFirstOrThrowArgs = invControlTowerResourcesFindFirstArgsBase
      

  /**
   * invControlTowerResources without action
   */
  export type invControlTowerResourcesArgs = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     * 
    **/
    select?: invControlTowerResourcesSelect | null
  }



  /**
   * Model invFlags
   */


  export type AggregateInvFlags = {
    _count: InvFlagsCountAggregateOutputType | null
    _avg: InvFlagsAvgAggregateOutputType | null
    _sum: InvFlagsSumAggregateOutputType | null
    _min: InvFlagsMinAggregateOutputType | null
    _max: InvFlagsMaxAggregateOutputType | null
  }

  export type InvFlagsAvgAggregateOutputType = {
    flagID: number | null
    orderID: number | null
  }

  export type InvFlagsSumAggregateOutputType = {
    flagID: number | null
    orderID: number | null
  }

  export type InvFlagsMinAggregateOutputType = {
    flagID: number | null
    flagName: string | null
    flagText: string | null
    orderID: number | null
  }

  export type InvFlagsMaxAggregateOutputType = {
    flagID: number | null
    flagName: string | null
    flagText: string | null
    orderID: number | null
  }

  export type InvFlagsCountAggregateOutputType = {
    flagID: number
    flagName: number
    flagText: number
    orderID: number
    _all: number
  }


  export type InvFlagsAvgAggregateInputType = {
    flagID?: true
    orderID?: true
  }

  export type InvFlagsSumAggregateInputType = {
    flagID?: true
    orderID?: true
  }

  export type InvFlagsMinAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
  }

  export type InvFlagsMaxAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
  }

  export type InvFlagsCountAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
    _all?: true
  }

  export type InvFlagsAggregateArgs = {
    /**
     * Filter which invFlags to aggregate.
     * 
    **/
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     * 
    **/
    orderBy?: Enumerable<invFlagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invFlags
    **/
    _count?: true | InvFlagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvFlagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvFlagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvFlagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvFlagsMaxAggregateInputType
  }

  export type GetInvFlagsAggregateType<T extends InvFlagsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvFlags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvFlags[P]>
      : GetScalarType<T[P], AggregateInvFlags[P]>
  }




  export type InvFlagsGroupByArgs = {
    where?: invFlagsWhereInput
    orderBy?: Enumerable<invFlagsOrderByWithAggregationInput>
    by: Array<InvFlagsScalarFieldEnum>
    having?: invFlagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvFlagsCountAggregateInputType | true
    _avg?: InvFlagsAvgAggregateInputType
    _sum?: InvFlagsSumAggregateInputType
    _min?: InvFlagsMinAggregateInputType
    _max?: InvFlagsMaxAggregateInputType
  }


  export type InvFlagsGroupByOutputType = {
    flagID: number
    flagName: string | null
    flagText: string | null
    orderID: number | null
    _count: InvFlagsCountAggregateOutputType | null
    _avg: InvFlagsAvgAggregateOutputType | null
    _sum: InvFlagsSumAggregateOutputType | null
    _min: InvFlagsMinAggregateOutputType | null
    _max: InvFlagsMaxAggregateOutputType | null
  }

  type GetInvFlagsGroupByPayload<T extends InvFlagsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvFlagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvFlagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvFlagsGroupByOutputType[P]>
            : GetScalarType<T[P], InvFlagsGroupByOutputType[P]>
        }
      >
    >


  export type invFlagsSelect = {
    flagID?: boolean
    flagName?: boolean
    flagText?: boolean
    orderID?: boolean
  }


  export type invFlagsGetPayload<S extends boolean | null | undefined | invFlagsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invFlags :
    S extends undefined ? never :
    S extends { include: any } & (invFlagsArgs | invFlagsFindManyArgs)
    ? invFlags 
    : S extends { select: any } & (invFlagsArgs | invFlagsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invFlags ? invFlags[P] : never
  } 
      : invFlags


  type invFlagsCountArgs = Merge<
    Omit<invFlagsFindManyArgs, 'select' | 'include'> & {
      select?: InvFlagsCountAggregateInputType | true
    }
  >

  export interface invFlagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvFlags that matches the filter.
     * @param {invFlagsFindUniqueArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invFlagsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invFlagsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invFlags'> extends True ? Prisma__invFlagsClient<invFlagsGetPayload<T>> : Prisma__invFlagsClient<invFlagsGetPayload<T> | null, null>

    /**
     * Find the first InvFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindFirstArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invFlagsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invFlagsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invFlags'> extends True ? Prisma__invFlagsClient<invFlagsGetPayload<T>> : Prisma__invFlagsClient<invFlagsGetPayload<T> | null, null>

    /**
     * Find zero or more InvFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvFlags
     * const invFlags = await prisma.invFlags.findMany()
     * 
     * // Get first 10 InvFlags
     * const invFlags = await prisma.invFlags.findMany({ take: 10 })
     * 
     * // Only select the `flagID`
     * const invFlagsWithFlagIDOnly = await prisma.invFlags.findMany({ select: { flagID: true } })
     * 
    **/
    findMany<T extends invFlagsFindManyArgs>(
      args?: SelectSubset<T, invFlagsFindManyArgs>
    ): PrismaPromise<Array<invFlagsGetPayload<T>>>

    /**
     * Create a InvFlags.
     * @param {invFlagsCreateArgs} args - Arguments to create a InvFlags.
     * @example
     * // Create one InvFlags
     * const InvFlags = await prisma.invFlags.create({
     *   data: {
     *     // ... data to create a InvFlags
     *   }
     * })
     * 
    **/
    create<T extends invFlagsCreateArgs>(
      args: SelectSubset<T, invFlagsCreateArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Create many InvFlags.
     *     @param {invFlagsCreateManyArgs} args - Arguments to create many InvFlags.
     *     @example
     *     // Create many InvFlags
     *     const invFlags = await prisma.invFlags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invFlagsCreateManyArgs>(
      args?: SelectSubset<T, invFlagsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvFlags.
     * @param {invFlagsDeleteArgs} args - Arguments to delete one InvFlags.
     * @example
     * // Delete one InvFlags
     * const InvFlags = await prisma.invFlags.delete({
     *   where: {
     *     // ... filter to delete one InvFlags
     *   }
     * })
     * 
    **/
    delete<T extends invFlagsDeleteArgs>(
      args: SelectSubset<T, invFlagsDeleteArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Update one InvFlags.
     * @param {invFlagsUpdateArgs} args - Arguments to update one InvFlags.
     * @example
     * // Update one InvFlags
     * const invFlags = await prisma.invFlags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invFlagsUpdateArgs>(
      args: SelectSubset<T, invFlagsUpdateArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Delete zero or more InvFlags.
     * @param {invFlagsDeleteManyArgs} args - Arguments to filter InvFlags to delete.
     * @example
     * // Delete a few InvFlags
     * const { count } = await prisma.invFlags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invFlagsDeleteManyArgs>(
      args?: SelectSubset<T, invFlagsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvFlags
     * const invFlags = await prisma.invFlags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invFlagsUpdateManyArgs>(
      args: SelectSubset<T, invFlagsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvFlags.
     * @param {invFlagsUpsertArgs} args - Arguments to update or create a InvFlags.
     * @example
     * // Update or create a InvFlags
     * const invFlags = await prisma.invFlags.upsert({
     *   create: {
     *     // ... data to create a InvFlags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvFlags we want to update
     *   }
     * })
    **/
    upsert<T extends invFlagsUpsertArgs>(
      args: SelectSubset<T, invFlagsUpsertArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Find one InvFlags that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invFlagsFindUniqueOrThrowArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invFlagsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invFlagsFindUniqueOrThrowArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Find the first InvFlags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindFirstOrThrowArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invFlagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invFlagsFindFirstOrThrowArgs>
    ): Prisma__invFlagsClient<invFlagsGetPayload<T>>

    /**
     * Count the number of InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsCountArgs} args - Arguments to filter InvFlags to count.
     * @example
     * // Count the number of InvFlags
     * const count = await prisma.invFlags.count({
     *   where: {
     *     // ... the filter for the InvFlags we want to count
     *   }
     * })
    **/
    count<T extends invFlagsCountArgs>(
      args?: Subset<T, invFlagsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvFlagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvFlagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvFlagsAggregateArgs>(args: Subset<T, InvFlagsAggregateArgs>): PrismaPromise<GetInvFlagsAggregateType<T>>

    /**
     * Group by InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvFlagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvFlagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvFlagsGroupByArgs['orderBy'] }
        : { orderBy?: InvFlagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvFlagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvFlagsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invFlags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invFlagsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invFlags base type for findUnique actions
   */
  export type invFlagsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * Filter, which invFlags to fetch.
     * 
    **/
    where: invFlagsWhereUniqueInput
  }

  /**
   * invFlags: findUnique
   */
  export interface invFlagsFindUniqueArgs extends invFlagsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invFlags base type for findFirst actions
   */
  export type invFlagsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * Filter, which invFlags to fetch.
     * 
    **/
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     * 
    **/
    orderBy?: Enumerable<invFlagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invFlags.
     * 
    **/
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invFlags.
     * 
    **/
    distinct?: Enumerable<InvFlagsScalarFieldEnum>
  }

  /**
   * invFlags: findFirst
   */
  export interface invFlagsFindFirstArgs extends invFlagsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invFlags findMany
   */
  export type invFlagsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * Filter, which invFlags to fetch.
     * 
    **/
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     * 
    **/
    orderBy?: Enumerable<invFlagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invFlags.
     * 
    **/
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvFlagsScalarFieldEnum>
  }


  /**
   * invFlags create
   */
  export type invFlagsCreateArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * The data needed to create a invFlags.
     * 
    **/
    data: XOR<invFlagsCreateInput, invFlagsUncheckedCreateInput>
  }


  /**
   * invFlags createMany
   */
  export type invFlagsCreateManyArgs = {
    /**
     * The data used to create many invFlags.
     * 
    **/
    data: Enumerable<invFlagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invFlags update
   */
  export type invFlagsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * The data needed to update a invFlags.
     * 
    **/
    data: XOR<invFlagsUpdateInput, invFlagsUncheckedUpdateInput>
    /**
     * Choose, which invFlags to update.
     * 
    **/
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags updateMany
   */
  export type invFlagsUpdateManyArgs = {
    /**
     * The data used to update invFlags.
     * 
    **/
    data: XOR<invFlagsUpdateManyMutationInput, invFlagsUncheckedUpdateManyInput>
    /**
     * Filter which invFlags to update
     * 
    **/
    where?: invFlagsWhereInput
  }


  /**
   * invFlags upsert
   */
  export type invFlagsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * The filter to search for the invFlags to update in case it exists.
     * 
    **/
    where: invFlagsWhereUniqueInput
    /**
     * In case the invFlags found by the `where` argument doesn't exist, create a new invFlags with this data.
     * 
    **/
    create: XOR<invFlagsCreateInput, invFlagsUncheckedCreateInput>
    /**
     * In case the invFlags was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invFlagsUpdateInput, invFlagsUncheckedUpdateInput>
  }


  /**
   * invFlags delete
   */
  export type invFlagsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
    /**
     * Filter which invFlags to delete.
     * 
    **/
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags deleteMany
   */
  export type invFlagsDeleteManyArgs = {
    /**
     * Filter which invFlags to delete
     * 
    **/
    where?: invFlagsWhereInput
  }


  /**
   * invFlags: findUniqueOrThrow
   */
  export type invFlagsFindUniqueOrThrowArgs = invFlagsFindUniqueArgsBase
      

  /**
   * invFlags: findFirstOrThrow
   */
  export type invFlagsFindFirstOrThrowArgs = invFlagsFindFirstArgsBase
      

  /**
   * invFlags without action
   */
  export type invFlagsArgs = {
    /**
     * Select specific fields to fetch from the invFlags
     * 
    **/
    select?: invFlagsSelect | null
  }



  /**
   * Model invGroups
   */


  export type AggregateInvGroups = {
    _count: InvGroupsCountAggregateOutputType | null
    _avg: InvGroupsAvgAggregateOutputType | null
    _sum: InvGroupsSumAggregateOutputType | null
    _min: InvGroupsMinAggregateOutputType | null
    _max: InvGroupsMaxAggregateOutputType | null
  }

  export type InvGroupsAvgAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    iconID: number | null
  }

  export type InvGroupsSumAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    iconID: number | null
  }

  export type InvGroupsMinAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
  }

  export type InvGroupsMaxAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
  }

  export type InvGroupsCountAggregateOutputType = {
    groupID: number
    categoryID: number
    groupName: number
    iconID: number
    useBasePrice: number
    anchored: number
    anchorable: number
    fittableNonSingleton: number
    published: number
    _all: number
  }


  export type InvGroupsAvgAggregateInputType = {
    groupID?: true
    categoryID?: true
    iconID?: true
  }

  export type InvGroupsSumAggregateInputType = {
    groupID?: true
    categoryID?: true
    iconID?: true
  }

  export type InvGroupsMinAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
  }

  export type InvGroupsMaxAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
  }

  export type InvGroupsCountAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
    _all?: true
  }

  export type InvGroupsAggregateArgs = {
    /**
     * Filter which invGroups to aggregate.
     * 
    **/
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invGroups
    **/
    _count?: true | InvGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvGroupsMaxAggregateInputType
  }

  export type GetInvGroupsAggregateType<T extends InvGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvGroups[P]>
      : GetScalarType<T[P], AggregateInvGroups[P]>
  }




  export type InvGroupsGroupByArgs = {
    where?: invGroupsWhereInput
    orderBy?: Enumerable<invGroupsOrderByWithAggregationInput>
    by: Array<InvGroupsScalarFieldEnum>
    having?: invGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvGroupsCountAggregateInputType | true
    _avg?: InvGroupsAvgAggregateInputType
    _sum?: InvGroupsSumAggregateInputType
    _min?: InvGroupsMinAggregateInputType
    _max?: InvGroupsMaxAggregateInputType
  }


  export type InvGroupsGroupByOutputType = {
    groupID: number
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
    _count: InvGroupsCountAggregateOutputType | null
    _avg: InvGroupsAvgAggregateOutputType | null
    _sum: InvGroupsSumAggregateOutputType | null
    _min: InvGroupsMinAggregateOutputType | null
    _max: InvGroupsMaxAggregateOutputType | null
  }

  type GetInvGroupsGroupByPayload<T extends InvGroupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invGroupsSelect = {
    groupID?: boolean
    categoryID?: boolean
    groupName?: boolean
    iconID?: boolean
    useBasePrice?: boolean
    anchored?: boolean
    anchorable?: boolean
    fittableNonSingleton?: boolean
    published?: boolean
  }


  export type invGroupsGetPayload<S extends boolean | null | undefined | invGroupsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invGroups :
    S extends undefined ? never :
    S extends { include: any } & (invGroupsArgs | invGroupsFindManyArgs)
    ? invGroups 
    : S extends { select: any } & (invGroupsArgs | invGroupsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invGroups ? invGroups[P] : never
  } 
      : invGroups


  type invGroupsCountArgs = Merge<
    Omit<invGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvGroupsCountAggregateInputType | true
    }
  >

  export interface invGroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvGroups that matches the filter.
     * @param {invGroupsFindUniqueArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invGroups'> extends True ? Prisma__invGroupsClient<invGroupsGetPayload<T>> : Prisma__invGroupsClient<invGroupsGetPayload<T> | null, null>

    /**
     * Find the first InvGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindFirstArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invGroups'> extends True ? Prisma__invGroupsClient<invGroupsGetPayload<T>> : Prisma__invGroupsClient<invGroupsGetPayload<T> | null, null>

    /**
     * Find zero or more InvGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvGroups
     * const invGroups = await prisma.invGroups.findMany()
     * 
     * // Get first 10 InvGroups
     * const invGroups = await prisma.invGroups.findMany({ take: 10 })
     * 
     * // Only select the `groupID`
     * const invGroupsWithGroupIDOnly = await prisma.invGroups.findMany({ select: { groupID: true } })
     * 
    **/
    findMany<T extends invGroupsFindManyArgs>(
      args?: SelectSubset<T, invGroupsFindManyArgs>
    ): PrismaPromise<Array<invGroupsGetPayload<T>>>

    /**
     * Create a InvGroups.
     * @param {invGroupsCreateArgs} args - Arguments to create a InvGroups.
     * @example
     * // Create one InvGroups
     * const InvGroups = await prisma.invGroups.create({
     *   data: {
     *     // ... data to create a InvGroups
     *   }
     * })
     * 
    **/
    create<T extends invGroupsCreateArgs>(
      args: SelectSubset<T, invGroupsCreateArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Create many InvGroups.
     *     @param {invGroupsCreateManyArgs} args - Arguments to create many InvGroups.
     *     @example
     *     // Create many InvGroups
     *     const invGroups = await prisma.invGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invGroupsCreateManyArgs>(
      args?: SelectSubset<T, invGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvGroups.
     * @param {invGroupsDeleteArgs} args - Arguments to delete one InvGroups.
     * @example
     * // Delete one InvGroups
     * const InvGroups = await prisma.invGroups.delete({
     *   where: {
     *     // ... filter to delete one InvGroups
     *   }
     * })
     * 
    **/
    delete<T extends invGroupsDeleteArgs>(
      args: SelectSubset<T, invGroupsDeleteArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Update one InvGroups.
     * @param {invGroupsUpdateArgs} args - Arguments to update one InvGroups.
     * @example
     * // Update one InvGroups
     * const invGroups = await prisma.invGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invGroupsUpdateArgs>(
      args: SelectSubset<T, invGroupsUpdateArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Delete zero or more InvGroups.
     * @param {invGroupsDeleteManyArgs} args - Arguments to filter InvGroups to delete.
     * @example
     * // Delete a few InvGroups
     * const { count } = await prisma.invGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invGroupsDeleteManyArgs>(
      args?: SelectSubset<T, invGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvGroups
     * const invGroups = await prisma.invGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invGroupsUpdateManyArgs>(
      args: SelectSubset<T, invGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvGroups.
     * @param {invGroupsUpsertArgs} args - Arguments to update or create a InvGroups.
     * @example
     * // Update or create a InvGroups
     * const invGroups = await prisma.invGroups.upsert({
     *   create: {
     *     // ... data to create a InvGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invGroupsUpsertArgs>(
      args: SelectSubset<T, invGroupsUpsertArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Find one InvGroups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invGroupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invGroupsFindUniqueOrThrowArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Find the first InvGroups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindFirstOrThrowArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invGroupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invGroupsFindFirstOrThrowArgs>
    ): Prisma__invGroupsClient<invGroupsGetPayload<T>>

    /**
     * Count the number of InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsCountArgs} args - Arguments to filter InvGroups to count.
     * @example
     * // Count the number of InvGroups
     * const count = await prisma.invGroups.count({
     *   where: {
     *     // ... the filter for the InvGroups we want to count
     *   }
     * })
    **/
    count<T extends invGroupsCountArgs>(
      args?: Subset<T, invGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvGroupsAggregateArgs>(args: Subset<T, InvGroupsAggregateArgs>): PrismaPromise<GetInvGroupsAggregateType<T>>

    /**
     * Group by InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvGroupsGroupByArgs['orderBy'] }
        : { orderBy?: InvGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvGroupsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invGroupsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invGroups base type for findUnique actions
   */
  export type invGroupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * Filter, which invGroups to fetch.
     * 
    **/
    where: invGroupsWhereUniqueInput
  }

  /**
   * invGroups: findUnique
   */
  export interface invGroupsFindUniqueArgs extends invGroupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invGroups base type for findFirst actions
   */
  export type invGroupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * Filter, which invGroups to fetch.
     * 
    **/
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invGroups.
     * 
    **/
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invGroups.
     * 
    **/
    distinct?: Enumerable<InvGroupsScalarFieldEnum>
  }

  /**
   * invGroups: findFirst
   */
  export interface invGroupsFindFirstArgs extends invGroupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invGroups findMany
   */
  export type invGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * Filter, which invGroups to fetch.
     * 
    **/
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invGroups.
     * 
    **/
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvGroupsScalarFieldEnum>
  }


  /**
   * invGroups create
   */
  export type invGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * The data needed to create a invGroups.
     * 
    **/
    data: XOR<invGroupsCreateInput, invGroupsUncheckedCreateInput>
  }


  /**
   * invGroups createMany
   */
  export type invGroupsCreateManyArgs = {
    /**
     * The data used to create many invGroups.
     * 
    **/
    data: Enumerable<invGroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invGroups update
   */
  export type invGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * The data needed to update a invGroups.
     * 
    **/
    data: XOR<invGroupsUpdateInput, invGroupsUncheckedUpdateInput>
    /**
     * Choose, which invGroups to update.
     * 
    **/
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups updateMany
   */
  export type invGroupsUpdateManyArgs = {
    /**
     * The data used to update invGroups.
     * 
    **/
    data: XOR<invGroupsUpdateManyMutationInput, invGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invGroups to update
     * 
    **/
    where?: invGroupsWhereInput
  }


  /**
   * invGroups upsert
   */
  export type invGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * The filter to search for the invGroups to update in case it exists.
     * 
    **/
    where: invGroupsWhereUniqueInput
    /**
     * In case the invGroups found by the `where` argument doesn't exist, create a new invGroups with this data.
     * 
    **/
    create: XOR<invGroupsCreateInput, invGroupsUncheckedCreateInput>
    /**
     * In case the invGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invGroupsUpdateInput, invGroupsUncheckedUpdateInput>
  }


  /**
   * invGroups delete
   */
  export type invGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
    /**
     * Filter which invGroups to delete.
     * 
    **/
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups deleteMany
   */
  export type invGroupsDeleteManyArgs = {
    /**
     * Filter which invGroups to delete
     * 
    **/
    where?: invGroupsWhereInput
  }


  /**
   * invGroups: findUniqueOrThrow
   */
  export type invGroupsFindUniqueOrThrowArgs = invGroupsFindUniqueArgsBase
      

  /**
   * invGroups: findFirstOrThrow
   */
  export type invGroupsFindFirstOrThrowArgs = invGroupsFindFirstArgsBase
      

  /**
   * invGroups without action
   */
  export type invGroupsArgs = {
    /**
     * Select specific fields to fetch from the invGroups
     * 
    **/
    select?: invGroupsSelect | null
  }



  /**
   * Model invItems
   */


  export type AggregateInvItems = {
    _count: InvItemsCountAggregateOutputType | null
    _avg: InvItemsAvgAggregateOutputType | null
    _sum: InvItemsSumAggregateOutputType | null
    _min: InvItemsMinAggregateOutputType | null
    _max: InvItemsMaxAggregateOutputType | null
  }

  export type InvItemsAvgAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsSumAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsMinAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsMaxAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsCountAggregateOutputType = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
    _all: number
  }


  export type InvItemsAvgAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsSumAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsMinAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsMaxAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsCountAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
    _all?: true
  }

  export type InvItemsAggregateArgs = {
    /**
     * Filter which invItems to aggregate.
     * 
    **/
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     * 
    **/
    orderBy?: Enumerable<invItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invItems
    **/
    _count?: true | InvItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvItemsMaxAggregateInputType
  }

  export type GetInvItemsAggregateType<T extends InvItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvItems[P]>
      : GetScalarType<T[P], AggregateInvItems[P]>
  }




  export type InvItemsGroupByArgs = {
    where?: invItemsWhereInput
    orderBy?: Enumerable<invItemsOrderByWithAggregationInput>
    by: Array<InvItemsScalarFieldEnum>
    having?: invItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvItemsCountAggregateInputType | true
    _avg?: InvItemsAvgAggregateInputType
    _sum?: InvItemsSumAggregateInputType
    _min?: InvItemsMinAggregateInputType
    _max?: InvItemsMaxAggregateInputType
  }


  export type InvItemsGroupByOutputType = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
    _count: InvItemsCountAggregateOutputType | null
    _avg: InvItemsAvgAggregateOutputType | null
    _sum: InvItemsSumAggregateOutputType | null
    _min: InvItemsMinAggregateOutputType | null
    _max: InvItemsMaxAggregateOutputType | null
  }

  type GetInvItemsGroupByPayload<T extends InvItemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvItemsGroupByOutputType[P]>
            : GetScalarType<T[P], InvItemsGroupByOutputType[P]>
        }
      >
    >


  export type invItemsSelect = {
    itemID?: boolean
    typeID?: boolean
    ownerID?: boolean
    locationID?: boolean
    flagID?: boolean
    quantity?: boolean
  }


  export type invItemsGetPayload<S extends boolean | null | undefined | invItemsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invItems :
    S extends undefined ? never :
    S extends { include: any } & (invItemsArgs | invItemsFindManyArgs)
    ? invItems 
    : S extends { select: any } & (invItemsArgs | invItemsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invItems ? invItems[P] : never
  } 
      : invItems


  type invItemsCountArgs = Merge<
    Omit<invItemsFindManyArgs, 'select' | 'include'> & {
      select?: InvItemsCountAggregateInputType | true
    }
  >

  export interface invItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvItems that matches the filter.
     * @param {invItemsFindUniqueArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invItems'> extends True ? Prisma__invItemsClient<invItemsGetPayload<T>> : Prisma__invItemsClient<invItemsGetPayload<T> | null, null>

    /**
     * Find the first InvItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindFirstArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invItems'> extends True ? Prisma__invItemsClient<invItemsGetPayload<T>> : Prisma__invItemsClient<invItemsGetPayload<T> | null, null>

    /**
     * Find zero or more InvItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvItems
     * const invItems = await prisma.invItems.findMany()
     * 
     * // Get first 10 InvItems
     * const invItems = await prisma.invItems.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invItemsWithItemIDOnly = await prisma.invItems.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invItemsFindManyArgs>(
      args?: SelectSubset<T, invItemsFindManyArgs>
    ): PrismaPromise<Array<invItemsGetPayload<T>>>

    /**
     * Create a InvItems.
     * @param {invItemsCreateArgs} args - Arguments to create a InvItems.
     * @example
     * // Create one InvItems
     * const InvItems = await prisma.invItems.create({
     *   data: {
     *     // ... data to create a InvItems
     *   }
     * })
     * 
    **/
    create<T extends invItemsCreateArgs>(
      args: SelectSubset<T, invItemsCreateArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Create many InvItems.
     *     @param {invItemsCreateManyArgs} args - Arguments to create many InvItems.
     *     @example
     *     // Create many InvItems
     *     const invItems = await prisma.invItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invItemsCreateManyArgs>(
      args?: SelectSubset<T, invItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvItems.
     * @param {invItemsDeleteArgs} args - Arguments to delete one InvItems.
     * @example
     * // Delete one InvItems
     * const InvItems = await prisma.invItems.delete({
     *   where: {
     *     // ... filter to delete one InvItems
     *   }
     * })
     * 
    **/
    delete<T extends invItemsDeleteArgs>(
      args: SelectSubset<T, invItemsDeleteArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Update one InvItems.
     * @param {invItemsUpdateArgs} args - Arguments to update one InvItems.
     * @example
     * // Update one InvItems
     * const invItems = await prisma.invItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invItemsUpdateArgs>(
      args: SelectSubset<T, invItemsUpdateArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Delete zero or more InvItems.
     * @param {invItemsDeleteManyArgs} args - Arguments to filter InvItems to delete.
     * @example
     * // Delete a few InvItems
     * const { count } = await prisma.invItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invItemsDeleteManyArgs>(
      args?: SelectSubset<T, invItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvItems
     * const invItems = await prisma.invItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invItemsUpdateManyArgs>(
      args: SelectSubset<T, invItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvItems.
     * @param {invItemsUpsertArgs} args - Arguments to update or create a InvItems.
     * @example
     * // Update or create a InvItems
     * const invItems = await prisma.invItems.upsert({
     *   create: {
     *     // ... data to create a InvItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvItems we want to update
     *   }
     * })
    **/
    upsert<T extends invItemsUpsertArgs>(
      args: SelectSubset<T, invItemsUpsertArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Find one InvItems that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invItemsFindUniqueOrThrowArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invItemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invItemsFindUniqueOrThrowArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Find the first InvItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindFirstOrThrowArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invItemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invItemsFindFirstOrThrowArgs>
    ): Prisma__invItemsClient<invItemsGetPayload<T>>

    /**
     * Count the number of InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsCountArgs} args - Arguments to filter InvItems to count.
     * @example
     * // Count the number of InvItems
     * const count = await prisma.invItems.count({
     *   where: {
     *     // ... the filter for the InvItems we want to count
     *   }
     * })
    **/
    count<T extends invItemsCountArgs>(
      args?: Subset<T, invItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvItemsAggregateArgs>(args: Subset<T, InvItemsAggregateArgs>): PrismaPromise<GetInvItemsAggregateType<T>>

    /**
     * Group by InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvItemsGroupByArgs['orderBy'] }
        : { orderBy?: InvItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvItemsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invItemsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invItems base type for findUnique actions
   */
  export type invItemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * Filter, which invItems to fetch.
     * 
    **/
    where: invItemsWhereUniqueInput
  }

  /**
   * invItems: findUnique
   */
  export interface invItemsFindUniqueArgs extends invItemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invItems base type for findFirst actions
   */
  export type invItemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * Filter, which invItems to fetch.
     * 
    **/
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     * 
    **/
    orderBy?: Enumerable<invItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invItems.
     * 
    **/
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invItems.
     * 
    **/
    distinct?: Enumerable<InvItemsScalarFieldEnum>
  }

  /**
   * invItems: findFirst
   */
  export interface invItemsFindFirstArgs extends invItemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invItems findMany
   */
  export type invItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * Filter, which invItems to fetch.
     * 
    **/
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     * 
    **/
    orderBy?: Enumerable<invItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invItems.
     * 
    **/
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvItemsScalarFieldEnum>
  }


  /**
   * invItems create
   */
  export type invItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * The data needed to create a invItems.
     * 
    **/
    data: XOR<invItemsCreateInput, invItemsUncheckedCreateInput>
  }


  /**
   * invItems createMany
   */
  export type invItemsCreateManyArgs = {
    /**
     * The data used to create many invItems.
     * 
    **/
    data: Enumerable<invItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invItems update
   */
  export type invItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * The data needed to update a invItems.
     * 
    **/
    data: XOR<invItemsUpdateInput, invItemsUncheckedUpdateInput>
    /**
     * Choose, which invItems to update.
     * 
    **/
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems updateMany
   */
  export type invItemsUpdateManyArgs = {
    /**
     * The data used to update invItems.
     * 
    **/
    data: XOR<invItemsUpdateManyMutationInput, invItemsUncheckedUpdateManyInput>
    /**
     * Filter which invItems to update
     * 
    **/
    where?: invItemsWhereInput
  }


  /**
   * invItems upsert
   */
  export type invItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * The filter to search for the invItems to update in case it exists.
     * 
    **/
    where: invItemsWhereUniqueInput
    /**
     * In case the invItems found by the `where` argument doesn't exist, create a new invItems with this data.
     * 
    **/
    create: XOR<invItemsCreateInput, invItemsUncheckedCreateInput>
    /**
     * In case the invItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invItemsUpdateInput, invItemsUncheckedUpdateInput>
  }


  /**
   * invItems delete
   */
  export type invItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
    /**
     * Filter which invItems to delete.
     * 
    **/
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems deleteMany
   */
  export type invItemsDeleteManyArgs = {
    /**
     * Filter which invItems to delete
     * 
    **/
    where?: invItemsWhereInput
  }


  /**
   * invItems: findUniqueOrThrow
   */
  export type invItemsFindUniqueOrThrowArgs = invItemsFindUniqueArgsBase
      

  /**
   * invItems: findFirstOrThrow
   */
  export type invItemsFindFirstOrThrowArgs = invItemsFindFirstArgsBase
      

  /**
   * invItems without action
   */
  export type invItemsArgs = {
    /**
     * Select specific fields to fetch from the invItems
     * 
    **/
    select?: invItemsSelect | null
  }



  /**
   * Model invMarketGroups
   */


  export type AggregateInvMarketGroups = {
    _count: InvMarketGroupsCountAggregateOutputType | null
    _avg: InvMarketGroupsAvgAggregateOutputType | null
    _sum: InvMarketGroupsSumAggregateOutputType | null
    _min: InvMarketGroupsMinAggregateOutputType | null
    _max: InvMarketGroupsMaxAggregateOutputType | null
  }

  export type InvMarketGroupsAvgAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    iconID: number | null
  }

  export type InvMarketGroupsSumAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    iconID: number | null
  }

  export type InvMarketGroupsMinAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
  }

  export type InvMarketGroupsMaxAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
  }

  export type InvMarketGroupsCountAggregateOutputType = {
    marketGroupID: number
    parentGroupID: number
    marketGroupName: number
    description: number
    iconID: number
    hasTypes: number
    _all: number
  }


  export type InvMarketGroupsAvgAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    iconID?: true
  }

  export type InvMarketGroupsSumAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    iconID?: true
  }

  export type InvMarketGroupsMinAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
  }

  export type InvMarketGroupsMaxAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
  }

  export type InvMarketGroupsCountAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
    _all?: true
  }

  export type InvMarketGroupsAggregateArgs = {
    /**
     * Filter which invMarketGroups to aggregate.
     * 
    **/
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMarketGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMarketGroups
    **/
    _count?: true | InvMarketGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMarketGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMarketGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMarketGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMarketGroupsMaxAggregateInputType
  }

  export type GetInvMarketGroupsAggregateType<T extends InvMarketGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMarketGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMarketGroups[P]>
      : GetScalarType<T[P], AggregateInvMarketGroups[P]>
  }




  export type InvMarketGroupsGroupByArgs = {
    where?: invMarketGroupsWhereInput
    orderBy?: Enumerable<invMarketGroupsOrderByWithAggregationInput>
    by: Array<InvMarketGroupsScalarFieldEnum>
    having?: invMarketGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMarketGroupsCountAggregateInputType | true
    _avg?: InvMarketGroupsAvgAggregateInputType
    _sum?: InvMarketGroupsSumAggregateInputType
    _min?: InvMarketGroupsMinAggregateInputType
    _max?: InvMarketGroupsMaxAggregateInputType
  }


  export type InvMarketGroupsGroupByOutputType = {
    marketGroupID: number
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
    _count: InvMarketGroupsCountAggregateOutputType | null
    _avg: InvMarketGroupsAvgAggregateOutputType | null
    _sum: InvMarketGroupsSumAggregateOutputType | null
    _min: InvMarketGroupsMinAggregateOutputType | null
    _max: InvMarketGroupsMaxAggregateOutputType | null
  }

  type GetInvMarketGroupsGroupByPayload<T extends InvMarketGroupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvMarketGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMarketGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMarketGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvMarketGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invMarketGroupsSelect = {
    marketGroupID?: boolean
    parentGroupID?: boolean
    marketGroupName?: boolean
    description?: boolean
    iconID?: boolean
    hasTypes?: boolean
  }


  export type invMarketGroupsGetPayload<S extends boolean | null | undefined | invMarketGroupsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invMarketGroups :
    S extends undefined ? never :
    S extends { include: any } & (invMarketGroupsArgs | invMarketGroupsFindManyArgs)
    ? invMarketGroups 
    : S extends { select: any } & (invMarketGroupsArgs | invMarketGroupsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invMarketGroups ? invMarketGroups[P] : never
  } 
      : invMarketGroups


  type invMarketGroupsCountArgs = Merge<
    Omit<invMarketGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvMarketGroupsCountAggregateInputType | true
    }
  >

  export interface invMarketGroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvMarketGroups that matches the filter.
     * @param {invMarketGroupsFindUniqueArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMarketGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invMarketGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invMarketGroups'> extends True ? Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>> : Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T> | null, null>

    /**
     * Find the first InvMarketGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindFirstArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMarketGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invMarketGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invMarketGroups'> extends True ? Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>> : Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T> | null, null>

    /**
     * Find zero or more InvMarketGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findMany()
     * 
     * // Get first 10 InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findMany({ take: 10 })
     * 
     * // Only select the `marketGroupID`
     * const invMarketGroupsWithMarketGroupIDOnly = await prisma.invMarketGroups.findMany({ select: { marketGroupID: true } })
     * 
    **/
    findMany<T extends invMarketGroupsFindManyArgs>(
      args?: SelectSubset<T, invMarketGroupsFindManyArgs>
    ): PrismaPromise<Array<invMarketGroupsGetPayload<T>>>

    /**
     * Create a InvMarketGroups.
     * @param {invMarketGroupsCreateArgs} args - Arguments to create a InvMarketGroups.
     * @example
     * // Create one InvMarketGroups
     * const InvMarketGroups = await prisma.invMarketGroups.create({
     *   data: {
     *     // ... data to create a InvMarketGroups
     *   }
     * })
     * 
    **/
    create<T extends invMarketGroupsCreateArgs>(
      args: SelectSubset<T, invMarketGroupsCreateArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Create many InvMarketGroups.
     *     @param {invMarketGroupsCreateManyArgs} args - Arguments to create many InvMarketGroups.
     *     @example
     *     // Create many InvMarketGroups
     *     const invMarketGroups = await prisma.invMarketGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMarketGroupsCreateManyArgs>(
      args?: SelectSubset<T, invMarketGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvMarketGroups.
     * @param {invMarketGroupsDeleteArgs} args - Arguments to delete one InvMarketGroups.
     * @example
     * // Delete one InvMarketGroups
     * const InvMarketGroups = await prisma.invMarketGroups.delete({
     *   where: {
     *     // ... filter to delete one InvMarketGroups
     *   }
     * })
     * 
    **/
    delete<T extends invMarketGroupsDeleteArgs>(
      args: SelectSubset<T, invMarketGroupsDeleteArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Update one InvMarketGroups.
     * @param {invMarketGroupsUpdateArgs} args - Arguments to update one InvMarketGroups.
     * @example
     * // Update one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMarketGroupsUpdateArgs>(
      args: SelectSubset<T, invMarketGroupsUpdateArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Delete zero or more InvMarketGroups.
     * @param {invMarketGroupsDeleteManyArgs} args - Arguments to filter InvMarketGroups to delete.
     * @example
     * // Delete a few InvMarketGroups
     * const { count } = await prisma.invMarketGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMarketGroupsDeleteManyArgs>(
      args?: SelectSubset<T, invMarketGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMarketGroupsUpdateManyArgs>(
      args: SelectSubset<T, invMarketGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMarketGroups.
     * @param {invMarketGroupsUpsertArgs} args - Arguments to update or create a InvMarketGroups.
     * @example
     * // Update or create a InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.upsert({
     *   create: {
     *     // ... data to create a InvMarketGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMarketGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invMarketGroupsUpsertArgs>(
      args: SelectSubset<T, invMarketGroupsUpsertArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Find one InvMarketGroups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invMarketGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMarketGroupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invMarketGroupsFindUniqueOrThrowArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Find the first InvMarketGroups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindFirstOrThrowArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMarketGroupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invMarketGroupsFindFirstOrThrowArgs>
    ): Prisma__invMarketGroupsClient<invMarketGroupsGetPayload<T>>

    /**
     * Count the number of InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsCountArgs} args - Arguments to filter InvMarketGroups to count.
     * @example
     * // Count the number of InvMarketGroups
     * const count = await prisma.invMarketGroups.count({
     *   where: {
     *     // ... the filter for the InvMarketGroups we want to count
     *   }
     * })
    **/
    count<T extends invMarketGroupsCountArgs>(
      args?: Subset<T, invMarketGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMarketGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMarketGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMarketGroupsAggregateArgs>(args: Subset<T, InvMarketGroupsAggregateArgs>): PrismaPromise<GetInvMarketGroupsAggregateType<T>>

    /**
     * Group by InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMarketGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvMarketGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvMarketGroupsGroupByArgs['orderBy'] }
        : { orderBy?: InvMarketGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvMarketGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMarketGroupsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invMarketGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invMarketGroupsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invMarketGroups base type for findUnique actions
   */
  export type invMarketGroupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * Filter, which invMarketGroups to fetch.
     * 
    **/
    where: invMarketGroupsWhereUniqueInput
  }

  /**
   * invMarketGroups: findUnique
   */
  export interface invMarketGroupsFindUniqueArgs extends invMarketGroupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMarketGroups base type for findFirst actions
   */
  export type invMarketGroupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * Filter, which invMarketGroups to fetch.
     * 
    **/
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMarketGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMarketGroups.
     * 
    **/
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMarketGroups.
     * 
    **/
    distinct?: Enumerable<InvMarketGroupsScalarFieldEnum>
  }

  /**
   * invMarketGroups: findFirst
   */
  export interface invMarketGroupsFindFirstArgs extends invMarketGroupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMarketGroups findMany
   */
  export type invMarketGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * Filter, which invMarketGroups to fetch.
     * 
    **/
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMarketGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMarketGroups.
     * 
    **/
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvMarketGroupsScalarFieldEnum>
  }


  /**
   * invMarketGroups create
   */
  export type invMarketGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * The data needed to create a invMarketGroups.
     * 
    **/
    data: XOR<invMarketGroupsCreateInput, invMarketGroupsUncheckedCreateInput>
  }


  /**
   * invMarketGroups createMany
   */
  export type invMarketGroupsCreateManyArgs = {
    /**
     * The data used to create many invMarketGroups.
     * 
    **/
    data: Enumerable<invMarketGroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invMarketGroups update
   */
  export type invMarketGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * The data needed to update a invMarketGroups.
     * 
    **/
    data: XOR<invMarketGroupsUpdateInput, invMarketGroupsUncheckedUpdateInput>
    /**
     * Choose, which invMarketGroups to update.
     * 
    **/
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups updateMany
   */
  export type invMarketGroupsUpdateManyArgs = {
    /**
     * The data used to update invMarketGroups.
     * 
    **/
    data: XOR<invMarketGroupsUpdateManyMutationInput, invMarketGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invMarketGroups to update
     * 
    **/
    where?: invMarketGroupsWhereInput
  }


  /**
   * invMarketGroups upsert
   */
  export type invMarketGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * The filter to search for the invMarketGroups to update in case it exists.
     * 
    **/
    where: invMarketGroupsWhereUniqueInput
    /**
     * In case the invMarketGroups found by the `where` argument doesn't exist, create a new invMarketGroups with this data.
     * 
    **/
    create: XOR<invMarketGroupsCreateInput, invMarketGroupsUncheckedCreateInput>
    /**
     * In case the invMarketGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invMarketGroupsUpdateInput, invMarketGroupsUncheckedUpdateInput>
  }


  /**
   * invMarketGroups delete
   */
  export type invMarketGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
    /**
     * Filter which invMarketGroups to delete.
     * 
    **/
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups deleteMany
   */
  export type invMarketGroupsDeleteManyArgs = {
    /**
     * Filter which invMarketGroups to delete
     * 
    **/
    where?: invMarketGroupsWhereInput
  }


  /**
   * invMarketGroups: findUniqueOrThrow
   */
  export type invMarketGroupsFindUniqueOrThrowArgs = invMarketGroupsFindUniqueArgsBase
      

  /**
   * invMarketGroups: findFirstOrThrow
   */
  export type invMarketGroupsFindFirstOrThrowArgs = invMarketGroupsFindFirstArgsBase
      

  /**
   * invMarketGroups without action
   */
  export type invMarketGroupsArgs = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     * 
    **/
    select?: invMarketGroupsSelect | null
  }



  /**
   * Model invMetaGroups
   */


  export type AggregateInvMetaGroups = {
    _count: InvMetaGroupsCountAggregateOutputType | null
    _avg: InvMetaGroupsAvgAggregateOutputType | null
    _sum: InvMetaGroupsSumAggregateOutputType | null
    _min: InvMetaGroupsMinAggregateOutputType | null
    _max: InvMetaGroupsMaxAggregateOutputType | null
  }

  export type InvMetaGroupsAvgAggregateOutputType = {
    metaGroupID: number | null
    iconID: number | null
  }

  export type InvMetaGroupsSumAggregateOutputType = {
    metaGroupID: number | null
    iconID: number | null
  }

  export type InvMetaGroupsMinAggregateOutputType = {
    metaGroupID: number | null
    metaGroupName: string | null
    description: string | null
    iconID: number | null
  }

  export type InvMetaGroupsMaxAggregateOutputType = {
    metaGroupID: number | null
    metaGroupName: string | null
    description: string | null
    iconID: number | null
  }

  export type InvMetaGroupsCountAggregateOutputType = {
    metaGroupID: number
    metaGroupName: number
    description: number
    iconID: number
    _all: number
  }


  export type InvMetaGroupsAvgAggregateInputType = {
    metaGroupID?: true
    iconID?: true
  }

  export type InvMetaGroupsSumAggregateInputType = {
    metaGroupID?: true
    iconID?: true
  }

  export type InvMetaGroupsMinAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
  }

  export type InvMetaGroupsMaxAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
  }

  export type InvMetaGroupsCountAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
    _all?: true
  }

  export type InvMetaGroupsAggregateArgs = {
    /**
     * Filter which invMetaGroups to aggregate.
     * 
    **/
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMetaGroups
    **/
    _count?: true | InvMetaGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMetaGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMetaGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMetaGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMetaGroupsMaxAggregateInputType
  }

  export type GetInvMetaGroupsAggregateType<T extends InvMetaGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMetaGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMetaGroups[P]>
      : GetScalarType<T[P], AggregateInvMetaGroups[P]>
  }




  export type InvMetaGroupsGroupByArgs = {
    where?: invMetaGroupsWhereInput
    orderBy?: Enumerable<invMetaGroupsOrderByWithAggregationInput>
    by: Array<InvMetaGroupsScalarFieldEnum>
    having?: invMetaGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMetaGroupsCountAggregateInputType | true
    _avg?: InvMetaGroupsAvgAggregateInputType
    _sum?: InvMetaGroupsSumAggregateInputType
    _min?: InvMetaGroupsMinAggregateInputType
    _max?: InvMetaGroupsMaxAggregateInputType
  }


  export type InvMetaGroupsGroupByOutputType = {
    metaGroupID: number
    metaGroupName: string | null
    description: string | null
    iconID: number | null
    _count: InvMetaGroupsCountAggregateOutputType | null
    _avg: InvMetaGroupsAvgAggregateOutputType | null
    _sum: InvMetaGroupsSumAggregateOutputType | null
    _min: InvMetaGroupsMinAggregateOutputType | null
    _max: InvMetaGroupsMaxAggregateOutputType | null
  }

  type GetInvMetaGroupsGroupByPayload<T extends InvMetaGroupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvMetaGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMetaGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMetaGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvMetaGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invMetaGroupsSelect = {
    metaGroupID?: boolean
    metaGroupName?: boolean
    description?: boolean
    iconID?: boolean
  }


  export type invMetaGroupsGetPayload<S extends boolean | null | undefined | invMetaGroupsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invMetaGroups :
    S extends undefined ? never :
    S extends { include: any } & (invMetaGroupsArgs | invMetaGroupsFindManyArgs)
    ? invMetaGroups 
    : S extends { select: any } & (invMetaGroupsArgs | invMetaGroupsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invMetaGroups ? invMetaGroups[P] : never
  } 
      : invMetaGroups


  type invMetaGroupsCountArgs = Merge<
    Omit<invMetaGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvMetaGroupsCountAggregateInputType | true
    }
  >

  export interface invMetaGroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvMetaGroups that matches the filter.
     * @param {invMetaGroupsFindUniqueArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMetaGroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invMetaGroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invMetaGroups'> extends True ? Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>> : Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T> | null, null>

    /**
     * Find the first InvMetaGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindFirstArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMetaGroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invMetaGroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invMetaGroups'> extends True ? Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>> : Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T> | null, null>

    /**
     * Find zero or more InvMetaGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findMany()
     * 
     * // Get first 10 InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findMany({ take: 10 })
     * 
     * // Only select the `metaGroupID`
     * const invMetaGroupsWithMetaGroupIDOnly = await prisma.invMetaGroups.findMany({ select: { metaGroupID: true } })
     * 
    **/
    findMany<T extends invMetaGroupsFindManyArgs>(
      args?: SelectSubset<T, invMetaGroupsFindManyArgs>
    ): PrismaPromise<Array<invMetaGroupsGetPayload<T>>>

    /**
     * Create a InvMetaGroups.
     * @param {invMetaGroupsCreateArgs} args - Arguments to create a InvMetaGroups.
     * @example
     * // Create one InvMetaGroups
     * const InvMetaGroups = await prisma.invMetaGroups.create({
     *   data: {
     *     // ... data to create a InvMetaGroups
     *   }
     * })
     * 
    **/
    create<T extends invMetaGroupsCreateArgs>(
      args: SelectSubset<T, invMetaGroupsCreateArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Create many InvMetaGroups.
     *     @param {invMetaGroupsCreateManyArgs} args - Arguments to create many InvMetaGroups.
     *     @example
     *     // Create many InvMetaGroups
     *     const invMetaGroups = await prisma.invMetaGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMetaGroupsCreateManyArgs>(
      args?: SelectSubset<T, invMetaGroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvMetaGroups.
     * @param {invMetaGroupsDeleteArgs} args - Arguments to delete one InvMetaGroups.
     * @example
     * // Delete one InvMetaGroups
     * const InvMetaGroups = await prisma.invMetaGroups.delete({
     *   where: {
     *     // ... filter to delete one InvMetaGroups
     *   }
     * })
     * 
    **/
    delete<T extends invMetaGroupsDeleteArgs>(
      args: SelectSubset<T, invMetaGroupsDeleteArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Update one InvMetaGroups.
     * @param {invMetaGroupsUpdateArgs} args - Arguments to update one InvMetaGroups.
     * @example
     * // Update one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMetaGroupsUpdateArgs>(
      args: SelectSubset<T, invMetaGroupsUpdateArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Delete zero or more InvMetaGroups.
     * @param {invMetaGroupsDeleteManyArgs} args - Arguments to filter InvMetaGroups to delete.
     * @example
     * // Delete a few InvMetaGroups
     * const { count } = await prisma.invMetaGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMetaGroupsDeleteManyArgs>(
      args?: SelectSubset<T, invMetaGroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMetaGroupsUpdateManyArgs>(
      args: SelectSubset<T, invMetaGroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMetaGroups.
     * @param {invMetaGroupsUpsertArgs} args - Arguments to update or create a InvMetaGroups.
     * @example
     * // Update or create a InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.upsert({
     *   create: {
     *     // ... data to create a InvMetaGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMetaGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invMetaGroupsUpsertArgs>(
      args: SelectSubset<T, invMetaGroupsUpsertArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Find one InvMetaGroups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invMetaGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMetaGroupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invMetaGroupsFindUniqueOrThrowArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Find the first InvMetaGroups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindFirstOrThrowArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMetaGroupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invMetaGroupsFindFirstOrThrowArgs>
    ): Prisma__invMetaGroupsClient<invMetaGroupsGetPayload<T>>

    /**
     * Count the number of InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsCountArgs} args - Arguments to filter InvMetaGroups to count.
     * @example
     * // Count the number of InvMetaGroups
     * const count = await prisma.invMetaGroups.count({
     *   where: {
     *     // ... the filter for the InvMetaGroups we want to count
     *   }
     * })
    **/
    count<T extends invMetaGroupsCountArgs>(
      args?: Subset<T, invMetaGroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMetaGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMetaGroupsAggregateArgs>(args: Subset<T, InvMetaGroupsAggregateArgs>): PrismaPromise<GetInvMetaGroupsAggregateType<T>>

    /**
     * Group by InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvMetaGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvMetaGroupsGroupByArgs['orderBy'] }
        : { orderBy?: InvMetaGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvMetaGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMetaGroupsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invMetaGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invMetaGroupsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invMetaGroups base type for findUnique actions
   */
  export type invMetaGroupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * Filter, which invMetaGroups to fetch.
     * 
    **/
    where: invMetaGroupsWhereUniqueInput
  }

  /**
   * invMetaGroups: findUnique
   */
  export interface invMetaGroupsFindUniqueArgs extends invMetaGroupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMetaGroups base type for findFirst actions
   */
  export type invMetaGroupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * Filter, which invMetaGroups to fetch.
     * 
    **/
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaGroups.
     * 
    **/
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaGroups.
     * 
    **/
    distinct?: Enumerable<InvMetaGroupsScalarFieldEnum>
  }

  /**
   * invMetaGroups: findFirst
   */
  export interface invMetaGroupsFindFirstArgs extends invMetaGroupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMetaGroups findMany
   */
  export type invMetaGroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * Filter, which invMetaGroups to fetch.
     * 
    **/
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaGroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMetaGroups.
     * 
    **/
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvMetaGroupsScalarFieldEnum>
  }


  /**
   * invMetaGroups create
   */
  export type invMetaGroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * The data needed to create a invMetaGroups.
     * 
    **/
    data: XOR<invMetaGroupsCreateInput, invMetaGroupsUncheckedCreateInput>
  }


  /**
   * invMetaGroups createMany
   */
  export type invMetaGroupsCreateManyArgs = {
    /**
     * The data used to create many invMetaGroups.
     * 
    **/
    data: Enumerable<invMetaGroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invMetaGroups update
   */
  export type invMetaGroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * The data needed to update a invMetaGroups.
     * 
    **/
    data: XOR<invMetaGroupsUpdateInput, invMetaGroupsUncheckedUpdateInput>
    /**
     * Choose, which invMetaGroups to update.
     * 
    **/
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups updateMany
   */
  export type invMetaGroupsUpdateManyArgs = {
    /**
     * The data used to update invMetaGroups.
     * 
    **/
    data: XOR<invMetaGroupsUpdateManyMutationInput, invMetaGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invMetaGroups to update
     * 
    **/
    where?: invMetaGroupsWhereInput
  }


  /**
   * invMetaGroups upsert
   */
  export type invMetaGroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * The filter to search for the invMetaGroups to update in case it exists.
     * 
    **/
    where: invMetaGroupsWhereUniqueInput
    /**
     * In case the invMetaGroups found by the `where` argument doesn't exist, create a new invMetaGroups with this data.
     * 
    **/
    create: XOR<invMetaGroupsCreateInput, invMetaGroupsUncheckedCreateInput>
    /**
     * In case the invMetaGroups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invMetaGroupsUpdateInput, invMetaGroupsUncheckedUpdateInput>
  }


  /**
   * invMetaGroups delete
   */
  export type invMetaGroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
    /**
     * Filter which invMetaGroups to delete.
     * 
    **/
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups deleteMany
   */
  export type invMetaGroupsDeleteManyArgs = {
    /**
     * Filter which invMetaGroups to delete
     * 
    **/
    where?: invMetaGroupsWhereInput
  }


  /**
   * invMetaGroups: findUniqueOrThrow
   */
  export type invMetaGroupsFindUniqueOrThrowArgs = invMetaGroupsFindUniqueArgsBase
      

  /**
   * invMetaGroups: findFirstOrThrow
   */
  export type invMetaGroupsFindFirstOrThrowArgs = invMetaGroupsFindFirstArgsBase
      

  /**
   * invMetaGroups without action
   */
  export type invMetaGroupsArgs = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     * 
    **/
    select?: invMetaGroupsSelect | null
  }



  /**
   * Model invMetaTypes
   */


  export type AggregateInvMetaTypes = {
    _count: InvMetaTypesCountAggregateOutputType | null
    _avg: InvMetaTypesAvgAggregateOutputType | null
    _sum: InvMetaTypesSumAggregateOutputType | null
    _min: InvMetaTypesMinAggregateOutputType | null
    _max: InvMetaTypesMaxAggregateOutputType | null
  }

  export type InvMetaTypesAvgAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesSumAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesMinAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesMaxAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesCountAggregateOutputType = {
    typeID: number
    parentTypeID: number
    metaGroupID: number
    _all: number
  }


  export type InvMetaTypesAvgAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesSumAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesMinAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesMaxAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesCountAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
    _all?: true
  }

  export type InvMetaTypesAggregateArgs = {
    /**
     * Filter which invMetaTypes to aggregate.
     * 
    **/
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMetaTypes
    **/
    _count?: true | InvMetaTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMetaTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMetaTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMetaTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMetaTypesMaxAggregateInputType
  }

  export type GetInvMetaTypesAggregateType<T extends InvMetaTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMetaTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMetaTypes[P]>
      : GetScalarType<T[P], AggregateInvMetaTypes[P]>
  }




  export type InvMetaTypesGroupByArgs = {
    where?: invMetaTypesWhereInput
    orderBy?: Enumerable<invMetaTypesOrderByWithAggregationInput>
    by: Array<InvMetaTypesScalarFieldEnum>
    having?: invMetaTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMetaTypesCountAggregateInputType | true
    _avg?: InvMetaTypesAvgAggregateInputType
    _sum?: InvMetaTypesSumAggregateInputType
    _min?: InvMetaTypesMinAggregateInputType
    _max?: InvMetaTypesMaxAggregateInputType
  }


  export type InvMetaTypesGroupByOutputType = {
    typeID: number
    parentTypeID: number | null
    metaGroupID: number | null
    _count: InvMetaTypesCountAggregateOutputType | null
    _avg: InvMetaTypesAvgAggregateOutputType | null
    _sum: InvMetaTypesSumAggregateOutputType | null
    _min: InvMetaTypesMinAggregateOutputType | null
    _max: InvMetaTypesMaxAggregateOutputType | null
  }

  type GetInvMetaTypesGroupByPayload<T extends InvMetaTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvMetaTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMetaTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMetaTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvMetaTypesGroupByOutputType[P]>
        }
      >
    >


  export type invMetaTypesSelect = {
    typeID?: boolean
    parentTypeID?: boolean
    metaGroupID?: boolean
  }


  export type invMetaTypesGetPayload<S extends boolean | null | undefined | invMetaTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invMetaTypes :
    S extends undefined ? never :
    S extends { include: any } & (invMetaTypesArgs | invMetaTypesFindManyArgs)
    ? invMetaTypes 
    : S extends { select: any } & (invMetaTypesArgs | invMetaTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invMetaTypes ? invMetaTypes[P] : never
  } 
      : invMetaTypes


  type invMetaTypesCountArgs = Merge<
    Omit<invMetaTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvMetaTypesCountAggregateInputType | true
    }
  >

  export interface invMetaTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvMetaTypes that matches the filter.
     * @param {invMetaTypesFindUniqueArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMetaTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invMetaTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invMetaTypes'> extends True ? Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>> : Prisma__invMetaTypesClient<invMetaTypesGetPayload<T> | null, null>

    /**
     * Find the first InvMetaTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindFirstArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMetaTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invMetaTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invMetaTypes'> extends True ? Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>> : Prisma__invMetaTypesClient<invMetaTypesGetPayload<T> | null, null>

    /**
     * Find zero or more InvMetaTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findMany()
     * 
     * // Get first 10 InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invMetaTypesWithTypeIDOnly = await prisma.invMetaTypes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invMetaTypesFindManyArgs>(
      args?: SelectSubset<T, invMetaTypesFindManyArgs>
    ): PrismaPromise<Array<invMetaTypesGetPayload<T>>>

    /**
     * Create a InvMetaTypes.
     * @param {invMetaTypesCreateArgs} args - Arguments to create a InvMetaTypes.
     * @example
     * // Create one InvMetaTypes
     * const InvMetaTypes = await prisma.invMetaTypes.create({
     *   data: {
     *     // ... data to create a InvMetaTypes
     *   }
     * })
     * 
    **/
    create<T extends invMetaTypesCreateArgs>(
      args: SelectSubset<T, invMetaTypesCreateArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Create many InvMetaTypes.
     *     @param {invMetaTypesCreateManyArgs} args - Arguments to create many InvMetaTypes.
     *     @example
     *     // Create many InvMetaTypes
     *     const invMetaTypes = await prisma.invMetaTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMetaTypesCreateManyArgs>(
      args?: SelectSubset<T, invMetaTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvMetaTypes.
     * @param {invMetaTypesDeleteArgs} args - Arguments to delete one InvMetaTypes.
     * @example
     * // Delete one InvMetaTypes
     * const InvMetaTypes = await prisma.invMetaTypes.delete({
     *   where: {
     *     // ... filter to delete one InvMetaTypes
     *   }
     * })
     * 
    **/
    delete<T extends invMetaTypesDeleteArgs>(
      args: SelectSubset<T, invMetaTypesDeleteArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Update one InvMetaTypes.
     * @param {invMetaTypesUpdateArgs} args - Arguments to update one InvMetaTypes.
     * @example
     * // Update one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMetaTypesUpdateArgs>(
      args: SelectSubset<T, invMetaTypesUpdateArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Delete zero or more InvMetaTypes.
     * @param {invMetaTypesDeleteManyArgs} args - Arguments to filter InvMetaTypes to delete.
     * @example
     * // Delete a few InvMetaTypes
     * const { count } = await prisma.invMetaTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMetaTypesDeleteManyArgs>(
      args?: SelectSubset<T, invMetaTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMetaTypesUpdateManyArgs>(
      args: SelectSubset<T, invMetaTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMetaTypes.
     * @param {invMetaTypesUpsertArgs} args - Arguments to update or create a InvMetaTypes.
     * @example
     * // Update or create a InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.upsert({
     *   create: {
     *     // ... data to create a InvMetaTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMetaTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invMetaTypesUpsertArgs>(
      args: SelectSubset<T, invMetaTypesUpsertArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Find one InvMetaTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invMetaTypesFindUniqueOrThrowArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMetaTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invMetaTypesFindUniqueOrThrowArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Find the first InvMetaTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindFirstOrThrowArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMetaTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invMetaTypesFindFirstOrThrowArgs>
    ): Prisma__invMetaTypesClient<invMetaTypesGetPayload<T>>

    /**
     * Count the number of InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesCountArgs} args - Arguments to filter InvMetaTypes to count.
     * @example
     * // Count the number of InvMetaTypes
     * const count = await prisma.invMetaTypes.count({
     *   where: {
     *     // ... the filter for the InvMetaTypes we want to count
     *   }
     * })
    **/
    count<T extends invMetaTypesCountArgs>(
      args?: Subset<T, invMetaTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMetaTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMetaTypesAggregateArgs>(args: Subset<T, InvMetaTypesAggregateArgs>): PrismaPromise<GetInvMetaTypesAggregateType<T>>

    /**
     * Group by InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvMetaTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvMetaTypesGroupByArgs['orderBy'] }
        : { orderBy?: InvMetaTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvMetaTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMetaTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invMetaTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invMetaTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invMetaTypes base type for findUnique actions
   */
  export type invMetaTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * Filter, which invMetaTypes to fetch.
     * 
    **/
    where: invMetaTypesWhereUniqueInput
  }

  /**
   * invMetaTypes: findUnique
   */
  export interface invMetaTypesFindUniqueArgs extends invMetaTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMetaTypes base type for findFirst actions
   */
  export type invMetaTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * Filter, which invMetaTypes to fetch.
     * 
    **/
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaTypes.
     * 
    **/
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaTypes.
     * 
    **/
    distinct?: Enumerable<InvMetaTypesScalarFieldEnum>
  }

  /**
   * invMetaTypes: findFirst
   */
  export interface invMetaTypesFindFirstArgs extends invMetaTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invMetaTypes findMany
   */
  export type invMetaTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * Filter, which invMetaTypes to fetch.
     * 
    **/
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invMetaTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMetaTypes.
     * 
    **/
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvMetaTypesScalarFieldEnum>
  }


  /**
   * invMetaTypes create
   */
  export type invMetaTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * The data needed to create a invMetaTypes.
     * 
    **/
    data: XOR<invMetaTypesCreateInput, invMetaTypesUncheckedCreateInput>
  }


  /**
   * invMetaTypes createMany
   */
  export type invMetaTypesCreateManyArgs = {
    /**
     * The data used to create many invMetaTypes.
     * 
    **/
    data: Enumerable<invMetaTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invMetaTypes update
   */
  export type invMetaTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * The data needed to update a invMetaTypes.
     * 
    **/
    data: XOR<invMetaTypesUpdateInput, invMetaTypesUncheckedUpdateInput>
    /**
     * Choose, which invMetaTypes to update.
     * 
    **/
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes updateMany
   */
  export type invMetaTypesUpdateManyArgs = {
    /**
     * The data used to update invMetaTypes.
     * 
    **/
    data: XOR<invMetaTypesUpdateManyMutationInput, invMetaTypesUncheckedUpdateManyInput>
    /**
     * Filter which invMetaTypes to update
     * 
    **/
    where?: invMetaTypesWhereInput
  }


  /**
   * invMetaTypes upsert
   */
  export type invMetaTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * The filter to search for the invMetaTypes to update in case it exists.
     * 
    **/
    where: invMetaTypesWhereUniqueInput
    /**
     * In case the invMetaTypes found by the `where` argument doesn't exist, create a new invMetaTypes with this data.
     * 
    **/
    create: XOR<invMetaTypesCreateInput, invMetaTypesUncheckedCreateInput>
    /**
     * In case the invMetaTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invMetaTypesUpdateInput, invMetaTypesUncheckedUpdateInput>
  }


  /**
   * invMetaTypes delete
   */
  export type invMetaTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
    /**
     * Filter which invMetaTypes to delete.
     * 
    **/
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes deleteMany
   */
  export type invMetaTypesDeleteManyArgs = {
    /**
     * Filter which invMetaTypes to delete
     * 
    **/
    where?: invMetaTypesWhereInput
  }


  /**
   * invMetaTypes: findUniqueOrThrow
   */
  export type invMetaTypesFindUniqueOrThrowArgs = invMetaTypesFindUniqueArgsBase
      

  /**
   * invMetaTypes: findFirstOrThrow
   */
  export type invMetaTypesFindFirstOrThrowArgs = invMetaTypesFindFirstArgsBase
      

  /**
   * invMetaTypes without action
   */
  export type invMetaTypesArgs = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     * 
    **/
    select?: invMetaTypesSelect | null
  }



  /**
   * Model invNames
   */


  export type AggregateInvNames = {
    _count: InvNamesCountAggregateOutputType | null
    _avg: InvNamesAvgAggregateOutputType | null
    _sum: InvNamesSumAggregateOutputType | null
    _min: InvNamesMinAggregateOutputType | null
    _max: InvNamesMaxAggregateOutputType | null
  }

  export type InvNamesAvgAggregateOutputType = {
    itemID: number | null
  }

  export type InvNamesSumAggregateOutputType = {
    itemID: number | null
  }

  export type InvNamesMinAggregateOutputType = {
    itemID: number | null
    itemName: string | null
  }

  export type InvNamesMaxAggregateOutputType = {
    itemID: number | null
    itemName: string | null
  }

  export type InvNamesCountAggregateOutputType = {
    itemID: number
    itemName: number
    _all: number
  }


  export type InvNamesAvgAggregateInputType = {
    itemID?: true
  }

  export type InvNamesSumAggregateInputType = {
    itemID?: true
  }

  export type InvNamesMinAggregateInputType = {
    itemID?: true
    itemName?: true
  }

  export type InvNamesMaxAggregateInputType = {
    itemID?: true
    itemName?: true
  }

  export type InvNamesCountAggregateInputType = {
    itemID?: true
    itemName?: true
    _all?: true
  }

  export type InvNamesAggregateArgs = {
    /**
     * Filter which invNames to aggregate.
     * 
    **/
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invNames
    **/
    _count?: true | InvNamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvNamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvNamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvNamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvNamesMaxAggregateInputType
  }

  export type GetInvNamesAggregateType<T extends InvNamesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvNames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvNames[P]>
      : GetScalarType<T[P], AggregateInvNames[P]>
  }




  export type InvNamesGroupByArgs = {
    where?: invNamesWhereInput
    orderBy?: Enumerable<invNamesOrderByWithAggregationInput>
    by: Array<InvNamesScalarFieldEnum>
    having?: invNamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvNamesCountAggregateInputType | true
    _avg?: InvNamesAvgAggregateInputType
    _sum?: InvNamesSumAggregateInputType
    _min?: InvNamesMinAggregateInputType
    _max?: InvNamesMaxAggregateInputType
  }


  export type InvNamesGroupByOutputType = {
    itemID: number
    itemName: string
    _count: InvNamesCountAggregateOutputType | null
    _avg: InvNamesAvgAggregateOutputType | null
    _sum: InvNamesSumAggregateOutputType | null
    _min: InvNamesMinAggregateOutputType | null
    _max: InvNamesMaxAggregateOutputType | null
  }

  type GetInvNamesGroupByPayload<T extends InvNamesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvNamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvNamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvNamesGroupByOutputType[P]>
            : GetScalarType<T[P], InvNamesGroupByOutputType[P]>
        }
      >
    >


  export type invNamesSelect = {
    itemID?: boolean
    itemName?: boolean
  }


  export type invNamesGetPayload<S extends boolean | null | undefined | invNamesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invNames :
    S extends undefined ? never :
    S extends { include: any } & (invNamesArgs | invNamesFindManyArgs)
    ? invNames 
    : S extends { select: any } & (invNamesArgs | invNamesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invNames ? invNames[P] : never
  } 
      : invNames


  type invNamesCountArgs = Merge<
    Omit<invNamesFindManyArgs, 'select' | 'include'> & {
      select?: InvNamesCountAggregateInputType | true
    }
  >

  export interface invNamesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvNames that matches the filter.
     * @param {invNamesFindUniqueArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invNamesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invNamesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invNames'> extends True ? Prisma__invNamesClient<invNamesGetPayload<T>> : Prisma__invNamesClient<invNamesGetPayload<T> | null, null>

    /**
     * Find the first InvNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindFirstArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invNamesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invNamesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invNames'> extends True ? Prisma__invNamesClient<invNamesGetPayload<T>> : Prisma__invNamesClient<invNamesGetPayload<T> | null, null>

    /**
     * Find zero or more InvNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvNames
     * const invNames = await prisma.invNames.findMany()
     * 
     * // Get first 10 InvNames
     * const invNames = await prisma.invNames.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invNamesWithItemIDOnly = await prisma.invNames.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invNamesFindManyArgs>(
      args?: SelectSubset<T, invNamesFindManyArgs>
    ): PrismaPromise<Array<invNamesGetPayload<T>>>

    /**
     * Create a InvNames.
     * @param {invNamesCreateArgs} args - Arguments to create a InvNames.
     * @example
     * // Create one InvNames
     * const InvNames = await prisma.invNames.create({
     *   data: {
     *     // ... data to create a InvNames
     *   }
     * })
     * 
    **/
    create<T extends invNamesCreateArgs>(
      args: SelectSubset<T, invNamesCreateArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Create many InvNames.
     *     @param {invNamesCreateManyArgs} args - Arguments to create many InvNames.
     *     @example
     *     // Create many InvNames
     *     const invNames = await prisma.invNames.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invNamesCreateManyArgs>(
      args?: SelectSubset<T, invNamesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvNames.
     * @param {invNamesDeleteArgs} args - Arguments to delete one InvNames.
     * @example
     * // Delete one InvNames
     * const InvNames = await prisma.invNames.delete({
     *   where: {
     *     // ... filter to delete one InvNames
     *   }
     * })
     * 
    **/
    delete<T extends invNamesDeleteArgs>(
      args: SelectSubset<T, invNamesDeleteArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Update one InvNames.
     * @param {invNamesUpdateArgs} args - Arguments to update one InvNames.
     * @example
     * // Update one InvNames
     * const invNames = await prisma.invNames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invNamesUpdateArgs>(
      args: SelectSubset<T, invNamesUpdateArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Delete zero or more InvNames.
     * @param {invNamesDeleteManyArgs} args - Arguments to filter InvNames to delete.
     * @example
     * // Delete a few InvNames
     * const { count } = await prisma.invNames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invNamesDeleteManyArgs>(
      args?: SelectSubset<T, invNamesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvNames
     * const invNames = await prisma.invNames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invNamesUpdateManyArgs>(
      args: SelectSubset<T, invNamesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvNames.
     * @param {invNamesUpsertArgs} args - Arguments to update or create a InvNames.
     * @example
     * // Update or create a InvNames
     * const invNames = await prisma.invNames.upsert({
     *   create: {
     *     // ... data to create a InvNames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvNames we want to update
     *   }
     * })
    **/
    upsert<T extends invNamesUpsertArgs>(
      args: SelectSubset<T, invNamesUpsertArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Find one InvNames that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invNamesFindUniqueOrThrowArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invNamesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invNamesFindUniqueOrThrowArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Find the first InvNames that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindFirstOrThrowArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invNamesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invNamesFindFirstOrThrowArgs>
    ): Prisma__invNamesClient<invNamesGetPayload<T>>

    /**
     * Count the number of InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesCountArgs} args - Arguments to filter InvNames to count.
     * @example
     * // Count the number of InvNames
     * const count = await prisma.invNames.count({
     *   where: {
     *     // ... the filter for the InvNames we want to count
     *   }
     * })
    **/
    count<T extends invNamesCountArgs>(
      args?: Subset<T, invNamesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvNamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvNamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvNamesAggregateArgs>(args: Subset<T, InvNamesAggregateArgs>): PrismaPromise<GetInvNamesAggregateType<T>>

    /**
     * Group by InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvNamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvNamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvNamesGroupByArgs['orderBy'] }
        : { orderBy?: InvNamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvNamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvNamesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invNames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invNamesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invNames base type for findUnique actions
   */
  export type invNamesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * Filter, which invNames to fetch.
     * 
    **/
    where: invNamesWhereUniqueInput
  }

  /**
   * invNames: findUnique
   */
  export interface invNamesFindUniqueArgs extends invNamesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invNames base type for findFirst actions
   */
  export type invNamesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * Filter, which invNames to fetch.
     * 
    **/
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invNames.
     * 
    **/
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invNames.
     * 
    **/
    distinct?: Enumerable<InvNamesScalarFieldEnum>
  }

  /**
   * invNames: findFirst
   */
  export interface invNamesFindFirstArgs extends invNamesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invNames findMany
   */
  export type invNamesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * Filter, which invNames to fetch.
     * 
    **/
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invNames.
     * 
    **/
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvNamesScalarFieldEnum>
  }


  /**
   * invNames create
   */
  export type invNamesCreateArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * The data needed to create a invNames.
     * 
    **/
    data: XOR<invNamesCreateInput, invNamesUncheckedCreateInput>
  }


  /**
   * invNames createMany
   */
  export type invNamesCreateManyArgs = {
    /**
     * The data used to create many invNames.
     * 
    **/
    data: Enumerable<invNamesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invNames update
   */
  export type invNamesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * The data needed to update a invNames.
     * 
    **/
    data: XOR<invNamesUpdateInput, invNamesUncheckedUpdateInput>
    /**
     * Choose, which invNames to update.
     * 
    **/
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames updateMany
   */
  export type invNamesUpdateManyArgs = {
    /**
     * The data used to update invNames.
     * 
    **/
    data: XOR<invNamesUpdateManyMutationInput, invNamesUncheckedUpdateManyInput>
    /**
     * Filter which invNames to update
     * 
    **/
    where?: invNamesWhereInput
  }


  /**
   * invNames upsert
   */
  export type invNamesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * The filter to search for the invNames to update in case it exists.
     * 
    **/
    where: invNamesWhereUniqueInput
    /**
     * In case the invNames found by the `where` argument doesn't exist, create a new invNames with this data.
     * 
    **/
    create: XOR<invNamesCreateInput, invNamesUncheckedCreateInput>
    /**
     * In case the invNames was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invNamesUpdateInput, invNamesUncheckedUpdateInput>
  }


  /**
   * invNames delete
   */
  export type invNamesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
    /**
     * Filter which invNames to delete.
     * 
    **/
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames deleteMany
   */
  export type invNamesDeleteManyArgs = {
    /**
     * Filter which invNames to delete
     * 
    **/
    where?: invNamesWhereInput
  }


  /**
   * invNames: findUniqueOrThrow
   */
  export type invNamesFindUniqueOrThrowArgs = invNamesFindUniqueArgsBase
      

  /**
   * invNames: findFirstOrThrow
   */
  export type invNamesFindFirstOrThrowArgs = invNamesFindFirstArgsBase
      

  /**
   * invNames without action
   */
  export type invNamesArgs = {
    /**
     * Select specific fields to fetch from the invNames
     * 
    **/
    select?: invNamesSelect | null
  }



  /**
   * Model invPositions
   */


  export type AggregateInvPositions = {
    _count: InvPositionsCountAggregateOutputType | null
    _avg: InvPositionsAvgAggregateOutputType | null
    _sum: InvPositionsSumAggregateOutputType | null
    _min: InvPositionsMinAggregateOutputType | null
    _max: InvPositionsMaxAggregateOutputType | null
  }

  export type InvPositionsAvgAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsSumAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsMinAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsMaxAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsCountAggregateOutputType = {
    itemID: number
    x: number
    y: number
    z: number
    yaw: number
    pitch: number
    roll: number
    _all: number
  }


  export type InvPositionsAvgAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsSumAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsMinAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsMaxAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsCountAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
    _all?: true
  }

  export type InvPositionsAggregateArgs = {
    /**
     * Filter which invPositions to aggregate.
     * 
    **/
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<invPositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invPositions
    **/
    _count?: true | InvPositionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvPositionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvPositionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvPositionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvPositionsMaxAggregateInputType
  }

  export type GetInvPositionsAggregateType<T extends InvPositionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvPositions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvPositions[P]>
      : GetScalarType<T[P], AggregateInvPositions[P]>
  }




  export type InvPositionsGroupByArgs = {
    where?: invPositionsWhereInput
    orderBy?: Enumerable<invPositionsOrderByWithAggregationInput>
    by: Array<InvPositionsScalarFieldEnum>
    having?: invPositionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvPositionsCountAggregateInputType | true
    _avg?: InvPositionsAvgAggregateInputType
    _sum?: InvPositionsSumAggregateInputType
    _min?: InvPositionsMinAggregateInputType
    _max?: InvPositionsMaxAggregateInputType
  }


  export type InvPositionsGroupByOutputType = {
    itemID: number
    x: number
    y: number
    z: number
    yaw: number | null
    pitch: number | null
    roll: number | null
    _count: InvPositionsCountAggregateOutputType | null
    _avg: InvPositionsAvgAggregateOutputType | null
    _sum: InvPositionsSumAggregateOutputType | null
    _min: InvPositionsMinAggregateOutputType | null
    _max: InvPositionsMaxAggregateOutputType | null
  }

  type GetInvPositionsGroupByPayload<T extends InvPositionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvPositionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvPositionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvPositionsGroupByOutputType[P]>
            : GetScalarType<T[P], InvPositionsGroupByOutputType[P]>
        }
      >
    >


  export type invPositionsSelect = {
    itemID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    yaw?: boolean
    pitch?: boolean
    roll?: boolean
  }


  export type invPositionsGetPayload<S extends boolean | null | undefined | invPositionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invPositions :
    S extends undefined ? never :
    S extends { include: any } & (invPositionsArgs | invPositionsFindManyArgs)
    ? invPositions 
    : S extends { select: any } & (invPositionsArgs | invPositionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invPositions ? invPositions[P] : never
  } 
      : invPositions


  type invPositionsCountArgs = Merge<
    Omit<invPositionsFindManyArgs, 'select' | 'include'> & {
      select?: InvPositionsCountAggregateInputType | true
    }
  >

  export interface invPositionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvPositions that matches the filter.
     * @param {invPositionsFindUniqueArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invPositionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invPositionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invPositions'> extends True ? Prisma__invPositionsClient<invPositionsGetPayload<T>> : Prisma__invPositionsClient<invPositionsGetPayload<T> | null, null>

    /**
     * Find the first InvPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindFirstArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invPositionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invPositionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invPositions'> extends True ? Prisma__invPositionsClient<invPositionsGetPayload<T>> : Prisma__invPositionsClient<invPositionsGetPayload<T> | null, null>

    /**
     * Find zero or more InvPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvPositions
     * const invPositions = await prisma.invPositions.findMany()
     * 
     * // Get first 10 InvPositions
     * const invPositions = await prisma.invPositions.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invPositionsWithItemIDOnly = await prisma.invPositions.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invPositionsFindManyArgs>(
      args?: SelectSubset<T, invPositionsFindManyArgs>
    ): PrismaPromise<Array<invPositionsGetPayload<T>>>

    /**
     * Create a InvPositions.
     * @param {invPositionsCreateArgs} args - Arguments to create a InvPositions.
     * @example
     * // Create one InvPositions
     * const InvPositions = await prisma.invPositions.create({
     *   data: {
     *     // ... data to create a InvPositions
     *   }
     * })
     * 
    **/
    create<T extends invPositionsCreateArgs>(
      args: SelectSubset<T, invPositionsCreateArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Create many InvPositions.
     *     @param {invPositionsCreateManyArgs} args - Arguments to create many InvPositions.
     *     @example
     *     // Create many InvPositions
     *     const invPositions = await prisma.invPositions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invPositionsCreateManyArgs>(
      args?: SelectSubset<T, invPositionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvPositions.
     * @param {invPositionsDeleteArgs} args - Arguments to delete one InvPositions.
     * @example
     * // Delete one InvPositions
     * const InvPositions = await prisma.invPositions.delete({
     *   where: {
     *     // ... filter to delete one InvPositions
     *   }
     * })
     * 
    **/
    delete<T extends invPositionsDeleteArgs>(
      args: SelectSubset<T, invPositionsDeleteArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Update one InvPositions.
     * @param {invPositionsUpdateArgs} args - Arguments to update one InvPositions.
     * @example
     * // Update one InvPositions
     * const invPositions = await prisma.invPositions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invPositionsUpdateArgs>(
      args: SelectSubset<T, invPositionsUpdateArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Delete zero or more InvPositions.
     * @param {invPositionsDeleteManyArgs} args - Arguments to filter InvPositions to delete.
     * @example
     * // Delete a few InvPositions
     * const { count } = await prisma.invPositions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invPositionsDeleteManyArgs>(
      args?: SelectSubset<T, invPositionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvPositions
     * const invPositions = await prisma.invPositions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invPositionsUpdateManyArgs>(
      args: SelectSubset<T, invPositionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvPositions.
     * @param {invPositionsUpsertArgs} args - Arguments to update or create a InvPositions.
     * @example
     * // Update or create a InvPositions
     * const invPositions = await prisma.invPositions.upsert({
     *   create: {
     *     // ... data to create a InvPositions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvPositions we want to update
     *   }
     * })
    **/
    upsert<T extends invPositionsUpsertArgs>(
      args: SelectSubset<T, invPositionsUpsertArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Find one InvPositions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invPositionsFindUniqueOrThrowArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invPositionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invPositionsFindUniqueOrThrowArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Find the first InvPositions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindFirstOrThrowArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invPositionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invPositionsFindFirstOrThrowArgs>
    ): Prisma__invPositionsClient<invPositionsGetPayload<T>>

    /**
     * Count the number of InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsCountArgs} args - Arguments to filter InvPositions to count.
     * @example
     * // Count the number of InvPositions
     * const count = await prisma.invPositions.count({
     *   where: {
     *     // ... the filter for the InvPositions we want to count
     *   }
     * })
    **/
    count<T extends invPositionsCountArgs>(
      args?: Subset<T, invPositionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvPositionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvPositionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvPositionsAggregateArgs>(args: Subset<T, InvPositionsAggregateArgs>): PrismaPromise<GetInvPositionsAggregateType<T>>

    /**
     * Group by InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvPositionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvPositionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvPositionsGroupByArgs['orderBy'] }
        : { orderBy?: InvPositionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvPositionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvPositionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invPositions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invPositionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invPositions base type for findUnique actions
   */
  export type invPositionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * Filter, which invPositions to fetch.
     * 
    **/
    where: invPositionsWhereUniqueInput
  }

  /**
   * invPositions: findUnique
   */
  export interface invPositionsFindUniqueArgs extends invPositionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invPositions base type for findFirst actions
   */
  export type invPositionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * Filter, which invPositions to fetch.
     * 
    **/
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<invPositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invPositions.
     * 
    **/
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invPositions.
     * 
    **/
    distinct?: Enumerable<InvPositionsScalarFieldEnum>
  }

  /**
   * invPositions: findFirst
   */
  export interface invPositionsFindFirstArgs extends invPositionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invPositions findMany
   */
  export type invPositionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * Filter, which invPositions to fetch.
     * 
    **/
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<invPositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invPositions.
     * 
    **/
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvPositionsScalarFieldEnum>
  }


  /**
   * invPositions create
   */
  export type invPositionsCreateArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * The data needed to create a invPositions.
     * 
    **/
    data: XOR<invPositionsCreateInput, invPositionsUncheckedCreateInput>
  }


  /**
   * invPositions createMany
   */
  export type invPositionsCreateManyArgs = {
    /**
     * The data used to create many invPositions.
     * 
    **/
    data: Enumerable<invPositionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invPositions update
   */
  export type invPositionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * The data needed to update a invPositions.
     * 
    **/
    data: XOR<invPositionsUpdateInput, invPositionsUncheckedUpdateInput>
    /**
     * Choose, which invPositions to update.
     * 
    **/
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions updateMany
   */
  export type invPositionsUpdateManyArgs = {
    /**
     * The data used to update invPositions.
     * 
    **/
    data: XOR<invPositionsUpdateManyMutationInput, invPositionsUncheckedUpdateManyInput>
    /**
     * Filter which invPositions to update
     * 
    **/
    where?: invPositionsWhereInput
  }


  /**
   * invPositions upsert
   */
  export type invPositionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * The filter to search for the invPositions to update in case it exists.
     * 
    **/
    where: invPositionsWhereUniqueInput
    /**
     * In case the invPositions found by the `where` argument doesn't exist, create a new invPositions with this data.
     * 
    **/
    create: XOR<invPositionsCreateInput, invPositionsUncheckedCreateInput>
    /**
     * In case the invPositions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invPositionsUpdateInput, invPositionsUncheckedUpdateInput>
  }


  /**
   * invPositions delete
   */
  export type invPositionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
    /**
     * Filter which invPositions to delete.
     * 
    **/
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions deleteMany
   */
  export type invPositionsDeleteManyArgs = {
    /**
     * Filter which invPositions to delete
     * 
    **/
    where?: invPositionsWhereInput
  }


  /**
   * invPositions: findUniqueOrThrow
   */
  export type invPositionsFindUniqueOrThrowArgs = invPositionsFindUniqueArgsBase
      

  /**
   * invPositions: findFirstOrThrow
   */
  export type invPositionsFindFirstOrThrowArgs = invPositionsFindFirstArgsBase
      

  /**
   * invPositions without action
   */
  export type invPositionsArgs = {
    /**
     * Select specific fields to fetch from the invPositions
     * 
    **/
    select?: invPositionsSelect | null
  }



  /**
   * Model invTraits
   */


  export type AggregateInvTraits = {
    _count: InvTraitsCountAggregateOutputType | null
    _avg: InvTraitsAvgAggregateOutputType | null
    _sum: InvTraitsSumAggregateOutputType | null
    _min: InvTraitsMinAggregateOutputType | null
    _max: InvTraitsMaxAggregateOutputType | null
  }

  export type InvTraitsAvgAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    unitID: number | null
  }

  export type InvTraitsSumAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    unitID: number | null
  }

  export type InvTraitsMinAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
  }

  export type InvTraitsMaxAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
  }

  export type InvTraitsCountAggregateOutputType = {
    traitID: number
    typeID: number
    skillID: number
    bonus: number
    bonusText: number
    unitID: number
    _all: number
  }


  export type InvTraitsAvgAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    unitID?: true
  }

  export type InvTraitsSumAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    unitID?: true
  }

  export type InvTraitsMinAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
  }

  export type InvTraitsMaxAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
  }

  export type InvTraitsCountAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
    _all?: true
  }

  export type InvTraitsAggregateArgs = {
    /**
     * Filter which invTraits to aggregate.
     * 
    **/
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     * 
    **/
    orderBy?: Enumerable<invTraitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTraits
    **/
    _count?: true | InvTraitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTraitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTraitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTraitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTraitsMaxAggregateInputType
  }

  export type GetInvTraitsAggregateType<T extends InvTraitsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTraits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTraits[P]>
      : GetScalarType<T[P], AggregateInvTraits[P]>
  }




  export type InvTraitsGroupByArgs = {
    where?: invTraitsWhereInput
    orderBy?: Enumerable<invTraitsOrderByWithAggregationInput>
    by: Array<InvTraitsScalarFieldEnum>
    having?: invTraitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTraitsCountAggregateInputType | true
    _avg?: InvTraitsAvgAggregateInputType
    _sum?: InvTraitsSumAggregateInputType
    _min?: InvTraitsMinAggregateInputType
    _max?: InvTraitsMaxAggregateInputType
  }


  export type InvTraitsGroupByOutputType = {
    traitID: number
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
    _count: InvTraitsCountAggregateOutputType | null
    _avg: InvTraitsAvgAggregateOutputType | null
    _sum: InvTraitsSumAggregateOutputType | null
    _min: InvTraitsMinAggregateOutputType | null
    _max: InvTraitsMaxAggregateOutputType | null
  }

  type GetInvTraitsGroupByPayload<T extends InvTraitsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvTraitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTraitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTraitsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTraitsGroupByOutputType[P]>
        }
      >
    >


  export type invTraitsSelect = {
    traitID?: boolean
    typeID?: boolean
    skillID?: boolean
    bonus?: boolean
    bonusText?: boolean
    unitID?: boolean
  }


  export type invTraitsGetPayload<S extends boolean | null | undefined | invTraitsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invTraits :
    S extends undefined ? never :
    S extends { include: any } & (invTraitsArgs | invTraitsFindManyArgs)
    ? invTraits 
    : S extends { select: any } & (invTraitsArgs | invTraitsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invTraits ? invTraits[P] : never
  } 
      : invTraits


  type invTraitsCountArgs = Merge<
    Omit<invTraitsFindManyArgs, 'select' | 'include'> & {
      select?: InvTraitsCountAggregateInputType | true
    }
  >

  export interface invTraitsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvTraits that matches the filter.
     * @param {invTraitsFindUniqueArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTraitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invTraitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invTraits'> extends True ? Prisma__invTraitsClient<invTraitsGetPayload<T>> : Prisma__invTraitsClient<invTraitsGetPayload<T> | null, null>

    /**
     * Find the first InvTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindFirstArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTraitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invTraitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invTraits'> extends True ? Prisma__invTraitsClient<invTraitsGetPayload<T>> : Prisma__invTraitsClient<invTraitsGetPayload<T> | null, null>

    /**
     * Find zero or more InvTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTraits
     * const invTraits = await prisma.invTraits.findMany()
     * 
     * // Get first 10 InvTraits
     * const invTraits = await prisma.invTraits.findMany({ take: 10 })
     * 
     * // Only select the `traitID`
     * const invTraitsWithTraitIDOnly = await prisma.invTraits.findMany({ select: { traitID: true } })
     * 
    **/
    findMany<T extends invTraitsFindManyArgs>(
      args?: SelectSubset<T, invTraitsFindManyArgs>
    ): PrismaPromise<Array<invTraitsGetPayload<T>>>

    /**
     * Create a InvTraits.
     * @param {invTraitsCreateArgs} args - Arguments to create a InvTraits.
     * @example
     * // Create one InvTraits
     * const InvTraits = await prisma.invTraits.create({
     *   data: {
     *     // ... data to create a InvTraits
     *   }
     * })
     * 
    **/
    create<T extends invTraitsCreateArgs>(
      args: SelectSubset<T, invTraitsCreateArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Create many InvTraits.
     *     @param {invTraitsCreateManyArgs} args - Arguments to create many InvTraits.
     *     @example
     *     // Create many InvTraits
     *     const invTraits = await prisma.invTraits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTraitsCreateManyArgs>(
      args?: SelectSubset<T, invTraitsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvTraits.
     * @param {invTraitsDeleteArgs} args - Arguments to delete one InvTraits.
     * @example
     * // Delete one InvTraits
     * const InvTraits = await prisma.invTraits.delete({
     *   where: {
     *     // ... filter to delete one InvTraits
     *   }
     * })
     * 
    **/
    delete<T extends invTraitsDeleteArgs>(
      args: SelectSubset<T, invTraitsDeleteArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Update one InvTraits.
     * @param {invTraitsUpdateArgs} args - Arguments to update one InvTraits.
     * @example
     * // Update one InvTraits
     * const invTraits = await prisma.invTraits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTraitsUpdateArgs>(
      args: SelectSubset<T, invTraitsUpdateArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Delete zero or more InvTraits.
     * @param {invTraitsDeleteManyArgs} args - Arguments to filter InvTraits to delete.
     * @example
     * // Delete a few InvTraits
     * const { count } = await prisma.invTraits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTraitsDeleteManyArgs>(
      args?: SelectSubset<T, invTraitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTraits
     * const invTraits = await prisma.invTraits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTraitsUpdateManyArgs>(
      args: SelectSubset<T, invTraitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTraits.
     * @param {invTraitsUpsertArgs} args - Arguments to update or create a InvTraits.
     * @example
     * // Update or create a InvTraits
     * const invTraits = await prisma.invTraits.upsert({
     *   create: {
     *     // ... data to create a InvTraits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTraits we want to update
     *   }
     * })
    **/
    upsert<T extends invTraitsUpsertArgs>(
      args: SelectSubset<T, invTraitsUpsertArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Find one InvTraits that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invTraitsFindUniqueOrThrowArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTraitsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invTraitsFindUniqueOrThrowArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Find the first InvTraits that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindFirstOrThrowArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTraitsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invTraitsFindFirstOrThrowArgs>
    ): Prisma__invTraitsClient<invTraitsGetPayload<T>>

    /**
     * Count the number of InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsCountArgs} args - Arguments to filter InvTraits to count.
     * @example
     * // Count the number of InvTraits
     * const count = await prisma.invTraits.count({
     *   where: {
     *     // ... the filter for the InvTraits we want to count
     *   }
     * })
    **/
    count<T extends invTraitsCountArgs>(
      args?: Subset<T, invTraitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTraitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTraitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTraitsAggregateArgs>(args: Subset<T, InvTraitsAggregateArgs>): PrismaPromise<GetInvTraitsAggregateType<T>>

    /**
     * Group by InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTraitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvTraitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvTraitsGroupByArgs['orderBy'] }
        : { orderBy?: InvTraitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvTraitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTraitsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invTraits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invTraitsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invTraits base type for findUnique actions
   */
  export type invTraitsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * Filter, which invTraits to fetch.
     * 
    **/
    where: invTraitsWhereUniqueInput
  }

  /**
   * invTraits: findUnique
   */
  export interface invTraitsFindUniqueArgs extends invTraitsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTraits base type for findFirst actions
   */
  export type invTraitsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * Filter, which invTraits to fetch.
     * 
    **/
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     * 
    **/
    orderBy?: Enumerable<invTraitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTraits.
     * 
    **/
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTraits.
     * 
    **/
    distinct?: Enumerable<InvTraitsScalarFieldEnum>
  }

  /**
   * invTraits: findFirst
   */
  export interface invTraitsFindFirstArgs extends invTraitsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTraits findMany
   */
  export type invTraitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * Filter, which invTraits to fetch.
     * 
    **/
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     * 
    **/
    orderBy?: Enumerable<invTraitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTraits.
     * 
    **/
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvTraitsScalarFieldEnum>
  }


  /**
   * invTraits create
   */
  export type invTraitsCreateArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * The data needed to create a invTraits.
     * 
    **/
    data: XOR<invTraitsCreateInput, invTraitsUncheckedCreateInput>
  }


  /**
   * invTraits createMany
   */
  export type invTraitsCreateManyArgs = {
    /**
     * The data used to create many invTraits.
     * 
    **/
    data: Enumerable<invTraitsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invTraits update
   */
  export type invTraitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * The data needed to update a invTraits.
     * 
    **/
    data: XOR<invTraitsUpdateInput, invTraitsUncheckedUpdateInput>
    /**
     * Choose, which invTraits to update.
     * 
    **/
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits updateMany
   */
  export type invTraitsUpdateManyArgs = {
    /**
     * The data used to update invTraits.
     * 
    **/
    data: XOR<invTraitsUpdateManyMutationInput, invTraitsUncheckedUpdateManyInput>
    /**
     * Filter which invTraits to update
     * 
    **/
    where?: invTraitsWhereInput
  }


  /**
   * invTraits upsert
   */
  export type invTraitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * The filter to search for the invTraits to update in case it exists.
     * 
    **/
    where: invTraitsWhereUniqueInput
    /**
     * In case the invTraits found by the `where` argument doesn't exist, create a new invTraits with this data.
     * 
    **/
    create: XOR<invTraitsCreateInput, invTraitsUncheckedCreateInput>
    /**
     * In case the invTraits was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invTraitsUpdateInput, invTraitsUncheckedUpdateInput>
  }


  /**
   * invTraits delete
   */
  export type invTraitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
    /**
     * Filter which invTraits to delete.
     * 
    **/
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits deleteMany
   */
  export type invTraitsDeleteManyArgs = {
    /**
     * Filter which invTraits to delete
     * 
    **/
    where?: invTraitsWhereInput
  }


  /**
   * invTraits: findUniqueOrThrow
   */
  export type invTraitsFindUniqueOrThrowArgs = invTraitsFindUniqueArgsBase
      

  /**
   * invTraits: findFirstOrThrow
   */
  export type invTraitsFindFirstOrThrowArgs = invTraitsFindFirstArgsBase
      

  /**
   * invTraits without action
   */
  export type invTraitsArgs = {
    /**
     * Select specific fields to fetch from the invTraits
     * 
    **/
    select?: invTraitsSelect | null
  }



  /**
   * Model invTypeMaterials
   */


  export type AggregateInvTypeMaterials = {
    _count: InvTypeMaterialsCountAggregateOutputType | null
    _avg: InvTypeMaterialsAvgAggregateOutputType | null
    _sum: InvTypeMaterialsSumAggregateOutputType | null
    _min: InvTypeMaterialsMinAggregateOutputType | null
    _max: InvTypeMaterialsMaxAggregateOutputType | null
  }

  export type InvTypeMaterialsAvgAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsSumAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsMinAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsMaxAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsCountAggregateOutputType = {
    typeID: number
    materialTypeID: number
    quantity: number
    _all: number
  }


  export type InvTypeMaterialsAvgAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsSumAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsMinAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsMaxAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsCountAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
    _all?: true
  }

  export type InvTypeMaterialsAggregateArgs = {
    /**
     * Filter which invTypeMaterials to aggregate.
     * 
    **/
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypeMaterials
    **/
    _count?: true | InvTypeMaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypeMaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypeMaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypeMaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypeMaterialsMaxAggregateInputType
  }

  export type GetInvTypeMaterialsAggregateType<T extends InvTypeMaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypeMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypeMaterials[P]>
      : GetScalarType<T[P], AggregateInvTypeMaterials[P]>
  }




  export type InvTypeMaterialsGroupByArgs = {
    where?: invTypeMaterialsWhereInput
    orderBy?: Enumerable<invTypeMaterialsOrderByWithAggregationInput>
    by: Array<InvTypeMaterialsScalarFieldEnum>
    having?: invTypeMaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypeMaterialsCountAggregateInputType | true
    _avg?: InvTypeMaterialsAvgAggregateInputType
    _sum?: InvTypeMaterialsSumAggregateInputType
    _min?: InvTypeMaterialsMinAggregateInputType
    _max?: InvTypeMaterialsMaxAggregateInputType
  }


  export type InvTypeMaterialsGroupByOutputType = {
    typeID: number
    materialTypeID: number
    quantity: number
    _count: InvTypeMaterialsCountAggregateOutputType | null
    _avg: InvTypeMaterialsAvgAggregateOutputType | null
    _sum: InvTypeMaterialsSumAggregateOutputType | null
    _min: InvTypeMaterialsMinAggregateOutputType | null
    _max: InvTypeMaterialsMaxAggregateOutputType | null
  }

  type GetInvTypeMaterialsGroupByPayload<T extends InvTypeMaterialsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvTypeMaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypeMaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypeMaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypeMaterialsGroupByOutputType[P]>
        }
      >
    >


  export type invTypeMaterialsSelect = {
    typeID?: boolean
    materialTypeID?: boolean
    quantity?: boolean
  }


  export type invTypeMaterialsGetPayload<S extends boolean | null | undefined | invTypeMaterialsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invTypeMaterials :
    S extends undefined ? never :
    S extends { include: any } & (invTypeMaterialsArgs | invTypeMaterialsFindManyArgs)
    ? invTypeMaterials 
    : S extends { select: any } & (invTypeMaterialsArgs | invTypeMaterialsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invTypeMaterials ? invTypeMaterials[P] : never
  } 
      : invTypeMaterials


  type invTypeMaterialsCountArgs = Merge<
    Omit<invTypeMaterialsFindManyArgs, 'select' | 'include'> & {
      select?: InvTypeMaterialsCountAggregateInputType | true
    }
  >

  export interface invTypeMaterialsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvTypeMaterials that matches the filter.
     * @param {invTypeMaterialsFindUniqueArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypeMaterialsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invTypeMaterialsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invTypeMaterials'> extends True ? Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>> : Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T> | null, null>

    /**
     * Find the first InvTypeMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindFirstArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypeMaterialsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invTypeMaterialsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invTypeMaterials'> extends True ? Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>> : Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T> | null, null>

    /**
     * Find zero or more InvTypeMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findMany()
     * 
     * // Get first 10 InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invTypeMaterialsWithTypeIDOnly = await prisma.invTypeMaterials.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invTypeMaterialsFindManyArgs>(
      args?: SelectSubset<T, invTypeMaterialsFindManyArgs>
    ): PrismaPromise<Array<invTypeMaterialsGetPayload<T>>>

    /**
     * Create a InvTypeMaterials.
     * @param {invTypeMaterialsCreateArgs} args - Arguments to create a InvTypeMaterials.
     * @example
     * // Create one InvTypeMaterials
     * const InvTypeMaterials = await prisma.invTypeMaterials.create({
     *   data: {
     *     // ... data to create a InvTypeMaterials
     *   }
     * })
     * 
    **/
    create<T extends invTypeMaterialsCreateArgs>(
      args: SelectSubset<T, invTypeMaterialsCreateArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Create many InvTypeMaterials.
     *     @param {invTypeMaterialsCreateManyArgs} args - Arguments to create many InvTypeMaterials.
     *     @example
     *     // Create many InvTypeMaterials
     *     const invTypeMaterials = await prisma.invTypeMaterials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypeMaterialsCreateManyArgs>(
      args?: SelectSubset<T, invTypeMaterialsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypeMaterials.
     * @param {invTypeMaterialsDeleteArgs} args - Arguments to delete one InvTypeMaterials.
     * @example
     * // Delete one InvTypeMaterials
     * const InvTypeMaterials = await prisma.invTypeMaterials.delete({
     *   where: {
     *     // ... filter to delete one InvTypeMaterials
     *   }
     * })
     * 
    **/
    delete<T extends invTypeMaterialsDeleteArgs>(
      args: SelectSubset<T, invTypeMaterialsDeleteArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Update one InvTypeMaterials.
     * @param {invTypeMaterialsUpdateArgs} args - Arguments to update one InvTypeMaterials.
     * @example
     * // Update one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypeMaterialsUpdateArgs>(
      args: SelectSubset<T, invTypeMaterialsUpdateArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Delete zero or more InvTypeMaterials.
     * @param {invTypeMaterialsDeleteManyArgs} args - Arguments to filter InvTypeMaterials to delete.
     * @example
     * // Delete a few InvTypeMaterials
     * const { count } = await prisma.invTypeMaterials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypeMaterialsDeleteManyArgs>(
      args?: SelectSubset<T, invTypeMaterialsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypeMaterialsUpdateManyArgs>(
      args: SelectSubset<T, invTypeMaterialsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypeMaterials.
     * @param {invTypeMaterialsUpsertArgs} args - Arguments to update or create a InvTypeMaterials.
     * @example
     * // Update or create a InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.upsert({
     *   create: {
     *     // ... data to create a InvTypeMaterials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypeMaterials we want to update
     *   }
     * })
    **/
    upsert<T extends invTypeMaterialsUpsertArgs>(
      args: SelectSubset<T, invTypeMaterialsUpsertArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Find one InvTypeMaterials that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invTypeMaterialsFindUniqueOrThrowArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypeMaterialsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invTypeMaterialsFindUniqueOrThrowArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Find the first InvTypeMaterials that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindFirstOrThrowArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypeMaterialsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invTypeMaterialsFindFirstOrThrowArgs>
    ): Prisma__invTypeMaterialsClient<invTypeMaterialsGetPayload<T>>

    /**
     * Count the number of InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsCountArgs} args - Arguments to filter InvTypeMaterials to count.
     * @example
     * // Count the number of InvTypeMaterials
     * const count = await prisma.invTypeMaterials.count({
     *   where: {
     *     // ... the filter for the InvTypeMaterials we want to count
     *   }
     * })
    **/
    count<T extends invTypeMaterialsCountArgs>(
      args?: Subset<T, invTypeMaterialsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypeMaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeMaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypeMaterialsAggregateArgs>(args: Subset<T, InvTypeMaterialsAggregateArgs>): PrismaPromise<GetInvTypeMaterialsAggregateType<T>>

    /**
     * Group by InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeMaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvTypeMaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvTypeMaterialsGroupByArgs['orderBy'] }
        : { orderBy?: InvTypeMaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvTypeMaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypeMaterialsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypeMaterials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invTypeMaterialsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invTypeMaterials base type for findUnique actions
   */
  export type invTypeMaterialsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * Filter, which invTypeMaterials to fetch.
     * 
    **/
    where: invTypeMaterialsWhereUniqueInput
  }

  /**
   * invTypeMaterials: findUnique
   */
  export interface invTypeMaterialsFindUniqueArgs extends invTypeMaterialsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypeMaterials base type for findFirst actions
   */
  export type invTypeMaterialsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * Filter, which invTypeMaterials to fetch.
     * 
    **/
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeMaterials.
     * 
    **/
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeMaterials.
     * 
    **/
    distinct?: Enumerable<InvTypeMaterialsScalarFieldEnum>
  }

  /**
   * invTypeMaterials: findFirst
   */
  export interface invTypeMaterialsFindFirstArgs extends invTypeMaterialsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypeMaterials findMany
   */
  export type invTypeMaterialsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * Filter, which invTypeMaterials to fetch.
     * 
    **/
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypeMaterials.
     * 
    **/
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvTypeMaterialsScalarFieldEnum>
  }


  /**
   * invTypeMaterials create
   */
  export type invTypeMaterialsCreateArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * The data needed to create a invTypeMaterials.
     * 
    **/
    data: XOR<invTypeMaterialsCreateInput, invTypeMaterialsUncheckedCreateInput>
  }


  /**
   * invTypeMaterials createMany
   */
  export type invTypeMaterialsCreateManyArgs = {
    /**
     * The data used to create many invTypeMaterials.
     * 
    **/
    data: Enumerable<invTypeMaterialsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invTypeMaterials update
   */
  export type invTypeMaterialsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * The data needed to update a invTypeMaterials.
     * 
    **/
    data: XOR<invTypeMaterialsUpdateInput, invTypeMaterialsUncheckedUpdateInput>
    /**
     * Choose, which invTypeMaterials to update.
     * 
    **/
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials updateMany
   */
  export type invTypeMaterialsUpdateManyArgs = {
    /**
     * The data used to update invTypeMaterials.
     * 
    **/
    data: XOR<invTypeMaterialsUpdateManyMutationInput, invTypeMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which invTypeMaterials to update
     * 
    **/
    where?: invTypeMaterialsWhereInput
  }


  /**
   * invTypeMaterials upsert
   */
  export type invTypeMaterialsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * The filter to search for the invTypeMaterials to update in case it exists.
     * 
    **/
    where: invTypeMaterialsWhereUniqueInput
    /**
     * In case the invTypeMaterials found by the `where` argument doesn't exist, create a new invTypeMaterials with this data.
     * 
    **/
    create: XOR<invTypeMaterialsCreateInput, invTypeMaterialsUncheckedCreateInput>
    /**
     * In case the invTypeMaterials was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invTypeMaterialsUpdateInput, invTypeMaterialsUncheckedUpdateInput>
  }


  /**
   * invTypeMaterials delete
   */
  export type invTypeMaterialsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
    /**
     * Filter which invTypeMaterials to delete.
     * 
    **/
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials deleteMany
   */
  export type invTypeMaterialsDeleteManyArgs = {
    /**
     * Filter which invTypeMaterials to delete
     * 
    **/
    where?: invTypeMaterialsWhereInput
  }


  /**
   * invTypeMaterials: findUniqueOrThrow
   */
  export type invTypeMaterialsFindUniqueOrThrowArgs = invTypeMaterialsFindUniqueArgsBase
      

  /**
   * invTypeMaterials: findFirstOrThrow
   */
  export type invTypeMaterialsFindFirstOrThrowArgs = invTypeMaterialsFindFirstArgsBase
      

  /**
   * invTypeMaterials without action
   */
  export type invTypeMaterialsArgs = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     * 
    **/
    select?: invTypeMaterialsSelect | null
  }



  /**
   * Model invTypeReactions
   */


  export type AggregateInvTypeReactions = {
    _count: InvTypeReactionsCountAggregateOutputType | null
    _avg: InvTypeReactionsAvgAggregateOutputType | null
    _sum: InvTypeReactionsSumAggregateOutputType | null
    _min: InvTypeReactionsMinAggregateOutputType | null
    _max: InvTypeReactionsMaxAggregateOutputType | null
  }

  export type InvTypeReactionsAvgAggregateOutputType = {
    reactionTypeID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsSumAggregateOutputType = {
    reactionTypeID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsMinAggregateOutputType = {
    reactionTypeID: number | null
    input: boolean | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsMaxAggregateOutputType = {
    reactionTypeID: number | null
    input: boolean | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsCountAggregateOutputType = {
    reactionTypeID: number
    input: number
    typeID: number
    quantity: number
    _all: number
  }


  export type InvTypeReactionsAvgAggregateInputType = {
    reactionTypeID?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsSumAggregateInputType = {
    reactionTypeID?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsMinAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsMaxAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsCountAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
    _all?: true
  }

  export type InvTypeReactionsAggregateArgs = {
    /**
     * Filter which invTypeReactions to aggregate.
     * 
    **/
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeReactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypeReactions
    **/
    _count?: true | InvTypeReactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypeReactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypeReactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypeReactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypeReactionsMaxAggregateInputType
  }

  export type GetInvTypeReactionsAggregateType<T extends InvTypeReactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypeReactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypeReactions[P]>
      : GetScalarType<T[P], AggregateInvTypeReactions[P]>
  }




  export type InvTypeReactionsGroupByArgs = {
    where?: invTypeReactionsWhereInput
    orderBy?: Enumerable<invTypeReactionsOrderByWithAggregationInput>
    by: Array<InvTypeReactionsScalarFieldEnum>
    having?: invTypeReactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypeReactionsCountAggregateInputType | true
    _avg?: InvTypeReactionsAvgAggregateInputType
    _sum?: InvTypeReactionsSumAggregateInputType
    _min?: InvTypeReactionsMinAggregateInputType
    _max?: InvTypeReactionsMaxAggregateInputType
  }


  export type InvTypeReactionsGroupByOutputType = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity: number | null
    _count: InvTypeReactionsCountAggregateOutputType | null
    _avg: InvTypeReactionsAvgAggregateOutputType | null
    _sum: InvTypeReactionsSumAggregateOutputType | null
    _min: InvTypeReactionsMinAggregateOutputType | null
    _max: InvTypeReactionsMaxAggregateOutputType | null
  }

  type GetInvTypeReactionsGroupByPayload<T extends InvTypeReactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvTypeReactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypeReactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypeReactionsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypeReactionsGroupByOutputType[P]>
        }
      >
    >


  export type invTypeReactionsSelect = {
    reactionTypeID?: boolean
    input?: boolean
    typeID?: boolean
    quantity?: boolean
  }


  export type invTypeReactionsGetPayload<S extends boolean | null | undefined | invTypeReactionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invTypeReactions :
    S extends undefined ? never :
    S extends { include: any } & (invTypeReactionsArgs | invTypeReactionsFindManyArgs)
    ? invTypeReactions 
    : S extends { select: any } & (invTypeReactionsArgs | invTypeReactionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invTypeReactions ? invTypeReactions[P] : never
  } 
      : invTypeReactions


  type invTypeReactionsCountArgs = Merge<
    Omit<invTypeReactionsFindManyArgs, 'select' | 'include'> & {
      select?: InvTypeReactionsCountAggregateInputType | true
    }
  >

  export interface invTypeReactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvTypeReactions that matches the filter.
     * @param {invTypeReactionsFindUniqueArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypeReactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invTypeReactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invTypeReactions'> extends True ? Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>> : Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T> | null, null>

    /**
     * Find the first InvTypeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindFirstArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypeReactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invTypeReactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invTypeReactions'> extends True ? Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>> : Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T> | null, null>

    /**
     * Find zero or more InvTypeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findMany()
     * 
     * // Get first 10 InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findMany({ take: 10 })
     * 
     * // Only select the `reactionTypeID`
     * const invTypeReactionsWithReactionTypeIDOnly = await prisma.invTypeReactions.findMany({ select: { reactionTypeID: true } })
     * 
    **/
    findMany<T extends invTypeReactionsFindManyArgs>(
      args?: SelectSubset<T, invTypeReactionsFindManyArgs>
    ): PrismaPromise<Array<invTypeReactionsGetPayload<T>>>

    /**
     * Create a InvTypeReactions.
     * @param {invTypeReactionsCreateArgs} args - Arguments to create a InvTypeReactions.
     * @example
     * // Create one InvTypeReactions
     * const InvTypeReactions = await prisma.invTypeReactions.create({
     *   data: {
     *     // ... data to create a InvTypeReactions
     *   }
     * })
     * 
    **/
    create<T extends invTypeReactionsCreateArgs>(
      args: SelectSubset<T, invTypeReactionsCreateArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Create many InvTypeReactions.
     *     @param {invTypeReactionsCreateManyArgs} args - Arguments to create many InvTypeReactions.
     *     @example
     *     // Create many InvTypeReactions
     *     const invTypeReactions = await prisma.invTypeReactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypeReactionsCreateManyArgs>(
      args?: SelectSubset<T, invTypeReactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypeReactions.
     * @param {invTypeReactionsDeleteArgs} args - Arguments to delete one InvTypeReactions.
     * @example
     * // Delete one InvTypeReactions
     * const InvTypeReactions = await prisma.invTypeReactions.delete({
     *   where: {
     *     // ... filter to delete one InvTypeReactions
     *   }
     * })
     * 
    **/
    delete<T extends invTypeReactionsDeleteArgs>(
      args: SelectSubset<T, invTypeReactionsDeleteArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Update one InvTypeReactions.
     * @param {invTypeReactionsUpdateArgs} args - Arguments to update one InvTypeReactions.
     * @example
     * // Update one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypeReactionsUpdateArgs>(
      args: SelectSubset<T, invTypeReactionsUpdateArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Delete zero or more InvTypeReactions.
     * @param {invTypeReactionsDeleteManyArgs} args - Arguments to filter InvTypeReactions to delete.
     * @example
     * // Delete a few InvTypeReactions
     * const { count } = await prisma.invTypeReactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypeReactionsDeleteManyArgs>(
      args?: SelectSubset<T, invTypeReactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypeReactionsUpdateManyArgs>(
      args: SelectSubset<T, invTypeReactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypeReactions.
     * @param {invTypeReactionsUpsertArgs} args - Arguments to update or create a InvTypeReactions.
     * @example
     * // Update or create a InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.upsert({
     *   create: {
     *     // ... data to create a InvTypeReactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypeReactions we want to update
     *   }
     * })
    **/
    upsert<T extends invTypeReactionsUpsertArgs>(
      args: SelectSubset<T, invTypeReactionsUpsertArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Find one InvTypeReactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invTypeReactionsFindUniqueOrThrowArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypeReactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invTypeReactionsFindUniqueOrThrowArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Find the first InvTypeReactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindFirstOrThrowArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypeReactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invTypeReactionsFindFirstOrThrowArgs>
    ): Prisma__invTypeReactionsClient<invTypeReactionsGetPayload<T>>

    /**
     * Count the number of InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsCountArgs} args - Arguments to filter InvTypeReactions to count.
     * @example
     * // Count the number of InvTypeReactions
     * const count = await prisma.invTypeReactions.count({
     *   where: {
     *     // ... the filter for the InvTypeReactions we want to count
     *   }
     * })
    **/
    count<T extends invTypeReactionsCountArgs>(
      args?: Subset<T, invTypeReactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypeReactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeReactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypeReactionsAggregateArgs>(args: Subset<T, InvTypeReactionsAggregateArgs>): PrismaPromise<GetInvTypeReactionsAggregateType<T>>

    /**
     * Group by InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeReactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvTypeReactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvTypeReactionsGroupByArgs['orderBy'] }
        : { orderBy?: InvTypeReactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvTypeReactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypeReactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypeReactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invTypeReactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invTypeReactions base type for findUnique actions
   */
  export type invTypeReactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * Filter, which invTypeReactions to fetch.
     * 
    **/
    where: invTypeReactionsWhereUniqueInput
  }

  /**
   * invTypeReactions: findUnique
   */
  export interface invTypeReactionsFindUniqueArgs extends invTypeReactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypeReactions base type for findFirst actions
   */
  export type invTypeReactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * Filter, which invTypeReactions to fetch.
     * 
    **/
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeReactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeReactions.
     * 
    **/
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeReactions.
     * 
    **/
    distinct?: Enumerable<InvTypeReactionsScalarFieldEnum>
  }

  /**
   * invTypeReactions: findFirst
   */
  export interface invTypeReactionsFindFirstArgs extends invTypeReactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypeReactions findMany
   */
  export type invTypeReactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * Filter, which invTypeReactions to fetch.
     * 
    **/
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypeReactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypeReactions.
     * 
    **/
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvTypeReactionsScalarFieldEnum>
  }


  /**
   * invTypeReactions create
   */
  export type invTypeReactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * The data needed to create a invTypeReactions.
     * 
    **/
    data: XOR<invTypeReactionsCreateInput, invTypeReactionsUncheckedCreateInput>
  }


  /**
   * invTypeReactions createMany
   */
  export type invTypeReactionsCreateManyArgs = {
    /**
     * The data used to create many invTypeReactions.
     * 
    **/
    data: Enumerable<invTypeReactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invTypeReactions update
   */
  export type invTypeReactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * The data needed to update a invTypeReactions.
     * 
    **/
    data: XOR<invTypeReactionsUpdateInput, invTypeReactionsUncheckedUpdateInput>
    /**
     * Choose, which invTypeReactions to update.
     * 
    **/
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions updateMany
   */
  export type invTypeReactionsUpdateManyArgs = {
    /**
     * The data used to update invTypeReactions.
     * 
    **/
    data: XOR<invTypeReactionsUpdateManyMutationInput, invTypeReactionsUncheckedUpdateManyInput>
    /**
     * Filter which invTypeReactions to update
     * 
    **/
    where?: invTypeReactionsWhereInput
  }


  /**
   * invTypeReactions upsert
   */
  export type invTypeReactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * The filter to search for the invTypeReactions to update in case it exists.
     * 
    **/
    where: invTypeReactionsWhereUniqueInput
    /**
     * In case the invTypeReactions found by the `where` argument doesn't exist, create a new invTypeReactions with this data.
     * 
    **/
    create: XOR<invTypeReactionsCreateInput, invTypeReactionsUncheckedCreateInput>
    /**
     * In case the invTypeReactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invTypeReactionsUpdateInput, invTypeReactionsUncheckedUpdateInput>
  }


  /**
   * invTypeReactions delete
   */
  export type invTypeReactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
    /**
     * Filter which invTypeReactions to delete.
     * 
    **/
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions deleteMany
   */
  export type invTypeReactionsDeleteManyArgs = {
    /**
     * Filter which invTypeReactions to delete
     * 
    **/
    where?: invTypeReactionsWhereInput
  }


  /**
   * invTypeReactions: findUniqueOrThrow
   */
  export type invTypeReactionsFindUniqueOrThrowArgs = invTypeReactionsFindUniqueArgsBase
      

  /**
   * invTypeReactions: findFirstOrThrow
   */
  export type invTypeReactionsFindFirstOrThrowArgs = invTypeReactionsFindFirstArgsBase
      

  /**
   * invTypeReactions without action
   */
  export type invTypeReactionsArgs = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     * 
    **/
    select?: invTypeReactionsSelect | null
  }



  /**
   * Model invTypes
   */


  export type AggregateInvTypes = {
    _count: InvTypesCountAggregateOutputType | null
    _avg: InvTypesAvgAggregateOutputType | null
    _sum: InvTypesSumAggregateOutputType | null
    _min: InvTypesMinAggregateOutputType | null
    _max: InvTypesMaxAggregateOutputType | null
  }

  export type InvTypesAvgAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesSumAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesMinAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesMaxAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesCountAggregateOutputType = {
    typeID: number
    groupID: number
    typeName: number
    description: number
    mass: number
    volume: number
    capacity: number
    portionSize: number
    raceID: number
    basePrice: number
    published: number
    marketGroupID: number
    iconID: number
    soundID: number
    graphicID: number
    _all: number
  }


  export type InvTypesAvgAggregateInputType = {
    typeID?: true
    groupID?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesSumAggregateInputType = {
    typeID?: true
    groupID?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesMinAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesMaxAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesCountAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
    _all?: true
  }

  export type InvTypesAggregateArgs = {
    /**
     * Filter which invTypes to aggregate.
     * 
    **/
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypes
    **/
    _count?: true | InvTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypesMaxAggregateInputType
  }

  export type GetInvTypesAggregateType<T extends InvTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypes[P]>
      : GetScalarType<T[P], AggregateInvTypes[P]>
  }




  export type InvTypesGroupByArgs = {
    where?: invTypesWhereInput
    orderBy?: Enumerable<invTypesOrderByWithAggregationInput>
    by: Array<InvTypesScalarFieldEnum>
    having?: invTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypesCountAggregateInputType | true
    _avg?: InvTypesAvgAggregateInputType
    _sum?: InvTypesSumAggregateInputType
    _min?: InvTypesMinAggregateInputType
    _max?: InvTypesMaxAggregateInputType
  }


  export type InvTypesGroupByOutputType = {
    typeID: number
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
    _count: InvTypesCountAggregateOutputType | null
    _avg: InvTypesAvgAggregateOutputType | null
    _sum: InvTypesSumAggregateOutputType | null
    _min: InvTypesMinAggregateOutputType | null
    _max: InvTypesMaxAggregateOutputType | null
  }

  type GetInvTypesGroupByPayload<T extends InvTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypesGroupByOutputType[P]>
        }
      >
    >


  export type invTypesSelect = {
    typeID?: boolean
    groupID?: boolean
    typeName?: boolean
    description?: boolean
    mass?: boolean
    volume?: boolean
    capacity?: boolean
    portionSize?: boolean
    raceID?: boolean
    basePrice?: boolean
    published?: boolean
    marketGroupID?: boolean
    iconID?: boolean
    soundID?: boolean
    graphicID?: boolean
  }


  export type invTypesGetPayload<S extends boolean | null | undefined | invTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invTypes :
    S extends undefined ? never :
    S extends { include: any } & (invTypesArgs | invTypesFindManyArgs)
    ? invTypes 
    : S extends { select: any } & (invTypesArgs | invTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invTypes ? invTypes[P] : never
  } 
      : invTypes


  type invTypesCountArgs = Merge<
    Omit<invTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvTypesCountAggregateInputType | true
    }
  >

  export interface invTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvTypes that matches the filter.
     * @param {invTypesFindUniqueArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invTypes'> extends True ? Prisma__invTypesClient<invTypesGetPayload<T>> : Prisma__invTypesClient<invTypesGetPayload<T> | null, null>

    /**
     * Find the first InvTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindFirstArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invTypes'> extends True ? Prisma__invTypesClient<invTypesGetPayload<T>> : Prisma__invTypesClient<invTypesGetPayload<T> | null, null>

    /**
     * Find zero or more InvTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypes
     * const invTypes = await prisma.invTypes.findMany()
     * 
     * // Get first 10 InvTypes
     * const invTypes = await prisma.invTypes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invTypesWithTypeIDOnly = await prisma.invTypes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invTypesFindManyArgs>(
      args?: SelectSubset<T, invTypesFindManyArgs>
    ): PrismaPromise<Array<invTypesGetPayload<T>>>

    /**
     * Create a InvTypes.
     * @param {invTypesCreateArgs} args - Arguments to create a InvTypes.
     * @example
     * // Create one InvTypes
     * const InvTypes = await prisma.invTypes.create({
     *   data: {
     *     // ... data to create a InvTypes
     *   }
     * })
     * 
    **/
    create<T extends invTypesCreateArgs>(
      args: SelectSubset<T, invTypesCreateArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Create many InvTypes.
     *     @param {invTypesCreateManyArgs} args - Arguments to create many InvTypes.
     *     @example
     *     // Create many InvTypes
     *     const invTypes = await prisma.invTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypesCreateManyArgs>(
      args?: SelectSubset<T, invTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypes.
     * @param {invTypesDeleteArgs} args - Arguments to delete one InvTypes.
     * @example
     * // Delete one InvTypes
     * const InvTypes = await prisma.invTypes.delete({
     *   where: {
     *     // ... filter to delete one InvTypes
     *   }
     * })
     * 
    **/
    delete<T extends invTypesDeleteArgs>(
      args: SelectSubset<T, invTypesDeleteArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Update one InvTypes.
     * @param {invTypesUpdateArgs} args - Arguments to update one InvTypes.
     * @example
     * // Update one InvTypes
     * const invTypes = await prisma.invTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypesUpdateArgs>(
      args: SelectSubset<T, invTypesUpdateArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Delete zero or more InvTypes.
     * @param {invTypesDeleteManyArgs} args - Arguments to filter InvTypes to delete.
     * @example
     * // Delete a few InvTypes
     * const { count } = await prisma.invTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypesDeleteManyArgs>(
      args?: SelectSubset<T, invTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypes
     * const invTypes = await prisma.invTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypesUpdateManyArgs>(
      args: SelectSubset<T, invTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypes.
     * @param {invTypesUpsertArgs} args - Arguments to update or create a InvTypes.
     * @example
     * // Update or create a InvTypes
     * const invTypes = await prisma.invTypes.upsert({
     *   create: {
     *     // ... data to create a InvTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invTypesUpsertArgs>(
      args: SelectSubset<T, invTypesUpsertArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Find one InvTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invTypesFindUniqueOrThrowArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invTypesFindUniqueOrThrowArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Find the first InvTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindFirstOrThrowArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invTypesFindFirstOrThrowArgs>
    ): Prisma__invTypesClient<invTypesGetPayload<T>>

    /**
     * Count the number of InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesCountArgs} args - Arguments to filter InvTypes to count.
     * @example
     * // Count the number of InvTypes
     * const count = await prisma.invTypes.count({
     *   where: {
     *     // ... the filter for the InvTypes we want to count
     *   }
     * })
    **/
    count<T extends invTypesCountArgs>(
      args?: Subset<T, invTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypesAggregateArgs>(args: Subset<T, InvTypesAggregateArgs>): PrismaPromise<GetInvTypesAggregateType<T>>

    /**
     * Group by InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvTypesGroupByArgs['orderBy'] }
        : { orderBy?: InvTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invTypes base type for findUnique actions
   */
  export type invTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * Filter, which invTypes to fetch.
     * 
    **/
    where: invTypesWhereUniqueInput
  }

  /**
   * invTypes: findUnique
   */
  export interface invTypesFindUniqueArgs extends invTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypes base type for findFirst actions
   */
  export type invTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * Filter, which invTypes to fetch.
     * 
    **/
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypes.
     * 
    **/
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypes.
     * 
    **/
    distinct?: Enumerable<InvTypesScalarFieldEnum>
  }

  /**
   * invTypes: findFirst
   */
  export interface invTypesFindFirstArgs extends invTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invTypes findMany
   */
  export type invTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * Filter, which invTypes to fetch.
     * 
    **/
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<invTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypes.
     * 
    **/
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvTypesScalarFieldEnum>
  }


  /**
   * invTypes create
   */
  export type invTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * The data needed to create a invTypes.
     * 
    **/
    data: XOR<invTypesCreateInput, invTypesUncheckedCreateInput>
  }


  /**
   * invTypes createMany
   */
  export type invTypesCreateManyArgs = {
    /**
     * The data used to create many invTypes.
     * 
    **/
    data: Enumerable<invTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invTypes update
   */
  export type invTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * The data needed to update a invTypes.
     * 
    **/
    data: XOR<invTypesUpdateInput, invTypesUncheckedUpdateInput>
    /**
     * Choose, which invTypes to update.
     * 
    **/
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes updateMany
   */
  export type invTypesUpdateManyArgs = {
    /**
     * The data used to update invTypes.
     * 
    **/
    data: XOR<invTypesUpdateManyMutationInput, invTypesUncheckedUpdateManyInput>
    /**
     * Filter which invTypes to update
     * 
    **/
    where?: invTypesWhereInput
  }


  /**
   * invTypes upsert
   */
  export type invTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * The filter to search for the invTypes to update in case it exists.
     * 
    **/
    where: invTypesWhereUniqueInput
    /**
     * In case the invTypes found by the `where` argument doesn't exist, create a new invTypes with this data.
     * 
    **/
    create: XOR<invTypesCreateInput, invTypesUncheckedCreateInput>
    /**
     * In case the invTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invTypesUpdateInput, invTypesUncheckedUpdateInput>
  }


  /**
   * invTypes delete
   */
  export type invTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
    /**
     * Filter which invTypes to delete.
     * 
    **/
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes deleteMany
   */
  export type invTypesDeleteManyArgs = {
    /**
     * Filter which invTypes to delete
     * 
    **/
    where?: invTypesWhereInput
  }


  /**
   * invTypes: findUniqueOrThrow
   */
  export type invTypesFindUniqueOrThrowArgs = invTypesFindUniqueArgsBase
      

  /**
   * invTypes: findFirstOrThrow
   */
  export type invTypesFindFirstOrThrowArgs = invTypesFindFirstArgsBase
      

  /**
   * invTypes without action
   */
  export type invTypesArgs = {
    /**
     * Select specific fields to fetch from the invTypes
     * 
    **/
    select?: invTypesSelect | null
  }



  /**
   * Model invUniqueNames
   */


  export type AggregateInvUniqueNames = {
    _count: InvUniqueNamesCountAggregateOutputType | null
    _avg: InvUniqueNamesAvgAggregateOutputType | null
    _sum: InvUniqueNamesSumAggregateOutputType | null
    _min: InvUniqueNamesMinAggregateOutputType | null
    _max: InvUniqueNamesMaxAggregateOutputType | null
  }

  export type InvUniqueNamesAvgAggregateOutputType = {
    itemID: number | null
    groupID: number | null
  }

  export type InvUniqueNamesSumAggregateOutputType = {
    itemID: number | null
    groupID: number | null
  }

  export type InvUniqueNamesMinAggregateOutputType = {
    itemID: number | null
    itemName: string | null
    groupID: number | null
  }

  export type InvUniqueNamesMaxAggregateOutputType = {
    itemID: number | null
    itemName: string | null
    groupID: number | null
  }

  export type InvUniqueNamesCountAggregateOutputType = {
    itemID: number
    itemName: number
    groupID: number
    _all: number
  }


  export type InvUniqueNamesAvgAggregateInputType = {
    itemID?: true
    groupID?: true
  }

  export type InvUniqueNamesSumAggregateInputType = {
    itemID?: true
    groupID?: true
  }

  export type InvUniqueNamesMinAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
  }

  export type InvUniqueNamesMaxAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
  }

  export type InvUniqueNamesCountAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
    _all?: true
  }

  export type InvUniqueNamesAggregateArgs = {
    /**
     * Filter which invUniqueNames to aggregate.
     * 
    **/
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invUniqueNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invUniqueNames
    **/
    _count?: true | InvUniqueNamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvUniqueNamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvUniqueNamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvUniqueNamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvUniqueNamesMaxAggregateInputType
  }

  export type GetInvUniqueNamesAggregateType<T extends InvUniqueNamesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvUniqueNames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvUniqueNames[P]>
      : GetScalarType<T[P], AggregateInvUniqueNames[P]>
  }




  export type InvUniqueNamesGroupByArgs = {
    where?: invUniqueNamesWhereInput
    orderBy?: Enumerable<invUniqueNamesOrderByWithAggregationInput>
    by: Array<InvUniqueNamesScalarFieldEnum>
    having?: invUniqueNamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvUniqueNamesCountAggregateInputType | true
    _avg?: InvUniqueNamesAvgAggregateInputType
    _sum?: InvUniqueNamesSumAggregateInputType
    _min?: InvUniqueNamesMinAggregateInputType
    _max?: InvUniqueNamesMaxAggregateInputType
  }


  export type InvUniqueNamesGroupByOutputType = {
    itemID: number
    itemName: string
    groupID: number | null
    _count: InvUniqueNamesCountAggregateOutputType | null
    _avg: InvUniqueNamesAvgAggregateOutputType | null
    _sum: InvUniqueNamesSumAggregateOutputType | null
    _min: InvUniqueNamesMinAggregateOutputType | null
    _max: InvUniqueNamesMaxAggregateOutputType | null
  }

  type GetInvUniqueNamesGroupByPayload<T extends InvUniqueNamesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvUniqueNamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvUniqueNamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvUniqueNamesGroupByOutputType[P]>
            : GetScalarType<T[P], InvUniqueNamesGroupByOutputType[P]>
        }
      >
    >


  export type invUniqueNamesSelect = {
    itemID?: boolean
    itemName?: boolean
    groupID?: boolean
  }


  export type invUniqueNamesGetPayload<S extends boolean | null | undefined | invUniqueNamesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invUniqueNames :
    S extends undefined ? never :
    S extends { include: any } & (invUniqueNamesArgs | invUniqueNamesFindManyArgs)
    ? invUniqueNames 
    : S extends { select: any } & (invUniqueNamesArgs | invUniqueNamesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invUniqueNames ? invUniqueNames[P] : never
  } 
      : invUniqueNames


  type invUniqueNamesCountArgs = Merge<
    Omit<invUniqueNamesFindManyArgs, 'select' | 'include'> & {
      select?: InvUniqueNamesCountAggregateInputType | true
    }
  >

  export interface invUniqueNamesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvUniqueNames that matches the filter.
     * @param {invUniqueNamesFindUniqueArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invUniqueNamesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invUniqueNamesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invUniqueNames'> extends True ? Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>> : Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T> | null, null>

    /**
     * Find the first InvUniqueNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindFirstArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invUniqueNamesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invUniqueNamesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invUniqueNames'> extends True ? Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>> : Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T> | null, null>

    /**
     * Find zero or more InvUniqueNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findMany()
     * 
     * // Get first 10 InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invUniqueNamesWithItemIDOnly = await prisma.invUniqueNames.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invUniqueNamesFindManyArgs>(
      args?: SelectSubset<T, invUniqueNamesFindManyArgs>
    ): PrismaPromise<Array<invUniqueNamesGetPayload<T>>>

    /**
     * Create a InvUniqueNames.
     * @param {invUniqueNamesCreateArgs} args - Arguments to create a InvUniqueNames.
     * @example
     * // Create one InvUniqueNames
     * const InvUniqueNames = await prisma.invUniqueNames.create({
     *   data: {
     *     // ... data to create a InvUniqueNames
     *   }
     * })
     * 
    **/
    create<T extends invUniqueNamesCreateArgs>(
      args: SelectSubset<T, invUniqueNamesCreateArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Create many InvUniqueNames.
     *     @param {invUniqueNamesCreateManyArgs} args - Arguments to create many InvUniqueNames.
     *     @example
     *     // Create many InvUniqueNames
     *     const invUniqueNames = await prisma.invUniqueNames.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invUniqueNamesCreateManyArgs>(
      args?: SelectSubset<T, invUniqueNamesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvUniqueNames.
     * @param {invUniqueNamesDeleteArgs} args - Arguments to delete one InvUniqueNames.
     * @example
     * // Delete one InvUniqueNames
     * const InvUniqueNames = await prisma.invUniqueNames.delete({
     *   where: {
     *     // ... filter to delete one InvUniqueNames
     *   }
     * })
     * 
    **/
    delete<T extends invUniqueNamesDeleteArgs>(
      args: SelectSubset<T, invUniqueNamesDeleteArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Update one InvUniqueNames.
     * @param {invUniqueNamesUpdateArgs} args - Arguments to update one InvUniqueNames.
     * @example
     * // Update one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invUniqueNamesUpdateArgs>(
      args: SelectSubset<T, invUniqueNamesUpdateArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Delete zero or more InvUniqueNames.
     * @param {invUniqueNamesDeleteManyArgs} args - Arguments to filter InvUniqueNames to delete.
     * @example
     * // Delete a few InvUniqueNames
     * const { count } = await prisma.invUniqueNames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invUniqueNamesDeleteManyArgs>(
      args?: SelectSubset<T, invUniqueNamesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invUniqueNamesUpdateManyArgs>(
      args: SelectSubset<T, invUniqueNamesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvUniqueNames.
     * @param {invUniqueNamesUpsertArgs} args - Arguments to update or create a InvUniqueNames.
     * @example
     * // Update or create a InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.upsert({
     *   create: {
     *     // ... data to create a InvUniqueNames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvUniqueNames we want to update
     *   }
     * })
    **/
    upsert<T extends invUniqueNamesUpsertArgs>(
      args: SelectSubset<T, invUniqueNamesUpsertArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Find one InvUniqueNames that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invUniqueNamesFindUniqueOrThrowArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invUniqueNamesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invUniqueNamesFindUniqueOrThrowArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Find the first InvUniqueNames that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindFirstOrThrowArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invUniqueNamesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invUniqueNamesFindFirstOrThrowArgs>
    ): Prisma__invUniqueNamesClient<invUniqueNamesGetPayload<T>>

    /**
     * Count the number of InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesCountArgs} args - Arguments to filter InvUniqueNames to count.
     * @example
     * // Count the number of InvUniqueNames
     * const count = await prisma.invUniqueNames.count({
     *   where: {
     *     // ... the filter for the InvUniqueNames we want to count
     *   }
     * })
    **/
    count<T extends invUniqueNamesCountArgs>(
      args?: Subset<T, invUniqueNamesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvUniqueNamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvUniqueNamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvUniqueNamesAggregateArgs>(args: Subset<T, InvUniqueNamesAggregateArgs>): PrismaPromise<GetInvUniqueNamesAggregateType<T>>

    /**
     * Group by InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvUniqueNamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvUniqueNamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvUniqueNamesGroupByArgs['orderBy'] }
        : { orderBy?: InvUniqueNamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvUniqueNamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvUniqueNamesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invUniqueNames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invUniqueNamesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invUniqueNames base type for findUnique actions
   */
  export type invUniqueNamesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * Filter, which invUniqueNames to fetch.
     * 
    **/
    where: invUniqueNamesWhereUniqueInput
  }

  /**
   * invUniqueNames: findUnique
   */
  export interface invUniqueNamesFindUniqueArgs extends invUniqueNamesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invUniqueNames base type for findFirst actions
   */
  export type invUniqueNamesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * Filter, which invUniqueNames to fetch.
     * 
    **/
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invUniqueNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invUniqueNames.
     * 
    **/
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invUniqueNames.
     * 
    **/
    distinct?: Enumerable<InvUniqueNamesScalarFieldEnum>
  }

  /**
   * invUniqueNames: findFirst
   */
  export interface invUniqueNamesFindFirstArgs extends invUniqueNamesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invUniqueNames findMany
   */
  export type invUniqueNamesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * Filter, which invUniqueNames to fetch.
     * 
    **/
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     * 
    **/
    orderBy?: Enumerable<invUniqueNamesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invUniqueNames.
     * 
    **/
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvUniqueNamesScalarFieldEnum>
  }


  /**
   * invUniqueNames create
   */
  export type invUniqueNamesCreateArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * The data needed to create a invUniqueNames.
     * 
    **/
    data: XOR<invUniqueNamesCreateInput, invUniqueNamesUncheckedCreateInput>
  }


  /**
   * invUniqueNames createMany
   */
  export type invUniqueNamesCreateManyArgs = {
    /**
     * The data used to create many invUniqueNames.
     * 
    **/
    data: Enumerable<invUniqueNamesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invUniqueNames update
   */
  export type invUniqueNamesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * The data needed to update a invUniqueNames.
     * 
    **/
    data: XOR<invUniqueNamesUpdateInput, invUniqueNamesUncheckedUpdateInput>
    /**
     * Choose, which invUniqueNames to update.
     * 
    **/
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames updateMany
   */
  export type invUniqueNamesUpdateManyArgs = {
    /**
     * The data used to update invUniqueNames.
     * 
    **/
    data: XOR<invUniqueNamesUpdateManyMutationInput, invUniqueNamesUncheckedUpdateManyInput>
    /**
     * Filter which invUniqueNames to update
     * 
    **/
    where?: invUniqueNamesWhereInput
  }


  /**
   * invUniqueNames upsert
   */
  export type invUniqueNamesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * The filter to search for the invUniqueNames to update in case it exists.
     * 
    **/
    where: invUniqueNamesWhereUniqueInput
    /**
     * In case the invUniqueNames found by the `where` argument doesn't exist, create a new invUniqueNames with this data.
     * 
    **/
    create: XOR<invUniqueNamesCreateInput, invUniqueNamesUncheckedCreateInput>
    /**
     * In case the invUniqueNames was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invUniqueNamesUpdateInput, invUniqueNamesUncheckedUpdateInput>
  }


  /**
   * invUniqueNames delete
   */
  export type invUniqueNamesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
    /**
     * Filter which invUniqueNames to delete.
     * 
    **/
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames deleteMany
   */
  export type invUniqueNamesDeleteManyArgs = {
    /**
     * Filter which invUniqueNames to delete
     * 
    **/
    where?: invUniqueNamesWhereInput
  }


  /**
   * invUniqueNames: findUniqueOrThrow
   */
  export type invUniqueNamesFindUniqueOrThrowArgs = invUniqueNamesFindUniqueArgsBase
      

  /**
   * invUniqueNames: findFirstOrThrow
   */
  export type invUniqueNamesFindFirstOrThrowArgs = invUniqueNamesFindFirstArgsBase
      

  /**
   * invUniqueNames without action
   */
  export type invUniqueNamesArgs = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     * 
    **/
    select?: invUniqueNamesSelect | null
  }



  /**
   * Model invVolumes
   */


  export type AggregateInvVolumes = {
    _count: InvVolumesCountAggregateOutputType | null
    _avg: InvVolumesAvgAggregateOutputType | null
    _sum: InvVolumesSumAggregateOutputType | null
    _min: InvVolumesMinAggregateOutputType | null
    _max: InvVolumesMaxAggregateOutputType | null
  }

  export type InvVolumesAvgAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesSumAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesMinAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesMaxAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesCountAggregateOutputType = {
    typeID: number
    volume: number
    _all: number
  }


  export type InvVolumesAvgAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesSumAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesMinAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesMaxAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesCountAggregateInputType = {
    typeID?: true
    volume?: true
    _all?: true
  }

  export type InvVolumesAggregateArgs = {
    /**
     * Filter which invVolumes to aggregate.
     * 
    **/
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     * 
    **/
    orderBy?: Enumerable<invVolumesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invVolumes
    **/
    _count?: true | InvVolumesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvVolumesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvVolumesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvVolumesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvVolumesMaxAggregateInputType
  }

  export type GetInvVolumesAggregateType<T extends InvVolumesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvVolumes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvVolumes[P]>
      : GetScalarType<T[P], AggregateInvVolumes[P]>
  }




  export type InvVolumesGroupByArgs = {
    where?: invVolumesWhereInput
    orderBy?: Enumerable<invVolumesOrderByWithAggregationInput>
    by: Array<InvVolumesScalarFieldEnum>
    having?: invVolumesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvVolumesCountAggregateInputType | true
    _avg?: InvVolumesAvgAggregateInputType
    _sum?: InvVolumesSumAggregateInputType
    _min?: InvVolumesMinAggregateInputType
    _max?: InvVolumesMaxAggregateInputType
  }


  export type InvVolumesGroupByOutputType = {
    typeID: number
    volume: number | null
    _count: InvVolumesCountAggregateOutputType | null
    _avg: InvVolumesAvgAggregateOutputType | null
    _sum: InvVolumesSumAggregateOutputType | null
    _min: InvVolumesMinAggregateOutputType | null
    _max: InvVolumesMaxAggregateOutputType | null
  }

  type GetInvVolumesGroupByPayload<T extends InvVolumesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvVolumesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvVolumesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvVolumesGroupByOutputType[P]>
            : GetScalarType<T[P], InvVolumesGroupByOutputType[P]>
        }
      >
    >


  export type invVolumesSelect = {
    typeID?: boolean
    volume?: boolean
  }


  export type invVolumesGetPayload<S extends boolean | null | undefined | invVolumesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? invVolumes :
    S extends undefined ? never :
    S extends { include: any } & (invVolumesArgs | invVolumesFindManyArgs)
    ? invVolumes 
    : S extends { select: any } & (invVolumesArgs | invVolumesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof invVolumes ? invVolumes[P] : never
  } 
      : invVolumes


  type invVolumesCountArgs = Merge<
    Omit<invVolumesFindManyArgs, 'select' | 'include'> & {
      select?: InvVolumesCountAggregateInputType | true
    }
  >

  export interface invVolumesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InvVolumes that matches the filter.
     * @param {invVolumesFindUniqueArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invVolumesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, invVolumesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'invVolumes'> extends True ? Prisma__invVolumesClient<invVolumesGetPayload<T>> : Prisma__invVolumesClient<invVolumesGetPayload<T> | null, null>

    /**
     * Find the first InvVolumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindFirstArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invVolumesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, invVolumesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'invVolumes'> extends True ? Prisma__invVolumesClient<invVolumesGetPayload<T>> : Prisma__invVolumesClient<invVolumesGetPayload<T> | null, null>

    /**
     * Find zero or more InvVolumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvVolumes
     * const invVolumes = await prisma.invVolumes.findMany()
     * 
     * // Get first 10 InvVolumes
     * const invVolumes = await prisma.invVolumes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invVolumesWithTypeIDOnly = await prisma.invVolumes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invVolumesFindManyArgs>(
      args?: SelectSubset<T, invVolumesFindManyArgs>
    ): PrismaPromise<Array<invVolumesGetPayload<T>>>

    /**
     * Create a InvVolumes.
     * @param {invVolumesCreateArgs} args - Arguments to create a InvVolumes.
     * @example
     * // Create one InvVolumes
     * const InvVolumes = await prisma.invVolumes.create({
     *   data: {
     *     // ... data to create a InvVolumes
     *   }
     * })
     * 
    **/
    create<T extends invVolumesCreateArgs>(
      args: SelectSubset<T, invVolumesCreateArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Create many InvVolumes.
     *     @param {invVolumesCreateManyArgs} args - Arguments to create many InvVolumes.
     *     @example
     *     // Create many InvVolumes
     *     const invVolumes = await prisma.invVolumes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invVolumesCreateManyArgs>(
      args?: SelectSubset<T, invVolumesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvVolumes.
     * @param {invVolumesDeleteArgs} args - Arguments to delete one InvVolumes.
     * @example
     * // Delete one InvVolumes
     * const InvVolumes = await prisma.invVolumes.delete({
     *   where: {
     *     // ... filter to delete one InvVolumes
     *   }
     * })
     * 
    **/
    delete<T extends invVolumesDeleteArgs>(
      args: SelectSubset<T, invVolumesDeleteArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Update one InvVolumes.
     * @param {invVolumesUpdateArgs} args - Arguments to update one InvVolumes.
     * @example
     * // Update one InvVolumes
     * const invVolumes = await prisma.invVolumes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invVolumesUpdateArgs>(
      args: SelectSubset<T, invVolumesUpdateArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Delete zero or more InvVolumes.
     * @param {invVolumesDeleteManyArgs} args - Arguments to filter InvVolumes to delete.
     * @example
     * // Delete a few InvVolumes
     * const { count } = await prisma.invVolumes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invVolumesDeleteManyArgs>(
      args?: SelectSubset<T, invVolumesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvVolumes
     * const invVolumes = await prisma.invVolumes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invVolumesUpdateManyArgs>(
      args: SelectSubset<T, invVolumesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvVolumes.
     * @param {invVolumesUpsertArgs} args - Arguments to update or create a InvVolumes.
     * @example
     * // Update or create a InvVolumes
     * const invVolumes = await prisma.invVolumes.upsert({
     *   create: {
     *     // ... data to create a InvVolumes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvVolumes we want to update
     *   }
     * })
    **/
    upsert<T extends invVolumesUpsertArgs>(
      args: SelectSubset<T, invVolumesUpsertArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Find one InvVolumes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {invVolumesFindUniqueOrThrowArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invVolumesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, invVolumesFindUniqueOrThrowArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Find the first InvVolumes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindFirstOrThrowArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invVolumesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, invVolumesFindFirstOrThrowArgs>
    ): Prisma__invVolumesClient<invVolumesGetPayload<T>>

    /**
     * Count the number of InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesCountArgs} args - Arguments to filter InvVolumes to count.
     * @example
     * // Count the number of InvVolumes
     * const count = await prisma.invVolumes.count({
     *   where: {
     *     // ... the filter for the InvVolumes we want to count
     *   }
     * })
    **/
    count<T extends invVolumesCountArgs>(
      args?: Subset<T, invVolumesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvVolumesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvVolumesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvVolumesAggregateArgs>(args: Subset<T, InvVolumesAggregateArgs>): PrismaPromise<GetInvVolumesAggregateType<T>>

    /**
     * Group by InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvVolumesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvVolumesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvVolumesGroupByArgs['orderBy'] }
        : { orderBy?: InvVolumesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvVolumesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvVolumesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for invVolumes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invVolumesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * invVolumes base type for findUnique actions
   */
  export type invVolumesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * Filter, which invVolumes to fetch.
     * 
    **/
    where: invVolumesWhereUniqueInput
  }

  /**
   * invVolumes: findUnique
   */
  export interface invVolumesFindUniqueArgs extends invVolumesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invVolumes base type for findFirst actions
   */
  export type invVolumesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * Filter, which invVolumes to fetch.
     * 
    **/
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     * 
    **/
    orderBy?: Enumerable<invVolumesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invVolumes.
     * 
    **/
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invVolumes.
     * 
    **/
    distinct?: Enumerable<InvVolumesScalarFieldEnum>
  }

  /**
   * invVolumes: findFirst
   */
  export interface invVolumesFindFirstArgs extends invVolumesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * invVolumes findMany
   */
  export type invVolumesFindManyArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * Filter, which invVolumes to fetch.
     * 
    **/
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     * 
    **/
    orderBy?: Enumerable<invVolumesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invVolumes.
     * 
    **/
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvVolumesScalarFieldEnum>
  }


  /**
   * invVolumes create
   */
  export type invVolumesCreateArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * The data needed to create a invVolumes.
     * 
    **/
    data: XOR<invVolumesCreateInput, invVolumesUncheckedCreateInput>
  }


  /**
   * invVolumes createMany
   */
  export type invVolumesCreateManyArgs = {
    /**
     * The data used to create many invVolumes.
     * 
    **/
    data: Enumerable<invVolumesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * invVolumes update
   */
  export type invVolumesUpdateArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * The data needed to update a invVolumes.
     * 
    **/
    data: XOR<invVolumesUpdateInput, invVolumesUncheckedUpdateInput>
    /**
     * Choose, which invVolumes to update.
     * 
    **/
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes updateMany
   */
  export type invVolumesUpdateManyArgs = {
    /**
     * The data used to update invVolumes.
     * 
    **/
    data: XOR<invVolumesUpdateManyMutationInput, invVolumesUncheckedUpdateManyInput>
    /**
     * Filter which invVolumes to update
     * 
    **/
    where?: invVolumesWhereInput
  }


  /**
   * invVolumes upsert
   */
  export type invVolumesUpsertArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * The filter to search for the invVolumes to update in case it exists.
     * 
    **/
    where: invVolumesWhereUniqueInput
    /**
     * In case the invVolumes found by the `where` argument doesn't exist, create a new invVolumes with this data.
     * 
    **/
    create: XOR<invVolumesCreateInput, invVolumesUncheckedCreateInput>
    /**
     * In case the invVolumes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<invVolumesUpdateInput, invVolumesUncheckedUpdateInput>
  }


  /**
   * invVolumes delete
   */
  export type invVolumesDeleteArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
    /**
     * Filter which invVolumes to delete.
     * 
    **/
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes deleteMany
   */
  export type invVolumesDeleteManyArgs = {
    /**
     * Filter which invVolumes to delete
     * 
    **/
    where?: invVolumesWhereInput
  }


  /**
   * invVolumes: findUniqueOrThrow
   */
  export type invVolumesFindUniqueOrThrowArgs = invVolumesFindUniqueArgsBase
      

  /**
   * invVolumes: findFirstOrThrow
   */
  export type invVolumesFindFirstOrThrowArgs = invVolumesFindFirstArgsBase
      

  /**
   * invVolumes without action
   */
  export type invVolumesArgs = {
    /**
     * Select specific fields to fetch from the invVolumes
     * 
    **/
    select?: invVolumesSelect | null
  }



  /**
   * Model mapCelestialGraphics
   */


  export type AggregateMapCelestialGraphics = {
    _count: MapCelestialGraphicsCountAggregateOutputType | null
    _avg: MapCelestialGraphicsAvgAggregateOutputType | null
    _sum: MapCelestialGraphicsSumAggregateOutputType | null
    _min: MapCelestialGraphicsMinAggregateOutputType | null
    _max: MapCelestialGraphicsMaxAggregateOutputType | null
  }

  export type MapCelestialGraphicsAvgAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
  }

  export type MapCelestialGraphicsSumAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
  }

  export type MapCelestialGraphicsMinAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
  }

  export type MapCelestialGraphicsMaxAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
  }

  export type MapCelestialGraphicsCountAggregateOutputType = {
    celestialID: number
    heightMap1: number
    heightMap2: number
    shaderPreset: number
    population: number
    _all: number
  }


  export type MapCelestialGraphicsAvgAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
  }

  export type MapCelestialGraphicsSumAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
  }

  export type MapCelestialGraphicsMinAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
  }

  export type MapCelestialGraphicsMaxAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
  }

  export type MapCelestialGraphicsCountAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
    _all?: true
  }

  export type MapCelestialGraphicsAggregateArgs = {
    /**
     * Filter which mapCelestialGraphics to aggregate.
     * 
    **/
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapCelestialGraphics
    **/
    _count?: true | MapCelestialGraphicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapCelestialGraphicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapCelestialGraphicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapCelestialGraphicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapCelestialGraphicsMaxAggregateInputType
  }

  export type GetMapCelestialGraphicsAggregateType<T extends MapCelestialGraphicsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapCelestialGraphics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapCelestialGraphics[P]>
      : GetScalarType<T[P], AggregateMapCelestialGraphics[P]>
  }




  export type MapCelestialGraphicsGroupByArgs = {
    where?: mapCelestialGraphicsWhereInput
    orderBy?: Enumerable<mapCelestialGraphicsOrderByWithAggregationInput>
    by: Array<MapCelestialGraphicsScalarFieldEnum>
    having?: mapCelestialGraphicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCelestialGraphicsCountAggregateInputType | true
    _avg?: MapCelestialGraphicsAvgAggregateInputType
    _sum?: MapCelestialGraphicsSumAggregateInputType
    _min?: MapCelestialGraphicsMinAggregateInputType
    _max?: MapCelestialGraphicsMaxAggregateInputType
  }


  export type MapCelestialGraphicsGroupByOutputType = {
    celestialID: number
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
    _count: MapCelestialGraphicsCountAggregateOutputType | null
    _avg: MapCelestialGraphicsAvgAggregateOutputType | null
    _sum: MapCelestialGraphicsSumAggregateOutputType | null
    _min: MapCelestialGraphicsMinAggregateOutputType | null
    _max: MapCelestialGraphicsMaxAggregateOutputType | null
  }

  type GetMapCelestialGraphicsGroupByPayload<T extends MapCelestialGraphicsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapCelestialGraphicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapCelestialGraphicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapCelestialGraphicsGroupByOutputType[P]>
            : GetScalarType<T[P], MapCelestialGraphicsGroupByOutputType[P]>
        }
      >
    >


  export type mapCelestialGraphicsSelect = {
    celestialID?: boolean
    heightMap1?: boolean
    heightMap2?: boolean
    shaderPreset?: boolean
    population?: boolean
  }


  export type mapCelestialGraphicsGetPayload<S extends boolean | null | undefined | mapCelestialGraphicsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapCelestialGraphics :
    S extends undefined ? never :
    S extends { include: any } & (mapCelestialGraphicsArgs | mapCelestialGraphicsFindManyArgs)
    ? mapCelestialGraphics 
    : S extends { select: any } & (mapCelestialGraphicsArgs | mapCelestialGraphicsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapCelestialGraphics ? mapCelestialGraphics[P] : never
  } 
      : mapCelestialGraphics


  type mapCelestialGraphicsCountArgs = Merge<
    Omit<mapCelestialGraphicsFindManyArgs, 'select' | 'include'> & {
      select?: MapCelestialGraphicsCountAggregateInputType | true
    }
  >

  export interface mapCelestialGraphicsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapCelestialGraphics that matches the filter.
     * @param {mapCelestialGraphicsFindUniqueArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapCelestialGraphicsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapCelestialGraphicsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapCelestialGraphics'> extends True ? Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>> : Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T> | null, null>

    /**
     * Find the first MapCelestialGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindFirstArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapCelestialGraphicsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapCelestialGraphicsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapCelestialGraphics'> extends True ? Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>> : Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T> | null, null>

    /**
     * Find zero or more MapCelestialGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany()
     * 
     * // Get first 10 MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany({ take: 10 })
     * 
     * // Only select the `celestialID`
     * const mapCelestialGraphicsWithCelestialIDOnly = await prisma.mapCelestialGraphics.findMany({ select: { celestialID: true } })
     * 
    **/
    findMany<T extends mapCelestialGraphicsFindManyArgs>(
      args?: SelectSubset<T, mapCelestialGraphicsFindManyArgs>
    ): PrismaPromise<Array<mapCelestialGraphicsGetPayload<T>>>

    /**
     * Create a MapCelestialGraphics.
     * @param {mapCelestialGraphicsCreateArgs} args - Arguments to create a MapCelestialGraphics.
     * @example
     * // Create one MapCelestialGraphics
     * const MapCelestialGraphics = await prisma.mapCelestialGraphics.create({
     *   data: {
     *     // ... data to create a MapCelestialGraphics
     *   }
     * })
     * 
    **/
    create<T extends mapCelestialGraphicsCreateArgs>(
      args: SelectSubset<T, mapCelestialGraphicsCreateArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Create many MapCelestialGraphics.
     *     @param {mapCelestialGraphicsCreateManyArgs} args - Arguments to create many MapCelestialGraphics.
     *     @example
     *     // Create many MapCelestialGraphics
     *     const mapCelestialGraphics = await prisma.mapCelestialGraphics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapCelestialGraphicsCreateManyArgs>(
      args?: SelectSubset<T, mapCelestialGraphicsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapCelestialGraphics.
     * @param {mapCelestialGraphicsDeleteArgs} args - Arguments to delete one MapCelestialGraphics.
     * @example
     * // Delete one MapCelestialGraphics
     * const MapCelestialGraphics = await prisma.mapCelestialGraphics.delete({
     *   where: {
     *     // ... filter to delete one MapCelestialGraphics
     *   }
     * })
     * 
    **/
    delete<T extends mapCelestialGraphicsDeleteArgs>(
      args: SelectSubset<T, mapCelestialGraphicsDeleteArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Update one MapCelestialGraphics.
     * @param {mapCelestialGraphicsUpdateArgs} args - Arguments to update one MapCelestialGraphics.
     * @example
     * // Update one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapCelestialGraphicsUpdateArgs>(
      args: SelectSubset<T, mapCelestialGraphicsUpdateArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Delete zero or more MapCelestialGraphics.
     * @param {mapCelestialGraphicsDeleteManyArgs} args - Arguments to filter MapCelestialGraphics to delete.
     * @example
     * // Delete a few MapCelestialGraphics
     * const { count } = await prisma.mapCelestialGraphics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapCelestialGraphicsDeleteManyArgs>(
      args?: SelectSubset<T, mapCelestialGraphicsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapCelestialGraphicsUpdateManyArgs>(
      args: SelectSubset<T, mapCelestialGraphicsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapCelestialGraphics.
     * @param {mapCelestialGraphicsUpsertArgs} args - Arguments to update or create a MapCelestialGraphics.
     * @example
     * // Update or create a MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.upsert({
     *   create: {
     *     // ... data to create a MapCelestialGraphics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapCelestialGraphics we want to update
     *   }
     * })
    **/
    upsert<T extends mapCelestialGraphicsUpsertArgs>(
      args: SelectSubset<T, mapCelestialGraphicsUpsertArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Find one MapCelestialGraphics that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapCelestialGraphicsFindUniqueOrThrowArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapCelestialGraphicsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapCelestialGraphicsFindUniqueOrThrowArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Find the first MapCelestialGraphics that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindFirstOrThrowArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapCelestialGraphicsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapCelestialGraphicsFindFirstOrThrowArgs>
    ): Prisma__mapCelestialGraphicsClient<mapCelestialGraphicsGetPayload<T>>

    /**
     * Count the number of MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsCountArgs} args - Arguments to filter MapCelestialGraphics to count.
     * @example
     * // Count the number of MapCelestialGraphics
     * const count = await prisma.mapCelestialGraphics.count({
     *   where: {
     *     // ... the filter for the MapCelestialGraphics we want to count
     *   }
     * })
    **/
    count<T extends mapCelestialGraphicsCountArgs>(
      args?: Subset<T, mapCelestialGraphicsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCelestialGraphicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialGraphicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapCelestialGraphicsAggregateArgs>(args: Subset<T, MapCelestialGraphicsAggregateArgs>): PrismaPromise<GetMapCelestialGraphicsAggregateType<T>>

    /**
     * Group by MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialGraphicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapCelestialGraphicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapCelestialGraphicsGroupByArgs['orderBy'] }
        : { orderBy?: MapCelestialGraphicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapCelestialGraphicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapCelestialGraphicsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapCelestialGraphics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapCelestialGraphicsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapCelestialGraphics base type for findUnique actions
   */
  export type mapCelestialGraphicsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     * 
    **/
    where: mapCelestialGraphicsWhereUniqueInput
  }

  /**
   * mapCelestialGraphics: findUnique
   */
  export interface mapCelestialGraphicsFindUniqueArgs extends mapCelestialGraphicsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapCelestialGraphics base type for findFirst actions
   */
  export type mapCelestialGraphicsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     * 
    **/
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialGraphics.
     * 
    **/
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialGraphics.
     * 
    **/
    distinct?: Enumerable<MapCelestialGraphicsScalarFieldEnum>
  }

  /**
   * mapCelestialGraphics: findFirst
   */
  export interface mapCelestialGraphicsFindFirstArgs extends mapCelestialGraphicsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapCelestialGraphics findMany
   */
  export type mapCelestialGraphicsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     * 
    **/
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialGraphicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapCelestialGraphics.
     * 
    **/
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapCelestialGraphicsScalarFieldEnum>
  }


  /**
   * mapCelestialGraphics create
   */
  export type mapCelestialGraphicsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * The data needed to create a mapCelestialGraphics.
     * 
    **/
    data: XOR<mapCelestialGraphicsCreateInput, mapCelestialGraphicsUncheckedCreateInput>
  }


  /**
   * mapCelestialGraphics createMany
   */
  export type mapCelestialGraphicsCreateManyArgs = {
    /**
     * The data used to create many mapCelestialGraphics.
     * 
    **/
    data: Enumerable<mapCelestialGraphicsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapCelestialGraphics update
   */
  export type mapCelestialGraphicsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * The data needed to update a mapCelestialGraphics.
     * 
    **/
    data: XOR<mapCelestialGraphicsUpdateInput, mapCelestialGraphicsUncheckedUpdateInput>
    /**
     * Choose, which mapCelestialGraphics to update.
     * 
    **/
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics updateMany
   */
  export type mapCelestialGraphicsUpdateManyArgs = {
    /**
     * The data used to update mapCelestialGraphics.
     * 
    **/
    data: XOR<mapCelestialGraphicsUpdateManyMutationInput, mapCelestialGraphicsUncheckedUpdateManyInput>
    /**
     * Filter which mapCelestialGraphics to update
     * 
    **/
    where?: mapCelestialGraphicsWhereInput
  }


  /**
   * mapCelestialGraphics upsert
   */
  export type mapCelestialGraphicsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * The filter to search for the mapCelestialGraphics to update in case it exists.
     * 
    **/
    where: mapCelestialGraphicsWhereUniqueInput
    /**
     * In case the mapCelestialGraphics found by the `where` argument doesn't exist, create a new mapCelestialGraphics with this data.
     * 
    **/
    create: XOR<mapCelestialGraphicsCreateInput, mapCelestialGraphicsUncheckedCreateInput>
    /**
     * In case the mapCelestialGraphics was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapCelestialGraphicsUpdateInput, mapCelestialGraphicsUncheckedUpdateInput>
  }


  /**
   * mapCelestialGraphics delete
   */
  export type mapCelestialGraphicsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
    /**
     * Filter which mapCelestialGraphics to delete.
     * 
    **/
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics deleteMany
   */
  export type mapCelestialGraphicsDeleteManyArgs = {
    /**
     * Filter which mapCelestialGraphics to delete
     * 
    **/
    where?: mapCelestialGraphicsWhereInput
  }


  /**
   * mapCelestialGraphics: findUniqueOrThrow
   */
  export type mapCelestialGraphicsFindUniqueOrThrowArgs = mapCelestialGraphicsFindUniqueArgsBase
      

  /**
   * mapCelestialGraphics: findFirstOrThrow
   */
  export type mapCelestialGraphicsFindFirstOrThrowArgs = mapCelestialGraphicsFindFirstArgsBase
      

  /**
   * mapCelestialGraphics without action
   */
  export type mapCelestialGraphicsArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     * 
    **/
    select?: mapCelestialGraphicsSelect | null
  }



  /**
   * Model mapCelestialStatistics
   */


  export type AggregateMapCelestialStatistics = {
    _count: MapCelestialStatisticsCountAggregateOutputType | null
    _avg: MapCelestialStatisticsAvgAggregateOutputType | null
    _sum: MapCelestialStatisticsSumAggregateOutputType | null
    _min: MapCelestialStatisticsMinAggregateOutputType | null
    _max: MapCelestialStatisticsMaxAggregateOutputType | null
  }

  export type MapCelestialStatisticsAvgAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsSumAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsMinAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsMaxAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsCountAggregateOutputType = {
    celestialID: number
    temperature: number
    spectralClass: number
    luminosity: number
    age: number
    life: number
    orbitRadius: number
    eccentricity: number
    massDust: number
    massGas: number
    fragmented: number
    density: number
    surfaceGravity: number
    escapeVelocity: number
    orbitPeriod: number
    rotationRate: number
    locked: number
    pressure: number
    radius: number
    mass: number
    _all: number
  }


  export type MapCelestialStatisticsAvgAggregateInputType = {
    celestialID?: true
    temperature?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsSumAggregateInputType = {
    celestialID?: true
    temperature?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsMinAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsMaxAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsCountAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
    _all?: true
  }

  export type MapCelestialStatisticsAggregateArgs = {
    /**
     * Filter which mapCelestialStatistics to aggregate.
     * 
    **/
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialStatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapCelestialStatistics
    **/
    _count?: true | MapCelestialStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapCelestialStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapCelestialStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapCelestialStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapCelestialStatisticsMaxAggregateInputType
  }

  export type GetMapCelestialStatisticsAggregateType<T extends MapCelestialStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapCelestialStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapCelestialStatistics[P]>
      : GetScalarType<T[P], AggregateMapCelestialStatistics[P]>
  }




  export type MapCelestialStatisticsGroupByArgs = {
    where?: mapCelestialStatisticsWhereInput
    orderBy?: Enumerable<mapCelestialStatisticsOrderByWithAggregationInput>
    by: Array<MapCelestialStatisticsScalarFieldEnum>
    having?: mapCelestialStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCelestialStatisticsCountAggregateInputType | true
    _avg?: MapCelestialStatisticsAvgAggregateInputType
    _sum?: MapCelestialStatisticsSumAggregateInputType
    _min?: MapCelestialStatisticsMinAggregateInputType
    _max?: MapCelestialStatisticsMaxAggregateInputType
  }


  export type MapCelestialStatisticsGroupByOutputType = {
    celestialID: number
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
    _count: MapCelestialStatisticsCountAggregateOutputType | null
    _avg: MapCelestialStatisticsAvgAggregateOutputType | null
    _sum: MapCelestialStatisticsSumAggregateOutputType | null
    _min: MapCelestialStatisticsMinAggregateOutputType | null
    _max: MapCelestialStatisticsMaxAggregateOutputType | null
  }

  type GetMapCelestialStatisticsGroupByPayload<T extends MapCelestialStatisticsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapCelestialStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapCelestialStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapCelestialStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], MapCelestialStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type mapCelestialStatisticsSelect = {
    celestialID?: boolean
    temperature?: boolean
    spectralClass?: boolean
    luminosity?: boolean
    age?: boolean
    life?: boolean
    orbitRadius?: boolean
    eccentricity?: boolean
    massDust?: boolean
    massGas?: boolean
    fragmented?: boolean
    density?: boolean
    surfaceGravity?: boolean
    escapeVelocity?: boolean
    orbitPeriod?: boolean
    rotationRate?: boolean
    locked?: boolean
    pressure?: boolean
    radius?: boolean
    mass?: boolean
  }


  export type mapCelestialStatisticsGetPayload<S extends boolean | null | undefined | mapCelestialStatisticsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapCelestialStatistics :
    S extends undefined ? never :
    S extends { include: any } & (mapCelestialStatisticsArgs | mapCelestialStatisticsFindManyArgs)
    ? mapCelestialStatistics 
    : S extends { select: any } & (mapCelestialStatisticsArgs | mapCelestialStatisticsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapCelestialStatistics ? mapCelestialStatistics[P] : never
  } 
      : mapCelestialStatistics


  type mapCelestialStatisticsCountArgs = Merge<
    Omit<mapCelestialStatisticsFindManyArgs, 'select' | 'include'> & {
      select?: MapCelestialStatisticsCountAggregateInputType | true
    }
  >

  export interface mapCelestialStatisticsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapCelestialStatistics that matches the filter.
     * @param {mapCelestialStatisticsFindUniqueArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapCelestialStatisticsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapCelestialStatisticsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapCelestialStatistics'> extends True ? Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>> : Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T> | null, null>

    /**
     * Find the first MapCelestialStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindFirstArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapCelestialStatisticsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapCelestialStatisticsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapCelestialStatistics'> extends True ? Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>> : Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T> | null, null>

    /**
     * Find zero or more MapCelestialStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany()
     * 
     * // Get first 10 MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany({ take: 10 })
     * 
     * // Only select the `celestialID`
     * const mapCelestialStatisticsWithCelestialIDOnly = await prisma.mapCelestialStatistics.findMany({ select: { celestialID: true } })
     * 
    **/
    findMany<T extends mapCelestialStatisticsFindManyArgs>(
      args?: SelectSubset<T, mapCelestialStatisticsFindManyArgs>
    ): PrismaPromise<Array<mapCelestialStatisticsGetPayload<T>>>

    /**
     * Create a MapCelestialStatistics.
     * @param {mapCelestialStatisticsCreateArgs} args - Arguments to create a MapCelestialStatistics.
     * @example
     * // Create one MapCelestialStatistics
     * const MapCelestialStatistics = await prisma.mapCelestialStatistics.create({
     *   data: {
     *     // ... data to create a MapCelestialStatistics
     *   }
     * })
     * 
    **/
    create<T extends mapCelestialStatisticsCreateArgs>(
      args: SelectSubset<T, mapCelestialStatisticsCreateArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Create many MapCelestialStatistics.
     *     @param {mapCelestialStatisticsCreateManyArgs} args - Arguments to create many MapCelestialStatistics.
     *     @example
     *     // Create many MapCelestialStatistics
     *     const mapCelestialStatistics = await prisma.mapCelestialStatistics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapCelestialStatisticsCreateManyArgs>(
      args?: SelectSubset<T, mapCelestialStatisticsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapCelestialStatistics.
     * @param {mapCelestialStatisticsDeleteArgs} args - Arguments to delete one MapCelestialStatistics.
     * @example
     * // Delete one MapCelestialStatistics
     * const MapCelestialStatistics = await prisma.mapCelestialStatistics.delete({
     *   where: {
     *     // ... filter to delete one MapCelestialStatistics
     *   }
     * })
     * 
    **/
    delete<T extends mapCelestialStatisticsDeleteArgs>(
      args: SelectSubset<T, mapCelestialStatisticsDeleteArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Update one MapCelestialStatistics.
     * @param {mapCelestialStatisticsUpdateArgs} args - Arguments to update one MapCelestialStatistics.
     * @example
     * // Update one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapCelestialStatisticsUpdateArgs>(
      args: SelectSubset<T, mapCelestialStatisticsUpdateArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Delete zero or more MapCelestialStatistics.
     * @param {mapCelestialStatisticsDeleteManyArgs} args - Arguments to filter MapCelestialStatistics to delete.
     * @example
     * // Delete a few MapCelestialStatistics
     * const { count } = await prisma.mapCelestialStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapCelestialStatisticsDeleteManyArgs>(
      args?: SelectSubset<T, mapCelestialStatisticsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapCelestialStatisticsUpdateManyArgs>(
      args: SelectSubset<T, mapCelestialStatisticsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapCelestialStatistics.
     * @param {mapCelestialStatisticsUpsertArgs} args - Arguments to update or create a MapCelestialStatistics.
     * @example
     * // Update or create a MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.upsert({
     *   create: {
     *     // ... data to create a MapCelestialStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapCelestialStatistics we want to update
     *   }
     * })
    **/
    upsert<T extends mapCelestialStatisticsUpsertArgs>(
      args: SelectSubset<T, mapCelestialStatisticsUpsertArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Find one MapCelestialStatistics that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapCelestialStatisticsFindUniqueOrThrowArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapCelestialStatisticsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapCelestialStatisticsFindUniqueOrThrowArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Find the first MapCelestialStatistics that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindFirstOrThrowArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapCelestialStatisticsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapCelestialStatisticsFindFirstOrThrowArgs>
    ): Prisma__mapCelestialStatisticsClient<mapCelestialStatisticsGetPayload<T>>

    /**
     * Count the number of MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsCountArgs} args - Arguments to filter MapCelestialStatistics to count.
     * @example
     * // Count the number of MapCelestialStatistics
     * const count = await prisma.mapCelestialStatistics.count({
     *   where: {
     *     // ... the filter for the MapCelestialStatistics we want to count
     *   }
     * })
    **/
    count<T extends mapCelestialStatisticsCountArgs>(
      args?: Subset<T, mapCelestialStatisticsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCelestialStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapCelestialStatisticsAggregateArgs>(args: Subset<T, MapCelestialStatisticsAggregateArgs>): PrismaPromise<GetMapCelestialStatisticsAggregateType<T>>

    /**
     * Group by MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapCelestialStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapCelestialStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: MapCelestialStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapCelestialStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapCelestialStatisticsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapCelestialStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapCelestialStatisticsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapCelestialStatistics base type for findUnique actions
   */
  export type mapCelestialStatisticsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     * 
    **/
    where: mapCelestialStatisticsWhereUniqueInput
  }

  /**
   * mapCelestialStatistics: findUnique
   */
  export interface mapCelestialStatisticsFindUniqueArgs extends mapCelestialStatisticsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapCelestialStatistics base type for findFirst actions
   */
  export type mapCelestialStatisticsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     * 
    **/
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialStatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialStatistics.
     * 
    **/
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialStatistics.
     * 
    **/
    distinct?: Enumerable<MapCelestialStatisticsScalarFieldEnum>
  }

  /**
   * mapCelestialStatistics: findFirst
   */
  export interface mapCelestialStatisticsFindFirstArgs extends mapCelestialStatisticsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapCelestialStatistics findMany
   */
  export type mapCelestialStatisticsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     * 
    **/
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<mapCelestialStatisticsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapCelestialStatistics.
     * 
    **/
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapCelestialStatisticsScalarFieldEnum>
  }


  /**
   * mapCelestialStatistics create
   */
  export type mapCelestialStatisticsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * The data needed to create a mapCelestialStatistics.
     * 
    **/
    data: XOR<mapCelestialStatisticsCreateInput, mapCelestialStatisticsUncheckedCreateInput>
  }


  /**
   * mapCelestialStatistics createMany
   */
  export type mapCelestialStatisticsCreateManyArgs = {
    /**
     * The data used to create many mapCelestialStatistics.
     * 
    **/
    data: Enumerable<mapCelestialStatisticsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapCelestialStatistics update
   */
  export type mapCelestialStatisticsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * The data needed to update a mapCelestialStatistics.
     * 
    **/
    data: XOR<mapCelestialStatisticsUpdateInput, mapCelestialStatisticsUncheckedUpdateInput>
    /**
     * Choose, which mapCelestialStatistics to update.
     * 
    **/
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics updateMany
   */
  export type mapCelestialStatisticsUpdateManyArgs = {
    /**
     * The data used to update mapCelestialStatistics.
     * 
    **/
    data: XOR<mapCelestialStatisticsUpdateManyMutationInput, mapCelestialStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which mapCelestialStatistics to update
     * 
    **/
    where?: mapCelestialStatisticsWhereInput
  }


  /**
   * mapCelestialStatistics upsert
   */
  export type mapCelestialStatisticsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * The filter to search for the mapCelestialStatistics to update in case it exists.
     * 
    **/
    where: mapCelestialStatisticsWhereUniqueInput
    /**
     * In case the mapCelestialStatistics found by the `where` argument doesn't exist, create a new mapCelestialStatistics with this data.
     * 
    **/
    create: XOR<mapCelestialStatisticsCreateInput, mapCelestialStatisticsUncheckedCreateInput>
    /**
     * In case the mapCelestialStatistics was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapCelestialStatisticsUpdateInput, mapCelestialStatisticsUncheckedUpdateInput>
  }


  /**
   * mapCelestialStatistics delete
   */
  export type mapCelestialStatisticsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
    /**
     * Filter which mapCelestialStatistics to delete.
     * 
    **/
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics deleteMany
   */
  export type mapCelestialStatisticsDeleteManyArgs = {
    /**
     * Filter which mapCelestialStatistics to delete
     * 
    **/
    where?: mapCelestialStatisticsWhereInput
  }


  /**
   * mapCelestialStatistics: findUniqueOrThrow
   */
  export type mapCelestialStatisticsFindUniqueOrThrowArgs = mapCelestialStatisticsFindUniqueArgsBase
      

  /**
   * mapCelestialStatistics: findFirstOrThrow
   */
  export type mapCelestialStatisticsFindFirstOrThrowArgs = mapCelestialStatisticsFindFirstArgsBase
      

  /**
   * mapCelestialStatistics without action
   */
  export type mapCelestialStatisticsArgs = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     * 
    **/
    select?: mapCelestialStatisticsSelect | null
  }



  /**
   * Model mapConstellationJumps
   */


  export type AggregateMapConstellationJumps = {
    _count: MapConstellationJumpsCountAggregateOutputType | null
    _avg: MapConstellationJumpsAvgAggregateOutputType | null
    _sum: MapConstellationJumpsSumAggregateOutputType | null
    _min: MapConstellationJumpsMinAggregateOutputType | null
    _max: MapConstellationJumpsMaxAggregateOutputType | null
  }

  export type MapConstellationJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsCountAggregateOutputType = {
    fromRegionID: number
    fromConstellationID: number
    toConstellationID: number
    toRegionID: number
    _all: number
  }


  export type MapConstellationJumpsAvgAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsSumAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsMinAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsMaxAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsCountAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapConstellationJumpsAggregateArgs = {
    /**
     * Filter which mapConstellationJumps to aggregate.
     * 
    **/
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapConstellationJumps
    **/
    _count?: true | MapConstellationJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapConstellationJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapConstellationJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapConstellationJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapConstellationJumpsMaxAggregateInputType
  }

  export type GetMapConstellationJumpsAggregateType<T extends MapConstellationJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapConstellationJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapConstellationJumps[P]>
      : GetScalarType<T[P], AggregateMapConstellationJumps[P]>
  }




  export type MapConstellationJumpsGroupByArgs = {
    where?: mapConstellationJumpsWhereInput
    orderBy?: Enumerable<mapConstellationJumpsOrderByWithAggregationInput>
    by: Array<MapConstellationJumpsScalarFieldEnum>
    having?: mapConstellationJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapConstellationJumpsCountAggregateInputType | true
    _avg?: MapConstellationJumpsAvgAggregateInputType
    _sum?: MapConstellationJumpsSumAggregateInputType
    _min?: MapConstellationJumpsMinAggregateInputType
    _max?: MapConstellationJumpsMaxAggregateInputType
  }


  export type MapConstellationJumpsGroupByOutputType = {
    fromRegionID: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID: number | null
    _count: MapConstellationJumpsCountAggregateOutputType | null
    _avg: MapConstellationJumpsAvgAggregateOutputType | null
    _sum: MapConstellationJumpsSumAggregateOutputType | null
    _min: MapConstellationJumpsMinAggregateOutputType | null
    _max: MapConstellationJumpsMaxAggregateOutputType | null
  }

  type GetMapConstellationJumpsGroupByPayload<T extends MapConstellationJumpsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapConstellationJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapConstellationJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapConstellationJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapConstellationJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapConstellationJumpsSelect = {
    fromRegionID?: boolean
    fromConstellationID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }


  export type mapConstellationJumpsGetPayload<S extends boolean | null | undefined | mapConstellationJumpsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapConstellationJumps :
    S extends undefined ? never :
    S extends { include: any } & (mapConstellationJumpsArgs | mapConstellationJumpsFindManyArgs)
    ? mapConstellationJumps 
    : S extends { select: any } & (mapConstellationJumpsArgs | mapConstellationJumpsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapConstellationJumps ? mapConstellationJumps[P] : never
  } 
      : mapConstellationJumps


  type mapConstellationJumpsCountArgs = Merge<
    Omit<mapConstellationJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapConstellationJumpsCountAggregateInputType | true
    }
  >

  export interface mapConstellationJumpsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapConstellationJumps that matches the filter.
     * @param {mapConstellationJumpsFindUniqueArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapConstellationJumpsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapConstellationJumpsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapConstellationJumps'> extends True ? Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>> : Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T> | null, null>

    /**
     * Find the first MapConstellationJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindFirstArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapConstellationJumpsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapConstellationJumpsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapConstellationJumps'> extends True ? Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>> : Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T> | null, null>

    /**
     * Find zero or more MapConstellationJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany()
     * 
     * // Get first 10 MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapConstellationJumpsWithFromRegionIDOnly = await prisma.mapConstellationJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapConstellationJumpsFindManyArgs>(
      args?: SelectSubset<T, mapConstellationJumpsFindManyArgs>
    ): PrismaPromise<Array<mapConstellationJumpsGetPayload<T>>>

    /**
     * Create a MapConstellationJumps.
     * @param {mapConstellationJumpsCreateArgs} args - Arguments to create a MapConstellationJumps.
     * @example
     * // Create one MapConstellationJumps
     * const MapConstellationJumps = await prisma.mapConstellationJumps.create({
     *   data: {
     *     // ... data to create a MapConstellationJumps
     *   }
     * })
     * 
    **/
    create<T extends mapConstellationJumpsCreateArgs>(
      args: SelectSubset<T, mapConstellationJumpsCreateArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Create many MapConstellationJumps.
     *     @param {mapConstellationJumpsCreateManyArgs} args - Arguments to create many MapConstellationJumps.
     *     @example
     *     // Create many MapConstellationJumps
     *     const mapConstellationJumps = await prisma.mapConstellationJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapConstellationJumpsCreateManyArgs>(
      args?: SelectSubset<T, mapConstellationJumpsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapConstellationJumps.
     * @param {mapConstellationJumpsDeleteArgs} args - Arguments to delete one MapConstellationJumps.
     * @example
     * // Delete one MapConstellationJumps
     * const MapConstellationJumps = await prisma.mapConstellationJumps.delete({
     *   where: {
     *     // ... filter to delete one MapConstellationJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapConstellationJumpsDeleteArgs>(
      args: SelectSubset<T, mapConstellationJumpsDeleteArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Update one MapConstellationJumps.
     * @param {mapConstellationJumpsUpdateArgs} args - Arguments to update one MapConstellationJumps.
     * @example
     * // Update one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapConstellationJumpsUpdateArgs>(
      args: SelectSubset<T, mapConstellationJumpsUpdateArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Delete zero or more MapConstellationJumps.
     * @param {mapConstellationJumpsDeleteManyArgs} args - Arguments to filter MapConstellationJumps to delete.
     * @example
     * // Delete a few MapConstellationJumps
     * const { count } = await prisma.mapConstellationJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapConstellationJumpsDeleteManyArgs>(
      args?: SelectSubset<T, mapConstellationJumpsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapConstellationJumpsUpdateManyArgs>(
      args: SelectSubset<T, mapConstellationJumpsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapConstellationJumps.
     * @param {mapConstellationJumpsUpsertArgs} args - Arguments to update or create a MapConstellationJumps.
     * @example
     * // Update or create a MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.upsert({
     *   create: {
     *     // ... data to create a MapConstellationJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapConstellationJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapConstellationJumpsUpsertArgs>(
      args: SelectSubset<T, mapConstellationJumpsUpsertArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Find one MapConstellationJumps that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapConstellationJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapConstellationJumpsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapConstellationJumpsFindUniqueOrThrowArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Find the first MapConstellationJumps that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindFirstOrThrowArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapConstellationJumpsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapConstellationJumpsFindFirstOrThrowArgs>
    ): Prisma__mapConstellationJumpsClient<mapConstellationJumpsGetPayload<T>>

    /**
     * Count the number of MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsCountArgs} args - Arguments to filter MapConstellationJumps to count.
     * @example
     * // Count the number of MapConstellationJumps
     * const count = await prisma.mapConstellationJumps.count({
     *   where: {
     *     // ... the filter for the MapConstellationJumps we want to count
     *   }
     * })
    **/
    count<T extends mapConstellationJumpsCountArgs>(
      args?: Subset<T, mapConstellationJumpsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapConstellationJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapConstellationJumpsAggregateArgs>(args: Subset<T, MapConstellationJumpsAggregateArgs>): PrismaPromise<GetMapConstellationJumpsAggregateType<T>>

    /**
     * Group by MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapConstellationJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapConstellationJumpsGroupByArgs['orderBy'] }
        : { orderBy?: MapConstellationJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapConstellationJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapConstellationJumpsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapConstellationJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapConstellationJumpsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapConstellationJumps base type for findUnique actions
   */
  export type mapConstellationJumpsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     * 
    **/
    where: mapConstellationJumpsWhereUniqueInput
  }

  /**
   * mapConstellationJumps: findUnique
   */
  export interface mapConstellationJumpsFindUniqueArgs extends mapConstellationJumpsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapConstellationJumps base type for findFirst actions
   */
  export type mapConstellationJumpsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     * 
    **/
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellationJumps.
     * 
    **/
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellationJumps.
     * 
    **/
    distinct?: Enumerable<MapConstellationJumpsScalarFieldEnum>
  }

  /**
   * mapConstellationJumps: findFirst
   */
  export interface mapConstellationJumpsFindFirstArgs extends mapConstellationJumpsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapConstellationJumps findMany
   */
  export type mapConstellationJumpsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     * 
    **/
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapConstellationJumps.
     * 
    **/
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapConstellationJumpsScalarFieldEnum>
  }


  /**
   * mapConstellationJumps create
   */
  export type mapConstellationJumpsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * The data needed to create a mapConstellationJumps.
     * 
    **/
    data: XOR<mapConstellationJumpsCreateInput, mapConstellationJumpsUncheckedCreateInput>
  }


  /**
   * mapConstellationJumps createMany
   */
  export type mapConstellationJumpsCreateManyArgs = {
    /**
     * The data used to create many mapConstellationJumps.
     * 
    **/
    data: Enumerable<mapConstellationJumpsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapConstellationJumps update
   */
  export type mapConstellationJumpsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * The data needed to update a mapConstellationJumps.
     * 
    **/
    data: XOR<mapConstellationJumpsUpdateInput, mapConstellationJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapConstellationJumps to update.
     * 
    **/
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps updateMany
   */
  export type mapConstellationJumpsUpdateManyArgs = {
    /**
     * The data used to update mapConstellationJumps.
     * 
    **/
    data: XOR<mapConstellationJumpsUpdateManyMutationInput, mapConstellationJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapConstellationJumps to update
     * 
    **/
    where?: mapConstellationJumpsWhereInput
  }


  /**
   * mapConstellationJumps upsert
   */
  export type mapConstellationJumpsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * The filter to search for the mapConstellationJumps to update in case it exists.
     * 
    **/
    where: mapConstellationJumpsWhereUniqueInput
    /**
     * In case the mapConstellationJumps found by the `where` argument doesn't exist, create a new mapConstellationJumps with this data.
     * 
    **/
    create: XOR<mapConstellationJumpsCreateInput, mapConstellationJumpsUncheckedCreateInput>
    /**
     * In case the mapConstellationJumps was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapConstellationJumpsUpdateInput, mapConstellationJumpsUncheckedUpdateInput>
  }


  /**
   * mapConstellationJumps delete
   */
  export type mapConstellationJumpsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
    /**
     * Filter which mapConstellationJumps to delete.
     * 
    **/
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps deleteMany
   */
  export type mapConstellationJumpsDeleteManyArgs = {
    /**
     * Filter which mapConstellationJumps to delete
     * 
    **/
    where?: mapConstellationJumpsWhereInput
  }


  /**
   * mapConstellationJumps: findUniqueOrThrow
   */
  export type mapConstellationJumpsFindUniqueOrThrowArgs = mapConstellationJumpsFindUniqueArgsBase
      

  /**
   * mapConstellationJumps: findFirstOrThrow
   */
  export type mapConstellationJumpsFindFirstOrThrowArgs = mapConstellationJumpsFindFirstArgsBase
      

  /**
   * mapConstellationJumps without action
   */
  export type mapConstellationJumpsArgs = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     * 
    **/
    select?: mapConstellationJumpsSelect | null
  }



  /**
   * Model mapConstellations
   */


  export type AggregateMapConstellations = {
    _count: MapConstellationsCountAggregateOutputType | null
    _avg: MapConstellationsAvgAggregateOutputType | null
    _sum: MapConstellationsSumAggregateOutputType | null
    _min: MapConstellationsMinAggregateOutputType | null
    _max: MapConstellationsMaxAggregateOutputType | null
  }

  export type MapConstellationsAvgAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsSumAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsMinAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsMaxAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsCountAggregateOutputType = {
    regionID: number
    constellationID: number
    constellationName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    factionID: number
    radius: number
    _all: number
  }


  export type MapConstellationsAvgAggregateInputType = {
    regionID?: true
    constellationID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsSumAggregateInputType = {
    regionID?: true
    constellationID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsMinAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsMaxAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsCountAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
    _all?: true
  }

  export type MapConstellationsAggregateArgs = {
    /**
     * Filter which mapConstellations to aggregate.
     * 
    **/
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapConstellations
    **/
    _count?: true | MapConstellationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapConstellationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapConstellationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapConstellationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapConstellationsMaxAggregateInputType
  }

  export type GetMapConstellationsAggregateType<T extends MapConstellationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapConstellations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapConstellations[P]>
      : GetScalarType<T[P], AggregateMapConstellations[P]>
  }




  export type MapConstellationsGroupByArgs = {
    where?: mapConstellationsWhereInput
    orderBy?: Enumerable<mapConstellationsOrderByWithAggregationInput>
    by: Array<MapConstellationsScalarFieldEnum>
    having?: mapConstellationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapConstellationsCountAggregateInputType | true
    _avg?: MapConstellationsAvgAggregateInputType
    _sum?: MapConstellationsSumAggregateInputType
    _min?: MapConstellationsMinAggregateInputType
    _max?: MapConstellationsMaxAggregateInputType
  }


  export type MapConstellationsGroupByOutputType = {
    regionID: number | null
    constellationID: number
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
    _count: MapConstellationsCountAggregateOutputType | null
    _avg: MapConstellationsAvgAggregateOutputType | null
    _sum: MapConstellationsSumAggregateOutputType | null
    _min: MapConstellationsMinAggregateOutputType | null
    _max: MapConstellationsMaxAggregateOutputType | null
  }

  type GetMapConstellationsGroupByPayload<T extends MapConstellationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapConstellationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapConstellationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapConstellationsGroupByOutputType[P]>
            : GetScalarType<T[P], MapConstellationsGroupByOutputType[P]>
        }
      >
    >


  export type mapConstellationsSelect = {
    regionID?: boolean
    constellationID?: boolean
    constellationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    radius?: boolean
  }


  export type mapConstellationsGetPayload<S extends boolean | null | undefined | mapConstellationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapConstellations :
    S extends undefined ? never :
    S extends { include: any } & (mapConstellationsArgs | mapConstellationsFindManyArgs)
    ? mapConstellations 
    : S extends { select: any } & (mapConstellationsArgs | mapConstellationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapConstellations ? mapConstellations[P] : never
  } 
      : mapConstellations


  type mapConstellationsCountArgs = Merge<
    Omit<mapConstellationsFindManyArgs, 'select' | 'include'> & {
      select?: MapConstellationsCountAggregateInputType | true
    }
  >

  export interface mapConstellationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapConstellations that matches the filter.
     * @param {mapConstellationsFindUniqueArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapConstellationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapConstellationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapConstellations'> extends True ? Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>> : Prisma__mapConstellationsClient<mapConstellationsGetPayload<T> | null, null>

    /**
     * Find the first MapConstellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindFirstArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapConstellationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapConstellationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapConstellations'> extends True ? Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>> : Prisma__mapConstellationsClient<mapConstellationsGetPayload<T> | null, null>

    /**
     * Find zero or more MapConstellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findMany()
     * 
     * // Get first 10 MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapConstellationsWithRegionIDOnly = await prisma.mapConstellations.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapConstellationsFindManyArgs>(
      args?: SelectSubset<T, mapConstellationsFindManyArgs>
    ): PrismaPromise<Array<mapConstellationsGetPayload<T>>>

    /**
     * Create a MapConstellations.
     * @param {mapConstellationsCreateArgs} args - Arguments to create a MapConstellations.
     * @example
     * // Create one MapConstellations
     * const MapConstellations = await prisma.mapConstellations.create({
     *   data: {
     *     // ... data to create a MapConstellations
     *   }
     * })
     * 
    **/
    create<T extends mapConstellationsCreateArgs>(
      args: SelectSubset<T, mapConstellationsCreateArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Create many MapConstellations.
     *     @param {mapConstellationsCreateManyArgs} args - Arguments to create many MapConstellations.
     *     @example
     *     // Create many MapConstellations
     *     const mapConstellations = await prisma.mapConstellations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapConstellationsCreateManyArgs>(
      args?: SelectSubset<T, mapConstellationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapConstellations.
     * @param {mapConstellationsDeleteArgs} args - Arguments to delete one MapConstellations.
     * @example
     * // Delete one MapConstellations
     * const MapConstellations = await prisma.mapConstellations.delete({
     *   where: {
     *     // ... filter to delete one MapConstellations
     *   }
     * })
     * 
    **/
    delete<T extends mapConstellationsDeleteArgs>(
      args: SelectSubset<T, mapConstellationsDeleteArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Update one MapConstellations.
     * @param {mapConstellationsUpdateArgs} args - Arguments to update one MapConstellations.
     * @example
     * // Update one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapConstellationsUpdateArgs>(
      args: SelectSubset<T, mapConstellationsUpdateArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Delete zero or more MapConstellations.
     * @param {mapConstellationsDeleteManyArgs} args - Arguments to filter MapConstellations to delete.
     * @example
     * // Delete a few MapConstellations
     * const { count } = await prisma.mapConstellations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapConstellationsDeleteManyArgs>(
      args?: SelectSubset<T, mapConstellationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapConstellations
     * const mapConstellations = await prisma.mapConstellations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapConstellationsUpdateManyArgs>(
      args: SelectSubset<T, mapConstellationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapConstellations.
     * @param {mapConstellationsUpsertArgs} args - Arguments to update or create a MapConstellations.
     * @example
     * // Update or create a MapConstellations
     * const mapConstellations = await prisma.mapConstellations.upsert({
     *   create: {
     *     // ... data to create a MapConstellations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapConstellations we want to update
     *   }
     * })
    **/
    upsert<T extends mapConstellationsUpsertArgs>(
      args: SelectSubset<T, mapConstellationsUpsertArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Find one MapConstellations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapConstellationsFindUniqueOrThrowArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapConstellationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapConstellationsFindUniqueOrThrowArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Find the first MapConstellations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindFirstOrThrowArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapConstellationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapConstellationsFindFirstOrThrowArgs>
    ): Prisma__mapConstellationsClient<mapConstellationsGetPayload<T>>

    /**
     * Count the number of MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsCountArgs} args - Arguments to filter MapConstellations to count.
     * @example
     * // Count the number of MapConstellations
     * const count = await prisma.mapConstellations.count({
     *   where: {
     *     // ... the filter for the MapConstellations we want to count
     *   }
     * })
    **/
    count<T extends mapConstellationsCountArgs>(
      args?: Subset<T, mapConstellationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapConstellationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapConstellationsAggregateArgs>(args: Subset<T, MapConstellationsAggregateArgs>): PrismaPromise<GetMapConstellationsAggregateType<T>>

    /**
     * Group by MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapConstellationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapConstellationsGroupByArgs['orderBy'] }
        : { orderBy?: MapConstellationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapConstellationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapConstellationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapConstellations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapConstellationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapConstellations base type for findUnique actions
   */
  export type mapConstellationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * Filter, which mapConstellations to fetch.
     * 
    **/
    where: mapConstellationsWhereUniqueInput
  }

  /**
   * mapConstellations: findUnique
   */
  export interface mapConstellationsFindUniqueArgs extends mapConstellationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapConstellations base type for findFirst actions
   */
  export type mapConstellationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * Filter, which mapConstellations to fetch.
     * 
    **/
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellations.
     * 
    **/
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellations.
     * 
    **/
    distinct?: Enumerable<MapConstellationsScalarFieldEnum>
  }

  /**
   * mapConstellations: findFirst
   */
  export interface mapConstellationsFindFirstArgs extends mapConstellationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapConstellations findMany
   */
  export type mapConstellationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * Filter, which mapConstellations to fetch.
     * 
    **/
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     * 
    **/
    orderBy?: Enumerable<mapConstellationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapConstellations.
     * 
    **/
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapConstellationsScalarFieldEnum>
  }


  /**
   * mapConstellations create
   */
  export type mapConstellationsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * The data needed to create a mapConstellations.
     * 
    **/
    data: XOR<mapConstellationsCreateInput, mapConstellationsUncheckedCreateInput>
  }


  /**
   * mapConstellations createMany
   */
  export type mapConstellationsCreateManyArgs = {
    /**
     * The data used to create many mapConstellations.
     * 
    **/
    data: Enumerable<mapConstellationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapConstellations update
   */
  export type mapConstellationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * The data needed to update a mapConstellations.
     * 
    **/
    data: XOR<mapConstellationsUpdateInput, mapConstellationsUncheckedUpdateInput>
    /**
     * Choose, which mapConstellations to update.
     * 
    **/
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations updateMany
   */
  export type mapConstellationsUpdateManyArgs = {
    /**
     * The data used to update mapConstellations.
     * 
    **/
    data: XOR<mapConstellationsUpdateManyMutationInput, mapConstellationsUncheckedUpdateManyInput>
    /**
     * Filter which mapConstellations to update
     * 
    **/
    where?: mapConstellationsWhereInput
  }


  /**
   * mapConstellations upsert
   */
  export type mapConstellationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * The filter to search for the mapConstellations to update in case it exists.
     * 
    **/
    where: mapConstellationsWhereUniqueInput
    /**
     * In case the mapConstellations found by the `where` argument doesn't exist, create a new mapConstellations with this data.
     * 
    **/
    create: XOR<mapConstellationsCreateInput, mapConstellationsUncheckedCreateInput>
    /**
     * In case the mapConstellations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapConstellationsUpdateInput, mapConstellationsUncheckedUpdateInput>
  }


  /**
   * mapConstellations delete
   */
  export type mapConstellationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
    /**
     * Filter which mapConstellations to delete.
     * 
    **/
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations deleteMany
   */
  export type mapConstellationsDeleteManyArgs = {
    /**
     * Filter which mapConstellations to delete
     * 
    **/
    where?: mapConstellationsWhereInput
  }


  /**
   * mapConstellations: findUniqueOrThrow
   */
  export type mapConstellationsFindUniqueOrThrowArgs = mapConstellationsFindUniqueArgsBase
      

  /**
   * mapConstellations: findFirstOrThrow
   */
  export type mapConstellationsFindFirstOrThrowArgs = mapConstellationsFindFirstArgsBase
      

  /**
   * mapConstellations without action
   */
  export type mapConstellationsArgs = {
    /**
     * Select specific fields to fetch from the mapConstellations
     * 
    **/
    select?: mapConstellationsSelect | null
  }



  /**
   * Model mapDenormalize
   */


  export type AggregateMapDenormalize = {
    _count: MapDenormalizeCountAggregateOutputType | null
    _avg: MapDenormalizeAvgAggregateOutputType | null
    _sum: MapDenormalizeSumAggregateOutputType | null
    _min: MapDenormalizeMinAggregateOutputType | null
    _max: MapDenormalizeMaxAggregateOutputType | null
  }

  export type MapDenormalizeAvgAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeSumAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeMinAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeMaxAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeCountAggregateOutputType = {
    itemID: number
    typeID: number
    groupID: number
    solarSystemID: number
    constellationID: number
    regionID: number
    orbitID: number
    x: number
    y: number
    z: number
    radius: number
    itemName: number
    security: number
    celestialIndex: number
    orbitIndex: number
    _all: number
  }


  export type MapDenormalizeAvgAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeSumAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeMinAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeMaxAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeCountAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
    _all?: true
  }

  export type MapDenormalizeAggregateArgs = {
    /**
     * Filter which mapDenormalize to aggregate.
     * 
    **/
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapDenormalizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapDenormalizes
    **/
    _count?: true | MapDenormalizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapDenormalizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapDenormalizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapDenormalizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapDenormalizeMaxAggregateInputType
  }

  export type GetMapDenormalizeAggregateType<T extends MapDenormalizeAggregateArgs> = {
        [P in keyof T & keyof AggregateMapDenormalize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapDenormalize[P]>
      : GetScalarType<T[P], AggregateMapDenormalize[P]>
  }




  export type MapDenormalizeGroupByArgs = {
    where?: mapDenormalizeWhereInput
    orderBy?: Enumerable<mapDenormalizeOrderByWithAggregationInput>
    by: Array<MapDenormalizeScalarFieldEnum>
    having?: mapDenormalizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapDenormalizeCountAggregateInputType | true
    _avg?: MapDenormalizeAvgAggregateInputType
    _sum?: MapDenormalizeSumAggregateInputType
    _min?: MapDenormalizeMinAggregateInputType
    _max?: MapDenormalizeMaxAggregateInputType
  }


  export type MapDenormalizeGroupByOutputType = {
    itemID: number
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
    _count: MapDenormalizeCountAggregateOutputType | null
    _avg: MapDenormalizeAvgAggregateOutputType | null
    _sum: MapDenormalizeSumAggregateOutputType | null
    _min: MapDenormalizeMinAggregateOutputType | null
    _max: MapDenormalizeMaxAggregateOutputType | null
  }

  type GetMapDenormalizeGroupByPayload<T extends MapDenormalizeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapDenormalizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapDenormalizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapDenormalizeGroupByOutputType[P]>
            : GetScalarType<T[P], MapDenormalizeGroupByOutputType[P]>
        }
      >
    >


  export type mapDenormalizeSelect = {
    itemID?: boolean
    typeID?: boolean
    groupID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    orbitID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    radius?: boolean
    itemName?: boolean
    security?: boolean
    celestialIndex?: boolean
    orbitIndex?: boolean
  }


  export type mapDenormalizeGetPayload<S extends boolean | null | undefined | mapDenormalizeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapDenormalize :
    S extends undefined ? never :
    S extends { include: any } & (mapDenormalizeArgs | mapDenormalizeFindManyArgs)
    ? mapDenormalize 
    : S extends { select: any } & (mapDenormalizeArgs | mapDenormalizeFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapDenormalize ? mapDenormalize[P] : never
  } 
      : mapDenormalize


  type mapDenormalizeCountArgs = Merge<
    Omit<mapDenormalizeFindManyArgs, 'select' | 'include'> & {
      select?: MapDenormalizeCountAggregateInputType | true
    }
  >

  export interface mapDenormalizeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapDenormalize that matches the filter.
     * @param {mapDenormalizeFindUniqueArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapDenormalizeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapDenormalizeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapDenormalize'> extends True ? Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>> : Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T> | null, null>

    /**
     * Find the first MapDenormalize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindFirstArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapDenormalizeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapDenormalizeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapDenormalize'> extends True ? Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>> : Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T> | null, null>

    /**
     * Find zero or more MapDenormalizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapDenormalizes
     * const mapDenormalizes = await prisma.mapDenormalize.findMany()
     * 
     * // Get first 10 MapDenormalizes
     * const mapDenormalizes = await prisma.mapDenormalize.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const mapDenormalizeWithItemIDOnly = await prisma.mapDenormalize.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends mapDenormalizeFindManyArgs>(
      args?: SelectSubset<T, mapDenormalizeFindManyArgs>
    ): PrismaPromise<Array<mapDenormalizeGetPayload<T>>>

    /**
     * Create a MapDenormalize.
     * @param {mapDenormalizeCreateArgs} args - Arguments to create a MapDenormalize.
     * @example
     * // Create one MapDenormalize
     * const MapDenormalize = await prisma.mapDenormalize.create({
     *   data: {
     *     // ... data to create a MapDenormalize
     *   }
     * })
     * 
    **/
    create<T extends mapDenormalizeCreateArgs>(
      args: SelectSubset<T, mapDenormalizeCreateArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Create many MapDenormalizes.
     *     @param {mapDenormalizeCreateManyArgs} args - Arguments to create many MapDenormalizes.
     *     @example
     *     // Create many MapDenormalizes
     *     const mapDenormalize = await prisma.mapDenormalize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapDenormalizeCreateManyArgs>(
      args?: SelectSubset<T, mapDenormalizeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapDenormalize.
     * @param {mapDenormalizeDeleteArgs} args - Arguments to delete one MapDenormalize.
     * @example
     * // Delete one MapDenormalize
     * const MapDenormalize = await prisma.mapDenormalize.delete({
     *   where: {
     *     // ... filter to delete one MapDenormalize
     *   }
     * })
     * 
    **/
    delete<T extends mapDenormalizeDeleteArgs>(
      args: SelectSubset<T, mapDenormalizeDeleteArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Update one MapDenormalize.
     * @param {mapDenormalizeUpdateArgs} args - Arguments to update one MapDenormalize.
     * @example
     * // Update one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapDenormalizeUpdateArgs>(
      args: SelectSubset<T, mapDenormalizeUpdateArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Delete zero or more MapDenormalizes.
     * @param {mapDenormalizeDeleteManyArgs} args - Arguments to filter MapDenormalizes to delete.
     * @example
     * // Delete a few MapDenormalizes
     * const { count } = await prisma.mapDenormalize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapDenormalizeDeleteManyArgs>(
      args?: SelectSubset<T, mapDenormalizeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapDenormalizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapDenormalizes
     * const mapDenormalize = await prisma.mapDenormalize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapDenormalizeUpdateManyArgs>(
      args: SelectSubset<T, mapDenormalizeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapDenormalize.
     * @param {mapDenormalizeUpsertArgs} args - Arguments to update or create a MapDenormalize.
     * @example
     * // Update or create a MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.upsert({
     *   create: {
     *     // ... data to create a MapDenormalize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapDenormalize we want to update
     *   }
     * })
    **/
    upsert<T extends mapDenormalizeUpsertArgs>(
      args: SelectSubset<T, mapDenormalizeUpsertArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Find one MapDenormalize that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapDenormalizeFindUniqueOrThrowArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapDenormalizeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapDenormalizeFindUniqueOrThrowArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Find the first MapDenormalize that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindFirstOrThrowArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapDenormalizeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapDenormalizeFindFirstOrThrowArgs>
    ): Prisma__mapDenormalizeClient<mapDenormalizeGetPayload<T>>

    /**
     * Count the number of MapDenormalizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeCountArgs} args - Arguments to filter MapDenormalizes to count.
     * @example
     * // Count the number of MapDenormalizes
     * const count = await prisma.mapDenormalize.count({
     *   where: {
     *     // ... the filter for the MapDenormalizes we want to count
     *   }
     * })
    **/
    count<T extends mapDenormalizeCountArgs>(
      args?: Subset<T, mapDenormalizeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapDenormalizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapDenormalize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDenormalizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapDenormalizeAggregateArgs>(args: Subset<T, MapDenormalizeAggregateArgs>): PrismaPromise<GetMapDenormalizeAggregateType<T>>

    /**
     * Group by MapDenormalize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDenormalizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapDenormalizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapDenormalizeGroupByArgs['orderBy'] }
        : { orderBy?: MapDenormalizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapDenormalizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapDenormalizeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapDenormalize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapDenormalizeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapDenormalize base type for findUnique actions
   */
  export type mapDenormalizeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * Filter, which mapDenormalize to fetch.
     * 
    **/
    where: mapDenormalizeWhereUniqueInput
  }

  /**
   * mapDenormalize: findUnique
   */
  export interface mapDenormalizeFindUniqueArgs extends mapDenormalizeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapDenormalize base type for findFirst actions
   */
  export type mapDenormalizeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * Filter, which mapDenormalize to fetch.
     * 
    **/
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapDenormalizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapDenormalizes.
     * 
    **/
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapDenormalizes.
     * 
    **/
    distinct?: Enumerable<MapDenormalizeScalarFieldEnum>
  }

  /**
   * mapDenormalize: findFirst
   */
  export interface mapDenormalizeFindFirstArgs extends mapDenormalizeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapDenormalize findMany
   */
  export type mapDenormalizeFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * Filter, which mapDenormalizes to fetch.
     * 
    **/
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapDenormalizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapDenormalizes.
     * 
    **/
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapDenormalizeScalarFieldEnum>
  }


  /**
   * mapDenormalize create
   */
  export type mapDenormalizeCreateArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * The data needed to create a mapDenormalize.
     * 
    **/
    data: XOR<mapDenormalizeCreateInput, mapDenormalizeUncheckedCreateInput>
  }


  /**
   * mapDenormalize createMany
   */
  export type mapDenormalizeCreateManyArgs = {
    /**
     * The data used to create many mapDenormalizes.
     * 
    **/
    data: Enumerable<mapDenormalizeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapDenormalize update
   */
  export type mapDenormalizeUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * The data needed to update a mapDenormalize.
     * 
    **/
    data: XOR<mapDenormalizeUpdateInput, mapDenormalizeUncheckedUpdateInput>
    /**
     * Choose, which mapDenormalize to update.
     * 
    **/
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize updateMany
   */
  export type mapDenormalizeUpdateManyArgs = {
    /**
     * The data used to update mapDenormalizes.
     * 
    **/
    data: XOR<mapDenormalizeUpdateManyMutationInput, mapDenormalizeUncheckedUpdateManyInput>
    /**
     * Filter which mapDenormalizes to update
     * 
    **/
    where?: mapDenormalizeWhereInput
  }


  /**
   * mapDenormalize upsert
   */
  export type mapDenormalizeUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * The filter to search for the mapDenormalize to update in case it exists.
     * 
    **/
    where: mapDenormalizeWhereUniqueInput
    /**
     * In case the mapDenormalize found by the `where` argument doesn't exist, create a new mapDenormalize with this data.
     * 
    **/
    create: XOR<mapDenormalizeCreateInput, mapDenormalizeUncheckedCreateInput>
    /**
     * In case the mapDenormalize was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapDenormalizeUpdateInput, mapDenormalizeUncheckedUpdateInput>
  }


  /**
   * mapDenormalize delete
   */
  export type mapDenormalizeDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
    /**
     * Filter which mapDenormalize to delete.
     * 
    **/
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize deleteMany
   */
  export type mapDenormalizeDeleteManyArgs = {
    /**
     * Filter which mapDenormalizes to delete
     * 
    **/
    where?: mapDenormalizeWhereInput
  }


  /**
   * mapDenormalize: findUniqueOrThrow
   */
  export type mapDenormalizeFindUniqueOrThrowArgs = mapDenormalizeFindUniqueArgsBase
      

  /**
   * mapDenormalize: findFirstOrThrow
   */
  export type mapDenormalizeFindFirstOrThrowArgs = mapDenormalizeFindFirstArgsBase
      

  /**
   * mapDenormalize without action
   */
  export type mapDenormalizeArgs = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     * 
    **/
    select?: mapDenormalizeSelect | null
  }



  /**
   * Model mapJumps
   */


  export type AggregateMapJumps = {
    _count: MapJumpsCountAggregateOutputType | null
    _avg: MapJumpsAvgAggregateOutputType | null
    _sum: MapJumpsSumAggregateOutputType | null
    _min: MapJumpsMinAggregateOutputType | null
    _max: MapJumpsMaxAggregateOutputType | null
  }

  export type MapJumpsAvgAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsSumAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsMinAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsMaxAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsCountAggregateOutputType = {
    stargateID: number
    destinationID: number
    _all: number
  }


  export type MapJumpsAvgAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsSumAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsMinAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsMaxAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsCountAggregateInputType = {
    stargateID?: true
    destinationID?: true
    _all?: true
  }

  export type MapJumpsAggregateArgs = {
    /**
     * Filter which mapJumps to aggregate.
     * 
    **/
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapJumps
    **/
    _count?: true | MapJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapJumpsMaxAggregateInputType
  }

  export type GetMapJumpsAggregateType<T extends MapJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapJumps[P]>
      : GetScalarType<T[P], AggregateMapJumps[P]>
  }




  export type MapJumpsGroupByArgs = {
    where?: mapJumpsWhereInput
    orderBy?: Enumerable<mapJumpsOrderByWithAggregationInput>
    by: Array<MapJumpsScalarFieldEnum>
    having?: mapJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapJumpsCountAggregateInputType | true
    _avg?: MapJumpsAvgAggregateInputType
    _sum?: MapJumpsSumAggregateInputType
    _min?: MapJumpsMinAggregateInputType
    _max?: MapJumpsMaxAggregateInputType
  }


  export type MapJumpsGroupByOutputType = {
    stargateID: number
    destinationID: number | null
    _count: MapJumpsCountAggregateOutputType | null
    _avg: MapJumpsAvgAggregateOutputType | null
    _sum: MapJumpsSumAggregateOutputType | null
    _min: MapJumpsMinAggregateOutputType | null
    _max: MapJumpsMaxAggregateOutputType | null
  }

  type GetMapJumpsGroupByPayload<T extends MapJumpsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapJumpsSelect = {
    stargateID?: boolean
    destinationID?: boolean
  }


  export type mapJumpsGetPayload<S extends boolean | null | undefined | mapJumpsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapJumps :
    S extends undefined ? never :
    S extends { include: any } & (mapJumpsArgs | mapJumpsFindManyArgs)
    ? mapJumps 
    : S extends { select: any } & (mapJumpsArgs | mapJumpsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapJumps ? mapJumps[P] : never
  } 
      : mapJumps


  type mapJumpsCountArgs = Merge<
    Omit<mapJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapJumpsCountAggregateInputType | true
    }
  >

  export interface mapJumpsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapJumps that matches the filter.
     * @param {mapJumpsFindUniqueArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapJumpsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapJumpsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapJumps'> extends True ? Prisma__mapJumpsClient<mapJumpsGetPayload<T>> : Prisma__mapJumpsClient<mapJumpsGetPayload<T> | null, null>

    /**
     * Find the first MapJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindFirstArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapJumpsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapJumpsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapJumps'> extends True ? Prisma__mapJumpsClient<mapJumpsGetPayload<T>> : Prisma__mapJumpsClient<mapJumpsGetPayload<T> | null, null>

    /**
     * Find zero or more MapJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapJumps
     * const mapJumps = await prisma.mapJumps.findMany()
     * 
     * // Get first 10 MapJumps
     * const mapJumps = await prisma.mapJumps.findMany({ take: 10 })
     * 
     * // Only select the `stargateID`
     * const mapJumpsWithStargateIDOnly = await prisma.mapJumps.findMany({ select: { stargateID: true } })
     * 
    **/
    findMany<T extends mapJumpsFindManyArgs>(
      args?: SelectSubset<T, mapJumpsFindManyArgs>
    ): PrismaPromise<Array<mapJumpsGetPayload<T>>>

    /**
     * Create a MapJumps.
     * @param {mapJumpsCreateArgs} args - Arguments to create a MapJumps.
     * @example
     * // Create one MapJumps
     * const MapJumps = await prisma.mapJumps.create({
     *   data: {
     *     // ... data to create a MapJumps
     *   }
     * })
     * 
    **/
    create<T extends mapJumpsCreateArgs>(
      args: SelectSubset<T, mapJumpsCreateArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Create many MapJumps.
     *     @param {mapJumpsCreateManyArgs} args - Arguments to create many MapJumps.
     *     @example
     *     // Create many MapJumps
     *     const mapJumps = await prisma.mapJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapJumpsCreateManyArgs>(
      args?: SelectSubset<T, mapJumpsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapJumps.
     * @param {mapJumpsDeleteArgs} args - Arguments to delete one MapJumps.
     * @example
     * // Delete one MapJumps
     * const MapJumps = await prisma.mapJumps.delete({
     *   where: {
     *     // ... filter to delete one MapJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapJumpsDeleteArgs>(
      args: SelectSubset<T, mapJumpsDeleteArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Update one MapJumps.
     * @param {mapJumpsUpdateArgs} args - Arguments to update one MapJumps.
     * @example
     * // Update one MapJumps
     * const mapJumps = await prisma.mapJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapJumpsUpdateArgs>(
      args: SelectSubset<T, mapJumpsUpdateArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Delete zero or more MapJumps.
     * @param {mapJumpsDeleteManyArgs} args - Arguments to filter MapJumps to delete.
     * @example
     * // Delete a few MapJumps
     * const { count } = await prisma.mapJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapJumpsDeleteManyArgs>(
      args?: SelectSubset<T, mapJumpsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapJumps
     * const mapJumps = await prisma.mapJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapJumpsUpdateManyArgs>(
      args: SelectSubset<T, mapJumpsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapJumps.
     * @param {mapJumpsUpsertArgs} args - Arguments to update or create a MapJumps.
     * @example
     * // Update or create a MapJumps
     * const mapJumps = await prisma.mapJumps.upsert({
     *   create: {
     *     // ... data to create a MapJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapJumpsUpsertArgs>(
      args: SelectSubset<T, mapJumpsUpsertArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Find one MapJumps that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapJumpsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapJumpsFindUniqueOrThrowArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Find the first MapJumps that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindFirstOrThrowArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapJumpsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapJumpsFindFirstOrThrowArgs>
    ): Prisma__mapJumpsClient<mapJumpsGetPayload<T>>

    /**
     * Count the number of MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsCountArgs} args - Arguments to filter MapJumps to count.
     * @example
     * // Count the number of MapJumps
     * const count = await prisma.mapJumps.count({
     *   where: {
     *     // ... the filter for the MapJumps we want to count
     *   }
     * })
    **/
    count<T extends mapJumpsCountArgs>(
      args?: Subset<T, mapJumpsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapJumpsAggregateArgs>(args: Subset<T, MapJumpsAggregateArgs>): PrismaPromise<GetMapJumpsAggregateType<T>>

    /**
     * Group by MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapJumpsGroupByArgs['orderBy'] }
        : { orderBy?: MapJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapJumpsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapJumpsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapJumps base type for findUnique actions
   */
  export type mapJumpsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * Filter, which mapJumps to fetch.
     * 
    **/
    where: mapJumpsWhereUniqueInput
  }

  /**
   * mapJumps: findUnique
   */
  export interface mapJumpsFindUniqueArgs extends mapJumpsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapJumps base type for findFirst actions
   */
  export type mapJumpsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * Filter, which mapJumps to fetch.
     * 
    **/
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapJumps.
     * 
    **/
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapJumps.
     * 
    **/
    distinct?: Enumerable<MapJumpsScalarFieldEnum>
  }

  /**
   * mapJumps: findFirst
   */
  export interface mapJumpsFindFirstArgs extends mapJumpsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapJumps findMany
   */
  export type mapJumpsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * Filter, which mapJumps to fetch.
     * 
    **/
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapJumps.
     * 
    **/
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapJumpsScalarFieldEnum>
  }


  /**
   * mapJumps create
   */
  export type mapJumpsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * The data needed to create a mapJumps.
     * 
    **/
    data: XOR<mapJumpsCreateInput, mapJumpsUncheckedCreateInput>
  }


  /**
   * mapJumps createMany
   */
  export type mapJumpsCreateManyArgs = {
    /**
     * The data used to create many mapJumps.
     * 
    **/
    data: Enumerable<mapJumpsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapJumps update
   */
  export type mapJumpsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * The data needed to update a mapJumps.
     * 
    **/
    data: XOR<mapJumpsUpdateInput, mapJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapJumps to update.
     * 
    **/
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps updateMany
   */
  export type mapJumpsUpdateManyArgs = {
    /**
     * The data used to update mapJumps.
     * 
    **/
    data: XOR<mapJumpsUpdateManyMutationInput, mapJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapJumps to update
     * 
    **/
    where?: mapJumpsWhereInput
  }


  /**
   * mapJumps upsert
   */
  export type mapJumpsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * The filter to search for the mapJumps to update in case it exists.
     * 
    **/
    where: mapJumpsWhereUniqueInput
    /**
     * In case the mapJumps found by the `where` argument doesn't exist, create a new mapJumps with this data.
     * 
    **/
    create: XOR<mapJumpsCreateInput, mapJumpsUncheckedCreateInput>
    /**
     * In case the mapJumps was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapJumpsUpdateInput, mapJumpsUncheckedUpdateInput>
  }


  /**
   * mapJumps delete
   */
  export type mapJumpsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
    /**
     * Filter which mapJumps to delete.
     * 
    **/
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps deleteMany
   */
  export type mapJumpsDeleteManyArgs = {
    /**
     * Filter which mapJumps to delete
     * 
    **/
    where?: mapJumpsWhereInput
  }


  /**
   * mapJumps: findUniqueOrThrow
   */
  export type mapJumpsFindUniqueOrThrowArgs = mapJumpsFindUniqueArgsBase
      

  /**
   * mapJumps: findFirstOrThrow
   */
  export type mapJumpsFindFirstOrThrowArgs = mapJumpsFindFirstArgsBase
      

  /**
   * mapJumps without action
   */
  export type mapJumpsArgs = {
    /**
     * Select specific fields to fetch from the mapJumps
     * 
    **/
    select?: mapJumpsSelect | null
  }



  /**
   * Model mapLandmarks
   */


  export type AggregateMapLandmarks = {
    _count: MapLandmarksCountAggregateOutputType | null
    _avg: MapLandmarksAvgAggregateOutputType | null
    _sum: MapLandmarksSumAggregateOutputType | null
    _min: MapLandmarksMinAggregateOutputType | null
    _max: MapLandmarksMaxAggregateOutputType | null
  }

  export type MapLandmarksAvgAggregateOutputType = {
    landmarkID: number | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksSumAggregateOutputType = {
    landmarkID: number | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksMinAggregateOutputType = {
    landmarkID: number | null
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksMaxAggregateOutputType = {
    landmarkID: number | null
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksCountAggregateOutputType = {
    landmarkID: number
    landmarkName: number
    description: number
    locationID: number
    x: number
    y: number
    z: number
    iconID: number
    _all: number
  }


  export type MapLandmarksAvgAggregateInputType = {
    landmarkID?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksSumAggregateInputType = {
    landmarkID?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksMinAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksMaxAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksCountAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
    _all?: true
  }

  export type MapLandmarksAggregateArgs = {
    /**
     * Filter which mapLandmarks to aggregate.
     * 
    **/
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLandmarksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLandmarks
    **/
    _count?: true | MapLandmarksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLandmarksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLandmarksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLandmarksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLandmarksMaxAggregateInputType
  }

  export type GetMapLandmarksAggregateType<T extends MapLandmarksAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLandmarks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLandmarks[P]>
      : GetScalarType<T[P], AggregateMapLandmarks[P]>
  }




  export type MapLandmarksGroupByArgs = {
    where?: mapLandmarksWhereInput
    orderBy?: Enumerable<mapLandmarksOrderByWithAggregationInput>
    by: Array<MapLandmarksScalarFieldEnum>
    having?: mapLandmarksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLandmarksCountAggregateInputType | true
    _avg?: MapLandmarksAvgAggregateInputType
    _sum?: MapLandmarksSumAggregateInputType
    _min?: MapLandmarksMinAggregateInputType
    _max?: MapLandmarksMaxAggregateInputType
  }


  export type MapLandmarksGroupByOutputType = {
    landmarkID: number
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
    _count: MapLandmarksCountAggregateOutputType | null
    _avg: MapLandmarksAvgAggregateOutputType | null
    _sum: MapLandmarksSumAggregateOutputType | null
    _min: MapLandmarksMinAggregateOutputType | null
    _max: MapLandmarksMaxAggregateOutputType | null
  }

  type GetMapLandmarksGroupByPayload<T extends MapLandmarksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapLandmarksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLandmarksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLandmarksGroupByOutputType[P]>
            : GetScalarType<T[P], MapLandmarksGroupByOutputType[P]>
        }
      >
    >


  export type mapLandmarksSelect = {
    landmarkID?: boolean
    landmarkName?: boolean
    description?: boolean
    locationID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    iconID?: boolean
  }


  export type mapLandmarksGetPayload<S extends boolean | null | undefined | mapLandmarksArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapLandmarks :
    S extends undefined ? never :
    S extends { include: any } & (mapLandmarksArgs | mapLandmarksFindManyArgs)
    ? mapLandmarks 
    : S extends { select: any } & (mapLandmarksArgs | mapLandmarksFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapLandmarks ? mapLandmarks[P] : never
  } 
      : mapLandmarks


  type mapLandmarksCountArgs = Merge<
    Omit<mapLandmarksFindManyArgs, 'select' | 'include'> & {
      select?: MapLandmarksCountAggregateInputType | true
    }
  >

  export interface mapLandmarksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapLandmarks that matches the filter.
     * @param {mapLandmarksFindUniqueArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLandmarksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapLandmarksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapLandmarks'> extends True ? Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>> : Prisma__mapLandmarksClient<mapLandmarksGetPayload<T> | null, null>

    /**
     * Find the first MapLandmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindFirstArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLandmarksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapLandmarksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapLandmarks'> extends True ? Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>> : Prisma__mapLandmarksClient<mapLandmarksGetPayload<T> | null, null>

    /**
     * Find zero or more MapLandmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findMany()
     * 
     * // Get first 10 MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findMany({ take: 10 })
     * 
     * // Only select the `landmarkID`
     * const mapLandmarksWithLandmarkIDOnly = await prisma.mapLandmarks.findMany({ select: { landmarkID: true } })
     * 
    **/
    findMany<T extends mapLandmarksFindManyArgs>(
      args?: SelectSubset<T, mapLandmarksFindManyArgs>
    ): PrismaPromise<Array<mapLandmarksGetPayload<T>>>

    /**
     * Create a MapLandmarks.
     * @param {mapLandmarksCreateArgs} args - Arguments to create a MapLandmarks.
     * @example
     * // Create one MapLandmarks
     * const MapLandmarks = await prisma.mapLandmarks.create({
     *   data: {
     *     // ... data to create a MapLandmarks
     *   }
     * })
     * 
    **/
    create<T extends mapLandmarksCreateArgs>(
      args: SelectSubset<T, mapLandmarksCreateArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Create many MapLandmarks.
     *     @param {mapLandmarksCreateManyArgs} args - Arguments to create many MapLandmarks.
     *     @example
     *     // Create many MapLandmarks
     *     const mapLandmarks = await prisma.mapLandmarks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLandmarksCreateManyArgs>(
      args?: SelectSubset<T, mapLandmarksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapLandmarks.
     * @param {mapLandmarksDeleteArgs} args - Arguments to delete one MapLandmarks.
     * @example
     * // Delete one MapLandmarks
     * const MapLandmarks = await prisma.mapLandmarks.delete({
     *   where: {
     *     // ... filter to delete one MapLandmarks
     *   }
     * })
     * 
    **/
    delete<T extends mapLandmarksDeleteArgs>(
      args: SelectSubset<T, mapLandmarksDeleteArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Update one MapLandmarks.
     * @param {mapLandmarksUpdateArgs} args - Arguments to update one MapLandmarks.
     * @example
     * // Update one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLandmarksUpdateArgs>(
      args: SelectSubset<T, mapLandmarksUpdateArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Delete zero or more MapLandmarks.
     * @param {mapLandmarksDeleteManyArgs} args - Arguments to filter MapLandmarks to delete.
     * @example
     * // Delete a few MapLandmarks
     * const { count } = await prisma.mapLandmarks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLandmarksDeleteManyArgs>(
      args?: SelectSubset<T, mapLandmarksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLandmarksUpdateManyArgs>(
      args: SelectSubset<T, mapLandmarksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLandmarks.
     * @param {mapLandmarksUpsertArgs} args - Arguments to update or create a MapLandmarks.
     * @example
     * // Update or create a MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.upsert({
     *   create: {
     *     // ... data to create a MapLandmarks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLandmarks we want to update
     *   }
     * })
    **/
    upsert<T extends mapLandmarksUpsertArgs>(
      args: SelectSubset<T, mapLandmarksUpsertArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Find one MapLandmarks that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapLandmarksFindUniqueOrThrowArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLandmarksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapLandmarksFindUniqueOrThrowArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Find the first MapLandmarks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindFirstOrThrowArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLandmarksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapLandmarksFindFirstOrThrowArgs>
    ): Prisma__mapLandmarksClient<mapLandmarksGetPayload<T>>

    /**
     * Count the number of MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksCountArgs} args - Arguments to filter MapLandmarks to count.
     * @example
     * // Count the number of MapLandmarks
     * const count = await prisma.mapLandmarks.count({
     *   where: {
     *     // ... the filter for the MapLandmarks we want to count
     *   }
     * })
    **/
    count<T extends mapLandmarksCountArgs>(
      args?: Subset<T, mapLandmarksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLandmarksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLandmarksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLandmarksAggregateArgs>(args: Subset<T, MapLandmarksAggregateArgs>): PrismaPromise<GetMapLandmarksAggregateType<T>>

    /**
     * Group by MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLandmarksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapLandmarksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapLandmarksGroupByArgs['orderBy'] }
        : { orderBy?: MapLandmarksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapLandmarksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLandmarksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLandmarks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapLandmarksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapLandmarks base type for findUnique actions
   */
  export type mapLandmarksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * Filter, which mapLandmarks to fetch.
     * 
    **/
    where: mapLandmarksWhereUniqueInput
  }

  /**
   * mapLandmarks: findUnique
   */
  export interface mapLandmarksFindUniqueArgs extends mapLandmarksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLandmarks base type for findFirst actions
   */
  export type mapLandmarksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * Filter, which mapLandmarks to fetch.
     * 
    **/
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLandmarksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLandmarks.
     * 
    **/
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLandmarks.
     * 
    **/
    distinct?: Enumerable<MapLandmarksScalarFieldEnum>
  }

  /**
   * mapLandmarks: findFirst
   */
  export interface mapLandmarksFindFirstArgs extends mapLandmarksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLandmarks findMany
   */
  export type mapLandmarksFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * Filter, which mapLandmarks to fetch.
     * 
    **/
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLandmarksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLandmarks.
     * 
    **/
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapLandmarksScalarFieldEnum>
  }


  /**
   * mapLandmarks create
   */
  export type mapLandmarksCreateArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * The data needed to create a mapLandmarks.
     * 
    **/
    data: XOR<mapLandmarksCreateInput, mapLandmarksUncheckedCreateInput>
  }


  /**
   * mapLandmarks createMany
   */
  export type mapLandmarksCreateManyArgs = {
    /**
     * The data used to create many mapLandmarks.
     * 
    **/
    data: Enumerable<mapLandmarksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapLandmarks update
   */
  export type mapLandmarksUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * The data needed to update a mapLandmarks.
     * 
    **/
    data: XOR<mapLandmarksUpdateInput, mapLandmarksUncheckedUpdateInput>
    /**
     * Choose, which mapLandmarks to update.
     * 
    **/
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks updateMany
   */
  export type mapLandmarksUpdateManyArgs = {
    /**
     * The data used to update mapLandmarks.
     * 
    **/
    data: XOR<mapLandmarksUpdateManyMutationInput, mapLandmarksUncheckedUpdateManyInput>
    /**
     * Filter which mapLandmarks to update
     * 
    **/
    where?: mapLandmarksWhereInput
  }


  /**
   * mapLandmarks upsert
   */
  export type mapLandmarksUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * The filter to search for the mapLandmarks to update in case it exists.
     * 
    **/
    where: mapLandmarksWhereUniqueInput
    /**
     * In case the mapLandmarks found by the `where` argument doesn't exist, create a new mapLandmarks with this data.
     * 
    **/
    create: XOR<mapLandmarksCreateInput, mapLandmarksUncheckedCreateInput>
    /**
     * In case the mapLandmarks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapLandmarksUpdateInput, mapLandmarksUncheckedUpdateInput>
  }


  /**
   * mapLandmarks delete
   */
  export type mapLandmarksDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
    /**
     * Filter which mapLandmarks to delete.
     * 
    **/
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks deleteMany
   */
  export type mapLandmarksDeleteManyArgs = {
    /**
     * Filter which mapLandmarks to delete
     * 
    **/
    where?: mapLandmarksWhereInput
  }


  /**
   * mapLandmarks: findUniqueOrThrow
   */
  export type mapLandmarksFindUniqueOrThrowArgs = mapLandmarksFindUniqueArgsBase
      

  /**
   * mapLandmarks: findFirstOrThrow
   */
  export type mapLandmarksFindFirstOrThrowArgs = mapLandmarksFindFirstArgsBase
      

  /**
   * mapLandmarks without action
   */
  export type mapLandmarksArgs = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     * 
    **/
    select?: mapLandmarksSelect | null
  }



  /**
   * Model mapLocationScenes
   */


  export type AggregateMapLocationScenes = {
    _count: MapLocationScenesCountAggregateOutputType | null
    _avg: MapLocationScenesAvgAggregateOutputType | null
    _sum: MapLocationScenesSumAggregateOutputType | null
    _min: MapLocationScenesMinAggregateOutputType | null
    _max: MapLocationScenesMaxAggregateOutputType | null
  }

  export type MapLocationScenesAvgAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesSumAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesMinAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesMaxAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesCountAggregateOutputType = {
    locationID: number
    graphicID: number
    _all: number
  }


  export type MapLocationScenesAvgAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesSumAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesMinAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesMaxAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesCountAggregateInputType = {
    locationID?: true
    graphicID?: true
    _all?: true
  }

  export type MapLocationScenesAggregateArgs = {
    /**
     * Filter which mapLocationScenes to aggregate.
     * 
    **/
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationScenesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLocationScenes
    **/
    _count?: true | MapLocationScenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLocationScenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLocationScenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLocationScenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLocationScenesMaxAggregateInputType
  }

  export type GetMapLocationScenesAggregateType<T extends MapLocationScenesAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLocationScenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLocationScenes[P]>
      : GetScalarType<T[P], AggregateMapLocationScenes[P]>
  }




  export type MapLocationScenesGroupByArgs = {
    where?: mapLocationScenesWhereInput
    orderBy?: Enumerable<mapLocationScenesOrderByWithAggregationInput>
    by: Array<MapLocationScenesScalarFieldEnum>
    having?: mapLocationScenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLocationScenesCountAggregateInputType | true
    _avg?: MapLocationScenesAvgAggregateInputType
    _sum?: MapLocationScenesSumAggregateInputType
    _min?: MapLocationScenesMinAggregateInputType
    _max?: MapLocationScenesMaxAggregateInputType
  }


  export type MapLocationScenesGroupByOutputType = {
    locationID: number
    graphicID: number | null
    _count: MapLocationScenesCountAggregateOutputType | null
    _avg: MapLocationScenesAvgAggregateOutputType | null
    _sum: MapLocationScenesSumAggregateOutputType | null
    _min: MapLocationScenesMinAggregateOutputType | null
    _max: MapLocationScenesMaxAggregateOutputType | null
  }

  type GetMapLocationScenesGroupByPayload<T extends MapLocationScenesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapLocationScenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLocationScenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLocationScenesGroupByOutputType[P]>
            : GetScalarType<T[P], MapLocationScenesGroupByOutputType[P]>
        }
      >
    >


  export type mapLocationScenesSelect = {
    locationID?: boolean
    graphicID?: boolean
  }


  export type mapLocationScenesGetPayload<S extends boolean | null | undefined | mapLocationScenesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapLocationScenes :
    S extends undefined ? never :
    S extends { include: any } & (mapLocationScenesArgs | mapLocationScenesFindManyArgs)
    ? mapLocationScenes 
    : S extends { select: any } & (mapLocationScenesArgs | mapLocationScenesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapLocationScenes ? mapLocationScenes[P] : never
  } 
      : mapLocationScenes


  type mapLocationScenesCountArgs = Merge<
    Omit<mapLocationScenesFindManyArgs, 'select' | 'include'> & {
      select?: MapLocationScenesCountAggregateInputType | true
    }
  >

  export interface mapLocationScenesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapLocationScenes that matches the filter.
     * @param {mapLocationScenesFindUniqueArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLocationScenesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapLocationScenesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapLocationScenes'> extends True ? Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>> : Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T> | null, null>

    /**
     * Find the first MapLocationScenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindFirstArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLocationScenesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapLocationScenesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapLocationScenes'> extends True ? Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>> : Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T> | null, null>

    /**
     * Find zero or more MapLocationScenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findMany()
     * 
     * // Get first 10 MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findMany({ take: 10 })
     * 
     * // Only select the `locationID`
     * const mapLocationScenesWithLocationIDOnly = await prisma.mapLocationScenes.findMany({ select: { locationID: true } })
     * 
    **/
    findMany<T extends mapLocationScenesFindManyArgs>(
      args?: SelectSubset<T, mapLocationScenesFindManyArgs>
    ): PrismaPromise<Array<mapLocationScenesGetPayload<T>>>

    /**
     * Create a MapLocationScenes.
     * @param {mapLocationScenesCreateArgs} args - Arguments to create a MapLocationScenes.
     * @example
     * // Create one MapLocationScenes
     * const MapLocationScenes = await prisma.mapLocationScenes.create({
     *   data: {
     *     // ... data to create a MapLocationScenes
     *   }
     * })
     * 
    **/
    create<T extends mapLocationScenesCreateArgs>(
      args: SelectSubset<T, mapLocationScenesCreateArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Create many MapLocationScenes.
     *     @param {mapLocationScenesCreateManyArgs} args - Arguments to create many MapLocationScenes.
     *     @example
     *     // Create many MapLocationScenes
     *     const mapLocationScenes = await prisma.mapLocationScenes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLocationScenesCreateManyArgs>(
      args?: SelectSubset<T, mapLocationScenesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapLocationScenes.
     * @param {mapLocationScenesDeleteArgs} args - Arguments to delete one MapLocationScenes.
     * @example
     * // Delete one MapLocationScenes
     * const MapLocationScenes = await prisma.mapLocationScenes.delete({
     *   where: {
     *     // ... filter to delete one MapLocationScenes
     *   }
     * })
     * 
    **/
    delete<T extends mapLocationScenesDeleteArgs>(
      args: SelectSubset<T, mapLocationScenesDeleteArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Update one MapLocationScenes.
     * @param {mapLocationScenesUpdateArgs} args - Arguments to update one MapLocationScenes.
     * @example
     * // Update one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLocationScenesUpdateArgs>(
      args: SelectSubset<T, mapLocationScenesUpdateArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Delete zero or more MapLocationScenes.
     * @param {mapLocationScenesDeleteManyArgs} args - Arguments to filter MapLocationScenes to delete.
     * @example
     * // Delete a few MapLocationScenes
     * const { count } = await prisma.mapLocationScenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLocationScenesDeleteManyArgs>(
      args?: SelectSubset<T, mapLocationScenesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLocationScenesUpdateManyArgs>(
      args: SelectSubset<T, mapLocationScenesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLocationScenes.
     * @param {mapLocationScenesUpsertArgs} args - Arguments to update or create a MapLocationScenes.
     * @example
     * // Update or create a MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.upsert({
     *   create: {
     *     // ... data to create a MapLocationScenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLocationScenes we want to update
     *   }
     * })
    **/
    upsert<T extends mapLocationScenesUpsertArgs>(
      args: SelectSubset<T, mapLocationScenesUpsertArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Find one MapLocationScenes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapLocationScenesFindUniqueOrThrowArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLocationScenesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapLocationScenesFindUniqueOrThrowArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Find the first MapLocationScenes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindFirstOrThrowArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLocationScenesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapLocationScenesFindFirstOrThrowArgs>
    ): Prisma__mapLocationScenesClient<mapLocationScenesGetPayload<T>>

    /**
     * Count the number of MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesCountArgs} args - Arguments to filter MapLocationScenes to count.
     * @example
     * // Count the number of MapLocationScenes
     * const count = await prisma.mapLocationScenes.count({
     *   where: {
     *     // ... the filter for the MapLocationScenes we want to count
     *   }
     * })
    **/
    count<T extends mapLocationScenesCountArgs>(
      args?: Subset<T, mapLocationScenesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLocationScenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationScenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLocationScenesAggregateArgs>(args: Subset<T, MapLocationScenesAggregateArgs>): PrismaPromise<GetMapLocationScenesAggregateType<T>>

    /**
     * Group by MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationScenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapLocationScenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapLocationScenesGroupByArgs['orderBy'] }
        : { orderBy?: MapLocationScenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapLocationScenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLocationScenesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLocationScenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapLocationScenesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapLocationScenes base type for findUnique actions
   */
  export type mapLocationScenesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * Filter, which mapLocationScenes to fetch.
     * 
    **/
    where: mapLocationScenesWhereUniqueInput
  }

  /**
   * mapLocationScenes: findUnique
   */
  export interface mapLocationScenesFindUniqueArgs extends mapLocationScenesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLocationScenes base type for findFirst actions
   */
  export type mapLocationScenesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * Filter, which mapLocationScenes to fetch.
     * 
    **/
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationScenesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationScenes.
     * 
    **/
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationScenes.
     * 
    **/
    distinct?: Enumerable<MapLocationScenesScalarFieldEnum>
  }

  /**
   * mapLocationScenes: findFirst
   */
  export interface mapLocationScenesFindFirstArgs extends mapLocationScenesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLocationScenes findMany
   */
  export type mapLocationScenesFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * Filter, which mapLocationScenes to fetch.
     * 
    **/
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationScenesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLocationScenes.
     * 
    **/
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapLocationScenesScalarFieldEnum>
  }


  /**
   * mapLocationScenes create
   */
  export type mapLocationScenesCreateArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * The data needed to create a mapLocationScenes.
     * 
    **/
    data: XOR<mapLocationScenesCreateInput, mapLocationScenesUncheckedCreateInput>
  }


  /**
   * mapLocationScenes createMany
   */
  export type mapLocationScenesCreateManyArgs = {
    /**
     * The data used to create many mapLocationScenes.
     * 
    **/
    data: Enumerable<mapLocationScenesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapLocationScenes update
   */
  export type mapLocationScenesUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * The data needed to update a mapLocationScenes.
     * 
    **/
    data: XOR<mapLocationScenesUpdateInput, mapLocationScenesUncheckedUpdateInput>
    /**
     * Choose, which mapLocationScenes to update.
     * 
    **/
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes updateMany
   */
  export type mapLocationScenesUpdateManyArgs = {
    /**
     * The data used to update mapLocationScenes.
     * 
    **/
    data: XOR<mapLocationScenesUpdateManyMutationInput, mapLocationScenesUncheckedUpdateManyInput>
    /**
     * Filter which mapLocationScenes to update
     * 
    **/
    where?: mapLocationScenesWhereInput
  }


  /**
   * mapLocationScenes upsert
   */
  export type mapLocationScenesUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * The filter to search for the mapLocationScenes to update in case it exists.
     * 
    **/
    where: mapLocationScenesWhereUniqueInput
    /**
     * In case the mapLocationScenes found by the `where` argument doesn't exist, create a new mapLocationScenes with this data.
     * 
    **/
    create: XOR<mapLocationScenesCreateInput, mapLocationScenesUncheckedCreateInput>
    /**
     * In case the mapLocationScenes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapLocationScenesUpdateInput, mapLocationScenesUncheckedUpdateInput>
  }


  /**
   * mapLocationScenes delete
   */
  export type mapLocationScenesDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
    /**
     * Filter which mapLocationScenes to delete.
     * 
    **/
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes deleteMany
   */
  export type mapLocationScenesDeleteManyArgs = {
    /**
     * Filter which mapLocationScenes to delete
     * 
    **/
    where?: mapLocationScenesWhereInput
  }


  /**
   * mapLocationScenes: findUniqueOrThrow
   */
  export type mapLocationScenesFindUniqueOrThrowArgs = mapLocationScenesFindUniqueArgsBase
      

  /**
   * mapLocationScenes: findFirstOrThrow
   */
  export type mapLocationScenesFindFirstOrThrowArgs = mapLocationScenesFindFirstArgsBase
      

  /**
   * mapLocationScenes without action
   */
  export type mapLocationScenesArgs = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     * 
    **/
    select?: mapLocationScenesSelect | null
  }



  /**
   * Model mapLocationWormholeClasses
   */


  export type AggregateMapLocationWormholeClasses = {
    _count: MapLocationWormholeClassesCountAggregateOutputType | null
    _avg: MapLocationWormholeClassesAvgAggregateOutputType | null
    _sum: MapLocationWormholeClassesSumAggregateOutputType | null
    _min: MapLocationWormholeClassesMinAggregateOutputType | null
    _max: MapLocationWormholeClassesMaxAggregateOutputType | null
  }

  export type MapLocationWormholeClassesAvgAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesSumAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesMinAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesMaxAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesCountAggregateOutputType = {
    locationID: number
    wormholeClassID: number
    _all: number
  }


  export type MapLocationWormholeClassesAvgAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesSumAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesMinAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesMaxAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesCountAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
    _all?: true
  }

  export type MapLocationWormholeClassesAggregateArgs = {
    /**
     * Filter which mapLocationWormholeClasses to aggregate.
     * 
    **/
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationWormholeClassesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLocationWormholeClasses
    **/
    _count?: true | MapLocationWormholeClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLocationWormholeClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLocationWormholeClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLocationWormholeClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLocationWormholeClassesMaxAggregateInputType
  }

  export type GetMapLocationWormholeClassesAggregateType<T extends MapLocationWormholeClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLocationWormholeClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLocationWormholeClasses[P]>
      : GetScalarType<T[P], AggregateMapLocationWormholeClasses[P]>
  }




  export type MapLocationWormholeClassesGroupByArgs = {
    where?: mapLocationWormholeClassesWhereInput
    orderBy?: Enumerable<mapLocationWormholeClassesOrderByWithAggregationInput>
    by: Array<MapLocationWormholeClassesScalarFieldEnum>
    having?: mapLocationWormholeClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLocationWormholeClassesCountAggregateInputType | true
    _avg?: MapLocationWormholeClassesAvgAggregateInputType
    _sum?: MapLocationWormholeClassesSumAggregateInputType
    _min?: MapLocationWormholeClassesMinAggregateInputType
    _max?: MapLocationWormholeClassesMaxAggregateInputType
  }


  export type MapLocationWormholeClassesGroupByOutputType = {
    locationID: number
    wormholeClassID: number | null
    _count: MapLocationWormholeClassesCountAggregateOutputType | null
    _avg: MapLocationWormholeClassesAvgAggregateOutputType | null
    _sum: MapLocationWormholeClassesSumAggregateOutputType | null
    _min: MapLocationWormholeClassesMinAggregateOutputType | null
    _max: MapLocationWormholeClassesMaxAggregateOutputType | null
  }

  type GetMapLocationWormholeClassesGroupByPayload<T extends MapLocationWormholeClassesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapLocationWormholeClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLocationWormholeClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLocationWormholeClassesGroupByOutputType[P]>
            : GetScalarType<T[P], MapLocationWormholeClassesGroupByOutputType[P]>
        }
      >
    >


  export type mapLocationWormholeClassesSelect = {
    locationID?: boolean
    wormholeClassID?: boolean
  }


  export type mapLocationWormholeClassesGetPayload<S extends boolean | null | undefined | mapLocationWormholeClassesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapLocationWormholeClasses :
    S extends undefined ? never :
    S extends { include: any } & (mapLocationWormholeClassesArgs | mapLocationWormholeClassesFindManyArgs)
    ? mapLocationWormholeClasses 
    : S extends { select: any } & (mapLocationWormholeClassesArgs | mapLocationWormholeClassesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapLocationWormholeClasses ? mapLocationWormholeClasses[P] : never
  } 
      : mapLocationWormholeClasses


  type mapLocationWormholeClassesCountArgs = Merge<
    Omit<mapLocationWormholeClassesFindManyArgs, 'select' | 'include'> & {
      select?: MapLocationWormholeClassesCountAggregateInputType | true
    }
  >

  export interface mapLocationWormholeClassesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapLocationWormholeClasses that matches the filter.
     * @param {mapLocationWormholeClassesFindUniqueArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLocationWormholeClassesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapLocationWormholeClassesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapLocationWormholeClasses'> extends True ? Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>> : Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T> | null, null>

    /**
     * Find the first MapLocationWormholeClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindFirstArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLocationWormholeClassesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapLocationWormholeClasses'> extends True ? Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>> : Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T> | null, null>

    /**
     * Find zero or more MapLocationWormholeClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany()
     * 
     * // Get first 10 MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany({ take: 10 })
     * 
     * // Only select the `locationID`
     * const mapLocationWormholeClassesWithLocationIDOnly = await prisma.mapLocationWormholeClasses.findMany({ select: { locationID: true } })
     * 
    **/
    findMany<T extends mapLocationWormholeClassesFindManyArgs>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindManyArgs>
    ): PrismaPromise<Array<mapLocationWormholeClassesGetPayload<T>>>

    /**
     * Create a MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesCreateArgs} args - Arguments to create a MapLocationWormholeClasses.
     * @example
     * // Create one MapLocationWormholeClasses
     * const MapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.create({
     *   data: {
     *     // ... data to create a MapLocationWormholeClasses
     *   }
     * })
     * 
    **/
    create<T extends mapLocationWormholeClassesCreateArgs>(
      args: SelectSubset<T, mapLocationWormholeClassesCreateArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Create many MapLocationWormholeClasses.
     *     @param {mapLocationWormholeClassesCreateManyArgs} args - Arguments to create many MapLocationWormholeClasses.
     *     @example
     *     // Create many MapLocationWormholeClasses
     *     const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLocationWormholeClassesCreateManyArgs>(
      args?: SelectSubset<T, mapLocationWormholeClassesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesDeleteArgs} args - Arguments to delete one MapLocationWormholeClasses.
     * @example
     * // Delete one MapLocationWormholeClasses
     * const MapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.delete({
     *   where: {
     *     // ... filter to delete one MapLocationWormholeClasses
     *   }
     * })
     * 
    **/
    delete<T extends mapLocationWormholeClassesDeleteArgs>(
      args: SelectSubset<T, mapLocationWormholeClassesDeleteArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Update one MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesUpdateArgs} args - Arguments to update one MapLocationWormholeClasses.
     * @example
     * // Update one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLocationWormholeClassesUpdateArgs>(
      args: SelectSubset<T, mapLocationWormholeClassesUpdateArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Delete zero or more MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesDeleteManyArgs} args - Arguments to filter MapLocationWormholeClasses to delete.
     * @example
     * // Delete a few MapLocationWormholeClasses
     * const { count } = await prisma.mapLocationWormholeClasses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLocationWormholeClassesDeleteManyArgs>(
      args?: SelectSubset<T, mapLocationWormholeClassesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLocationWormholeClassesUpdateManyArgs>(
      args: SelectSubset<T, mapLocationWormholeClassesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesUpsertArgs} args - Arguments to update or create a MapLocationWormholeClasses.
     * @example
     * // Update or create a MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.upsert({
     *   create: {
     *     // ... data to create a MapLocationWormholeClasses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLocationWormholeClasses we want to update
     *   }
     * })
    **/
    upsert<T extends mapLocationWormholeClassesUpsertArgs>(
      args: SelectSubset<T, mapLocationWormholeClassesUpsertArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Find one MapLocationWormholeClasses that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapLocationWormholeClassesFindUniqueOrThrowArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLocationWormholeClassesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindUniqueOrThrowArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Find the first MapLocationWormholeClasses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindFirstOrThrowArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLocationWormholeClassesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindFirstOrThrowArgs>
    ): Prisma__mapLocationWormholeClassesClient<mapLocationWormholeClassesGetPayload<T>>

    /**
     * Count the number of MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesCountArgs} args - Arguments to filter MapLocationWormholeClasses to count.
     * @example
     * // Count the number of MapLocationWormholeClasses
     * const count = await prisma.mapLocationWormholeClasses.count({
     *   where: {
     *     // ... the filter for the MapLocationWormholeClasses we want to count
     *   }
     * })
    **/
    count<T extends mapLocationWormholeClassesCountArgs>(
      args?: Subset<T, mapLocationWormholeClassesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLocationWormholeClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationWormholeClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLocationWormholeClassesAggregateArgs>(args: Subset<T, MapLocationWormholeClassesAggregateArgs>): PrismaPromise<GetMapLocationWormholeClassesAggregateType<T>>

    /**
     * Group by MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationWormholeClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapLocationWormholeClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapLocationWormholeClassesGroupByArgs['orderBy'] }
        : { orderBy?: MapLocationWormholeClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapLocationWormholeClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLocationWormholeClassesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLocationWormholeClasses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapLocationWormholeClassesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapLocationWormholeClasses base type for findUnique actions
   */
  export type mapLocationWormholeClassesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     * 
    **/
    where: mapLocationWormholeClassesWhereUniqueInput
  }

  /**
   * mapLocationWormholeClasses: findUnique
   */
  export interface mapLocationWormholeClassesFindUniqueArgs extends mapLocationWormholeClassesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLocationWormholeClasses base type for findFirst actions
   */
  export type mapLocationWormholeClassesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     * 
    **/
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationWormholeClassesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationWormholeClasses.
     * 
    **/
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationWormholeClasses.
     * 
    **/
    distinct?: Enumerable<MapLocationWormholeClassesScalarFieldEnum>
  }

  /**
   * mapLocationWormholeClasses: findFirst
   */
  export interface mapLocationWormholeClassesFindFirstArgs extends mapLocationWormholeClassesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapLocationWormholeClasses findMany
   */
  export type mapLocationWormholeClassesFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     * 
    **/
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapLocationWormholeClassesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLocationWormholeClasses.
     * 
    **/
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapLocationWormholeClassesScalarFieldEnum>
  }


  /**
   * mapLocationWormholeClasses create
   */
  export type mapLocationWormholeClassesCreateArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * The data needed to create a mapLocationWormholeClasses.
     * 
    **/
    data: XOR<mapLocationWormholeClassesCreateInput, mapLocationWormholeClassesUncheckedCreateInput>
  }


  /**
   * mapLocationWormholeClasses createMany
   */
  export type mapLocationWormholeClassesCreateManyArgs = {
    /**
     * The data used to create many mapLocationWormholeClasses.
     * 
    **/
    data: Enumerable<mapLocationWormholeClassesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapLocationWormholeClasses update
   */
  export type mapLocationWormholeClassesUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * The data needed to update a mapLocationWormholeClasses.
     * 
    **/
    data: XOR<mapLocationWormholeClassesUpdateInput, mapLocationWormholeClassesUncheckedUpdateInput>
    /**
     * Choose, which mapLocationWormholeClasses to update.
     * 
    **/
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses updateMany
   */
  export type mapLocationWormholeClassesUpdateManyArgs = {
    /**
     * The data used to update mapLocationWormholeClasses.
     * 
    **/
    data: XOR<mapLocationWormholeClassesUpdateManyMutationInput, mapLocationWormholeClassesUncheckedUpdateManyInput>
    /**
     * Filter which mapLocationWormholeClasses to update
     * 
    **/
    where?: mapLocationWormholeClassesWhereInput
  }


  /**
   * mapLocationWormholeClasses upsert
   */
  export type mapLocationWormholeClassesUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * The filter to search for the mapLocationWormholeClasses to update in case it exists.
     * 
    **/
    where: mapLocationWormholeClassesWhereUniqueInput
    /**
     * In case the mapLocationWormholeClasses found by the `where` argument doesn't exist, create a new mapLocationWormholeClasses with this data.
     * 
    **/
    create: XOR<mapLocationWormholeClassesCreateInput, mapLocationWormholeClassesUncheckedCreateInput>
    /**
     * In case the mapLocationWormholeClasses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapLocationWormholeClassesUpdateInput, mapLocationWormholeClassesUncheckedUpdateInput>
  }


  /**
   * mapLocationWormholeClasses delete
   */
  export type mapLocationWormholeClassesDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
    /**
     * Filter which mapLocationWormholeClasses to delete.
     * 
    **/
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses deleteMany
   */
  export type mapLocationWormholeClassesDeleteManyArgs = {
    /**
     * Filter which mapLocationWormholeClasses to delete
     * 
    **/
    where?: mapLocationWormholeClassesWhereInput
  }


  /**
   * mapLocationWormholeClasses: findUniqueOrThrow
   */
  export type mapLocationWormholeClassesFindUniqueOrThrowArgs = mapLocationWormholeClassesFindUniqueArgsBase
      

  /**
   * mapLocationWormholeClasses: findFirstOrThrow
   */
  export type mapLocationWormholeClassesFindFirstOrThrowArgs = mapLocationWormholeClassesFindFirstArgsBase
      

  /**
   * mapLocationWormholeClasses without action
   */
  export type mapLocationWormholeClassesArgs = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     * 
    **/
    select?: mapLocationWormholeClassesSelect | null
  }



  /**
   * Model mapRegionJumps
   */


  export type AggregateMapRegionJumps = {
    _count: MapRegionJumpsCountAggregateOutputType | null
    _avg: MapRegionJumpsAvgAggregateOutputType | null
    _sum: MapRegionJumpsSumAggregateOutputType | null
    _min: MapRegionJumpsMinAggregateOutputType | null
    _max: MapRegionJumpsMaxAggregateOutputType | null
  }

  export type MapRegionJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsCountAggregateOutputType = {
    fromRegionID: number
    toRegionID: number
    _all: number
  }


  export type MapRegionJumpsAvgAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsSumAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsMinAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsMaxAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsCountAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapRegionJumpsAggregateArgs = {
    /**
     * Filter which mapRegionJumps to aggregate.
     * 
    **/
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapRegionJumps
    **/
    _count?: true | MapRegionJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapRegionJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapRegionJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapRegionJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapRegionJumpsMaxAggregateInputType
  }

  export type GetMapRegionJumpsAggregateType<T extends MapRegionJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapRegionJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapRegionJumps[P]>
      : GetScalarType<T[P], AggregateMapRegionJumps[P]>
  }




  export type MapRegionJumpsGroupByArgs = {
    where?: mapRegionJumpsWhereInput
    orderBy?: Enumerable<mapRegionJumpsOrderByWithAggregationInput>
    by: Array<MapRegionJumpsScalarFieldEnum>
    having?: mapRegionJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapRegionJumpsCountAggregateInputType | true
    _avg?: MapRegionJumpsAvgAggregateInputType
    _sum?: MapRegionJumpsSumAggregateInputType
    _min?: MapRegionJumpsMinAggregateInputType
    _max?: MapRegionJumpsMaxAggregateInputType
  }


  export type MapRegionJumpsGroupByOutputType = {
    fromRegionID: number
    toRegionID: number
    _count: MapRegionJumpsCountAggregateOutputType | null
    _avg: MapRegionJumpsAvgAggregateOutputType | null
    _sum: MapRegionJumpsSumAggregateOutputType | null
    _min: MapRegionJumpsMinAggregateOutputType | null
    _max: MapRegionJumpsMaxAggregateOutputType | null
  }

  type GetMapRegionJumpsGroupByPayload<T extends MapRegionJumpsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapRegionJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapRegionJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapRegionJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapRegionJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapRegionJumpsSelect = {
    fromRegionID?: boolean
    toRegionID?: boolean
  }


  export type mapRegionJumpsGetPayload<S extends boolean | null | undefined | mapRegionJumpsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapRegionJumps :
    S extends undefined ? never :
    S extends { include: any } & (mapRegionJumpsArgs | mapRegionJumpsFindManyArgs)
    ? mapRegionJumps 
    : S extends { select: any } & (mapRegionJumpsArgs | mapRegionJumpsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapRegionJumps ? mapRegionJumps[P] : never
  } 
      : mapRegionJumps


  type mapRegionJumpsCountArgs = Merge<
    Omit<mapRegionJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapRegionJumpsCountAggregateInputType | true
    }
  >

  export interface mapRegionJumpsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapRegionJumps that matches the filter.
     * @param {mapRegionJumpsFindUniqueArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapRegionJumpsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapRegionJumpsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapRegionJumps'> extends True ? Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>> : Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T> | null, null>

    /**
     * Find the first MapRegionJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindFirstArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapRegionJumpsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapRegionJumpsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapRegionJumps'> extends True ? Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>> : Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T> | null, null>

    /**
     * Find zero or more MapRegionJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findMany()
     * 
     * // Get first 10 MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapRegionJumpsWithFromRegionIDOnly = await prisma.mapRegionJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapRegionJumpsFindManyArgs>(
      args?: SelectSubset<T, mapRegionJumpsFindManyArgs>
    ): PrismaPromise<Array<mapRegionJumpsGetPayload<T>>>

    /**
     * Create a MapRegionJumps.
     * @param {mapRegionJumpsCreateArgs} args - Arguments to create a MapRegionJumps.
     * @example
     * // Create one MapRegionJumps
     * const MapRegionJumps = await prisma.mapRegionJumps.create({
     *   data: {
     *     // ... data to create a MapRegionJumps
     *   }
     * })
     * 
    **/
    create<T extends mapRegionJumpsCreateArgs>(
      args: SelectSubset<T, mapRegionJumpsCreateArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Create many MapRegionJumps.
     *     @param {mapRegionJumpsCreateManyArgs} args - Arguments to create many MapRegionJumps.
     *     @example
     *     // Create many MapRegionJumps
     *     const mapRegionJumps = await prisma.mapRegionJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapRegionJumpsCreateManyArgs>(
      args?: SelectSubset<T, mapRegionJumpsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapRegionJumps.
     * @param {mapRegionJumpsDeleteArgs} args - Arguments to delete one MapRegionJumps.
     * @example
     * // Delete one MapRegionJumps
     * const MapRegionJumps = await prisma.mapRegionJumps.delete({
     *   where: {
     *     // ... filter to delete one MapRegionJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapRegionJumpsDeleteArgs>(
      args: SelectSubset<T, mapRegionJumpsDeleteArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Update one MapRegionJumps.
     * @param {mapRegionJumpsUpdateArgs} args - Arguments to update one MapRegionJumps.
     * @example
     * // Update one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapRegionJumpsUpdateArgs>(
      args: SelectSubset<T, mapRegionJumpsUpdateArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Delete zero or more MapRegionJumps.
     * @param {mapRegionJumpsDeleteManyArgs} args - Arguments to filter MapRegionJumps to delete.
     * @example
     * // Delete a few MapRegionJumps
     * const { count } = await prisma.mapRegionJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapRegionJumpsDeleteManyArgs>(
      args?: SelectSubset<T, mapRegionJumpsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapRegionJumpsUpdateManyArgs>(
      args: SelectSubset<T, mapRegionJumpsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapRegionJumps.
     * @param {mapRegionJumpsUpsertArgs} args - Arguments to update or create a MapRegionJumps.
     * @example
     * // Update or create a MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.upsert({
     *   create: {
     *     // ... data to create a MapRegionJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapRegionJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapRegionJumpsUpsertArgs>(
      args: SelectSubset<T, mapRegionJumpsUpsertArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Find one MapRegionJumps that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapRegionJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapRegionJumpsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapRegionJumpsFindUniqueOrThrowArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Find the first MapRegionJumps that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindFirstOrThrowArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapRegionJumpsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapRegionJumpsFindFirstOrThrowArgs>
    ): Prisma__mapRegionJumpsClient<mapRegionJumpsGetPayload<T>>

    /**
     * Count the number of MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsCountArgs} args - Arguments to filter MapRegionJumps to count.
     * @example
     * // Count the number of MapRegionJumps
     * const count = await prisma.mapRegionJumps.count({
     *   where: {
     *     // ... the filter for the MapRegionJumps we want to count
     *   }
     * })
    **/
    count<T extends mapRegionJumpsCountArgs>(
      args?: Subset<T, mapRegionJumpsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapRegionJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapRegionJumpsAggregateArgs>(args: Subset<T, MapRegionJumpsAggregateArgs>): PrismaPromise<GetMapRegionJumpsAggregateType<T>>

    /**
     * Group by MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapRegionJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapRegionJumpsGroupByArgs['orderBy'] }
        : { orderBy?: MapRegionJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapRegionJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapRegionJumpsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapRegionJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapRegionJumpsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapRegionJumps base type for findUnique actions
   */
  export type mapRegionJumpsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * Filter, which mapRegionJumps to fetch.
     * 
    **/
    where: mapRegionJumpsWhereUniqueInput
  }

  /**
   * mapRegionJumps: findUnique
   */
  export interface mapRegionJumpsFindUniqueArgs extends mapRegionJumpsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapRegionJumps base type for findFirst actions
   */
  export type mapRegionJumpsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * Filter, which mapRegionJumps to fetch.
     * 
    **/
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegionJumps.
     * 
    **/
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegionJumps.
     * 
    **/
    distinct?: Enumerable<MapRegionJumpsScalarFieldEnum>
  }

  /**
   * mapRegionJumps: findFirst
   */
  export interface mapRegionJumpsFindFirstArgs extends mapRegionJumpsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapRegionJumps findMany
   */
  export type mapRegionJumpsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * Filter, which mapRegionJumps to fetch.
     * 
    **/
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapRegionJumps.
     * 
    **/
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapRegionJumpsScalarFieldEnum>
  }


  /**
   * mapRegionJumps create
   */
  export type mapRegionJumpsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * The data needed to create a mapRegionJumps.
     * 
    **/
    data: XOR<mapRegionJumpsCreateInput, mapRegionJumpsUncheckedCreateInput>
  }


  /**
   * mapRegionJumps createMany
   */
  export type mapRegionJumpsCreateManyArgs = {
    /**
     * The data used to create many mapRegionJumps.
     * 
    **/
    data: Enumerable<mapRegionJumpsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapRegionJumps update
   */
  export type mapRegionJumpsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * The data needed to update a mapRegionJumps.
     * 
    **/
    data: XOR<mapRegionJumpsUpdateInput, mapRegionJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapRegionJumps to update.
     * 
    **/
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps updateMany
   */
  export type mapRegionJumpsUpdateManyArgs = {
    /**
     * The data used to update mapRegionJumps.
     * 
    **/
    data: XOR<mapRegionJumpsUpdateManyMutationInput, mapRegionJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapRegionJumps to update
     * 
    **/
    where?: mapRegionJumpsWhereInput
  }


  /**
   * mapRegionJumps upsert
   */
  export type mapRegionJumpsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * The filter to search for the mapRegionJumps to update in case it exists.
     * 
    **/
    where: mapRegionJumpsWhereUniqueInput
    /**
     * In case the mapRegionJumps found by the `where` argument doesn't exist, create a new mapRegionJumps with this data.
     * 
    **/
    create: XOR<mapRegionJumpsCreateInput, mapRegionJumpsUncheckedCreateInput>
    /**
     * In case the mapRegionJumps was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapRegionJumpsUpdateInput, mapRegionJumpsUncheckedUpdateInput>
  }


  /**
   * mapRegionJumps delete
   */
  export type mapRegionJumpsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
    /**
     * Filter which mapRegionJumps to delete.
     * 
    **/
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps deleteMany
   */
  export type mapRegionJumpsDeleteManyArgs = {
    /**
     * Filter which mapRegionJumps to delete
     * 
    **/
    where?: mapRegionJumpsWhereInput
  }


  /**
   * mapRegionJumps: findUniqueOrThrow
   */
  export type mapRegionJumpsFindUniqueOrThrowArgs = mapRegionJumpsFindUniqueArgsBase
      

  /**
   * mapRegionJumps: findFirstOrThrow
   */
  export type mapRegionJumpsFindFirstOrThrowArgs = mapRegionJumpsFindFirstArgsBase
      

  /**
   * mapRegionJumps without action
   */
  export type mapRegionJumpsArgs = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     * 
    **/
    select?: mapRegionJumpsSelect | null
  }



  /**
   * Model mapRegions
   */


  export type AggregateMapRegions = {
    _count: MapRegionsCountAggregateOutputType | null
    _avg: MapRegionsAvgAggregateOutputType | null
    _sum: MapRegionsSumAggregateOutputType | null
    _min: MapRegionsMinAggregateOutputType | null
    _max: MapRegionsMaxAggregateOutputType | null
  }

  export type MapRegionsAvgAggregateOutputType = {
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsSumAggregateOutputType = {
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsMinAggregateOutputType = {
    regionID: number | null
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsMaxAggregateOutputType = {
    regionID: number | null
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsCountAggregateOutputType = {
    regionID: number
    regionName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    factionID: number
    nebula: number
    radius: number
    _all: number
  }


  export type MapRegionsAvgAggregateInputType = {
    regionID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsSumAggregateInputType = {
    regionID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsMinAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsMaxAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsCountAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
    _all?: true
  }

  export type MapRegionsAggregateArgs = {
    /**
     * Filter which mapRegions to aggregate.
     * 
    **/
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapRegions
    **/
    _count?: true | MapRegionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapRegionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapRegionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapRegionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapRegionsMaxAggregateInputType
  }

  export type GetMapRegionsAggregateType<T extends MapRegionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapRegions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapRegions[P]>
      : GetScalarType<T[P], AggregateMapRegions[P]>
  }




  export type MapRegionsGroupByArgs = {
    where?: mapRegionsWhereInput
    orderBy?: Enumerable<mapRegionsOrderByWithAggregationInput>
    by: Array<MapRegionsScalarFieldEnum>
    having?: mapRegionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapRegionsCountAggregateInputType | true
    _avg?: MapRegionsAvgAggregateInputType
    _sum?: MapRegionsSumAggregateInputType
    _min?: MapRegionsMinAggregateInputType
    _max?: MapRegionsMaxAggregateInputType
  }


  export type MapRegionsGroupByOutputType = {
    regionID: number
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
    _count: MapRegionsCountAggregateOutputType | null
    _avg: MapRegionsAvgAggregateOutputType | null
    _sum: MapRegionsSumAggregateOutputType | null
    _min: MapRegionsMinAggregateOutputType | null
    _max: MapRegionsMaxAggregateOutputType | null
  }

  type GetMapRegionsGroupByPayload<T extends MapRegionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapRegionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapRegionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapRegionsGroupByOutputType[P]>
            : GetScalarType<T[P], MapRegionsGroupByOutputType[P]>
        }
      >
    >


  export type mapRegionsSelect = {
    regionID?: boolean
    regionName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    nebula?: boolean
    radius?: boolean
  }


  export type mapRegionsGetPayload<S extends boolean | null | undefined | mapRegionsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapRegions :
    S extends undefined ? never :
    S extends { include: any } & (mapRegionsArgs | mapRegionsFindManyArgs)
    ? mapRegions 
    : S extends { select: any } & (mapRegionsArgs | mapRegionsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapRegions ? mapRegions[P] : never
  } 
      : mapRegions


  type mapRegionsCountArgs = Merge<
    Omit<mapRegionsFindManyArgs, 'select' | 'include'> & {
      select?: MapRegionsCountAggregateInputType | true
    }
  >

  export interface mapRegionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapRegions that matches the filter.
     * @param {mapRegionsFindUniqueArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapRegionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapRegionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapRegions'> extends True ? Prisma__mapRegionsClient<mapRegionsGetPayload<T>> : Prisma__mapRegionsClient<mapRegionsGetPayload<T> | null, null>

    /**
     * Find the first MapRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindFirstArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapRegionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapRegionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapRegions'> extends True ? Prisma__mapRegionsClient<mapRegionsGetPayload<T>> : Prisma__mapRegionsClient<mapRegionsGetPayload<T> | null, null>

    /**
     * Find zero or more MapRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapRegions
     * const mapRegions = await prisma.mapRegions.findMany()
     * 
     * // Get first 10 MapRegions
     * const mapRegions = await prisma.mapRegions.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapRegionsWithRegionIDOnly = await prisma.mapRegions.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapRegionsFindManyArgs>(
      args?: SelectSubset<T, mapRegionsFindManyArgs>
    ): PrismaPromise<Array<mapRegionsGetPayload<T>>>

    /**
     * Create a MapRegions.
     * @param {mapRegionsCreateArgs} args - Arguments to create a MapRegions.
     * @example
     * // Create one MapRegions
     * const MapRegions = await prisma.mapRegions.create({
     *   data: {
     *     // ... data to create a MapRegions
     *   }
     * })
     * 
    **/
    create<T extends mapRegionsCreateArgs>(
      args: SelectSubset<T, mapRegionsCreateArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Create many MapRegions.
     *     @param {mapRegionsCreateManyArgs} args - Arguments to create many MapRegions.
     *     @example
     *     // Create many MapRegions
     *     const mapRegions = await prisma.mapRegions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapRegionsCreateManyArgs>(
      args?: SelectSubset<T, mapRegionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapRegions.
     * @param {mapRegionsDeleteArgs} args - Arguments to delete one MapRegions.
     * @example
     * // Delete one MapRegions
     * const MapRegions = await prisma.mapRegions.delete({
     *   where: {
     *     // ... filter to delete one MapRegions
     *   }
     * })
     * 
    **/
    delete<T extends mapRegionsDeleteArgs>(
      args: SelectSubset<T, mapRegionsDeleteArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Update one MapRegions.
     * @param {mapRegionsUpdateArgs} args - Arguments to update one MapRegions.
     * @example
     * // Update one MapRegions
     * const mapRegions = await prisma.mapRegions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapRegionsUpdateArgs>(
      args: SelectSubset<T, mapRegionsUpdateArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Delete zero or more MapRegions.
     * @param {mapRegionsDeleteManyArgs} args - Arguments to filter MapRegions to delete.
     * @example
     * // Delete a few MapRegions
     * const { count } = await prisma.mapRegions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapRegionsDeleteManyArgs>(
      args?: SelectSubset<T, mapRegionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapRegions
     * const mapRegions = await prisma.mapRegions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapRegionsUpdateManyArgs>(
      args: SelectSubset<T, mapRegionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapRegions.
     * @param {mapRegionsUpsertArgs} args - Arguments to update or create a MapRegions.
     * @example
     * // Update or create a MapRegions
     * const mapRegions = await prisma.mapRegions.upsert({
     *   create: {
     *     // ... data to create a MapRegions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapRegions we want to update
     *   }
     * })
    **/
    upsert<T extends mapRegionsUpsertArgs>(
      args: SelectSubset<T, mapRegionsUpsertArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Find one MapRegions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapRegionsFindUniqueOrThrowArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapRegionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapRegionsFindUniqueOrThrowArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Find the first MapRegions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindFirstOrThrowArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapRegionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapRegionsFindFirstOrThrowArgs>
    ): Prisma__mapRegionsClient<mapRegionsGetPayload<T>>

    /**
     * Count the number of MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsCountArgs} args - Arguments to filter MapRegions to count.
     * @example
     * // Count the number of MapRegions
     * const count = await prisma.mapRegions.count({
     *   where: {
     *     // ... the filter for the MapRegions we want to count
     *   }
     * })
    **/
    count<T extends mapRegionsCountArgs>(
      args?: Subset<T, mapRegionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapRegionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapRegionsAggregateArgs>(args: Subset<T, MapRegionsAggregateArgs>): PrismaPromise<GetMapRegionsAggregateType<T>>

    /**
     * Group by MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapRegionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapRegionsGroupByArgs['orderBy'] }
        : { orderBy?: MapRegionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapRegionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapRegionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapRegions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapRegionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapRegions base type for findUnique actions
   */
  export type mapRegionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * Filter, which mapRegions to fetch.
     * 
    **/
    where: mapRegionsWhereUniqueInput
  }

  /**
   * mapRegions: findUnique
   */
  export interface mapRegionsFindUniqueArgs extends mapRegionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapRegions base type for findFirst actions
   */
  export type mapRegionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * Filter, which mapRegions to fetch.
     * 
    **/
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegions.
     * 
    **/
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegions.
     * 
    **/
    distinct?: Enumerable<MapRegionsScalarFieldEnum>
  }

  /**
   * mapRegions: findFirst
   */
  export interface mapRegionsFindFirstArgs extends mapRegionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapRegions findMany
   */
  export type mapRegionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * Filter, which mapRegions to fetch.
     * 
    **/
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<mapRegionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapRegions.
     * 
    **/
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapRegionsScalarFieldEnum>
  }


  /**
   * mapRegions create
   */
  export type mapRegionsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * The data needed to create a mapRegions.
     * 
    **/
    data: XOR<mapRegionsCreateInput, mapRegionsUncheckedCreateInput>
  }


  /**
   * mapRegions createMany
   */
  export type mapRegionsCreateManyArgs = {
    /**
     * The data used to create many mapRegions.
     * 
    **/
    data: Enumerable<mapRegionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapRegions update
   */
  export type mapRegionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * The data needed to update a mapRegions.
     * 
    **/
    data: XOR<mapRegionsUpdateInput, mapRegionsUncheckedUpdateInput>
    /**
     * Choose, which mapRegions to update.
     * 
    **/
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions updateMany
   */
  export type mapRegionsUpdateManyArgs = {
    /**
     * The data used to update mapRegions.
     * 
    **/
    data: XOR<mapRegionsUpdateManyMutationInput, mapRegionsUncheckedUpdateManyInput>
    /**
     * Filter which mapRegions to update
     * 
    **/
    where?: mapRegionsWhereInput
  }


  /**
   * mapRegions upsert
   */
  export type mapRegionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * The filter to search for the mapRegions to update in case it exists.
     * 
    **/
    where: mapRegionsWhereUniqueInput
    /**
     * In case the mapRegions found by the `where` argument doesn't exist, create a new mapRegions with this data.
     * 
    **/
    create: XOR<mapRegionsCreateInput, mapRegionsUncheckedCreateInput>
    /**
     * In case the mapRegions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapRegionsUpdateInput, mapRegionsUncheckedUpdateInput>
  }


  /**
   * mapRegions delete
   */
  export type mapRegionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
    /**
     * Filter which mapRegions to delete.
     * 
    **/
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions deleteMany
   */
  export type mapRegionsDeleteManyArgs = {
    /**
     * Filter which mapRegions to delete
     * 
    **/
    where?: mapRegionsWhereInput
  }


  /**
   * mapRegions: findUniqueOrThrow
   */
  export type mapRegionsFindUniqueOrThrowArgs = mapRegionsFindUniqueArgsBase
      

  /**
   * mapRegions: findFirstOrThrow
   */
  export type mapRegionsFindFirstOrThrowArgs = mapRegionsFindFirstArgsBase
      

  /**
   * mapRegions without action
   */
  export type mapRegionsArgs = {
    /**
     * Select specific fields to fetch from the mapRegions
     * 
    **/
    select?: mapRegionsSelect | null
  }



  /**
   * Model mapSolarSystemJumps
   */


  export type AggregateMapSolarSystemJumps = {
    _count: MapSolarSystemJumpsCountAggregateOutputType | null
    _avg: MapSolarSystemJumpsAvgAggregateOutputType | null
    _sum: MapSolarSystemJumpsSumAggregateOutputType | null
    _min: MapSolarSystemJumpsMinAggregateOutputType | null
    _max: MapSolarSystemJumpsMaxAggregateOutputType | null
  }

  export type MapSolarSystemJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsCountAggregateOutputType = {
    fromRegionID: number
    fromConstellationID: number
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID: number
    toRegionID: number
    _all: number
  }


  export type MapSolarSystemJumpsAvgAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsSumAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsMinAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsMaxAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsCountAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapSolarSystemJumpsAggregateArgs = {
    /**
     * Filter which mapSolarSystemJumps to aggregate.
     * 
    **/
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapSolarSystemJumps
    **/
    _count?: true | MapSolarSystemJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapSolarSystemJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSolarSystemJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapSolarSystemJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapSolarSystemJumpsMaxAggregateInputType
  }

  export type GetMapSolarSystemJumpsAggregateType<T extends MapSolarSystemJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapSolarSystemJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapSolarSystemJumps[P]>
      : GetScalarType<T[P], AggregateMapSolarSystemJumps[P]>
  }




  export type MapSolarSystemJumpsGroupByArgs = {
    where?: mapSolarSystemJumpsWhereInput
    orderBy?: Enumerable<mapSolarSystemJumpsOrderByWithAggregationInput>
    by: Array<MapSolarSystemJumpsScalarFieldEnum>
    having?: mapSolarSystemJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapSolarSystemJumpsCountAggregateInputType | true
    _avg?: MapSolarSystemJumpsAvgAggregateInputType
    _sum?: MapSolarSystemJumpsSumAggregateInputType
    _min?: MapSolarSystemJumpsMinAggregateInputType
    _max?: MapSolarSystemJumpsMaxAggregateInputType
  }


  export type MapSolarSystemJumpsGroupByOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID: number | null
    toRegionID: number | null
    _count: MapSolarSystemJumpsCountAggregateOutputType | null
    _avg: MapSolarSystemJumpsAvgAggregateOutputType | null
    _sum: MapSolarSystemJumpsSumAggregateOutputType | null
    _min: MapSolarSystemJumpsMinAggregateOutputType | null
    _max: MapSolarSystemJumpsMaxAggregateOutputType | null
  }

  type GetMapSolarSystemJumpsGroupByPayload<T extends MapSolarSystemJumpsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapSolarSystemJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapSolarSystemJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapSolarSystemJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapSolarSystemJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapSolarSystemJumpsSelect = {
    fromRegionID?: boolean
    fromConstellationID?: boolean
    fromSolarSystemID?: boolean
    toSolarSystemID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }


  export type mapSolarSystemJumpsGetPayload<S extends boolean | null | undefined | mapSolarSystemJumpsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapSolarSystemJumps :
    S extends undefined ? never :
    S extends { include: any } & (mapSolarSystemJumpsArgs | mapSolarSystemJumpsFindManyArgs)
    ? mapSolarSystemJumps 
    : S extends { select: any } & (mapSolarSystemJumpsArgs | mapSolarSystemJumpsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapSolarSystemJumps ? mapSolarSystemJumps[P] : never
  } 
      : mapSolarSystemJumps


  type mapSolarSystemJumpsCountArgs = Merge<
    Omit<mapSolarSystemJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapSolarSystemJumpsCountAggregateInputType | true
    }
  >

  export interface mapSolarSystemJumpsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapSolarSystemJumps that matches the filter.
     * @param {mapSolarSystemJumpsFindUniqueArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapSolarSystemJumpsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapSolarSystemJumpsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapSolarSystemJumps'> extends True ? Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>> : Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T> | null, null>

    /**
     * Find the first MapSolarSystemJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindFirstArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapSolarSystemJumpsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapSolarSystemJumps'> extends True ? Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>> : Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T> | null, null>

    /**
     * Find zero or more MapSolarSystemJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany()
     * 
     * // Get first 10 MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapSolarSystemJumpsWithFromRegionIDOnly = await prisma.mapSolarSystemJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapSolarSystemJumpsFindManyArgs>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindManyArgs>
    ): PrismaPromise<Array<mapSolarSystemJumpsGetPayload<T>>>

    /**
     * Create a MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsCreateArgs} args - Arguments to create a MapSolarSystemJumps.
     * @example
     * // Create one MapSolarSystemJumps
     * const MapSolarSystemJumps = await prisma.mapSolarSystemJumps.create({
     *   data: {
     *     // ... data to create a MapSolarSystemJumps
     *   }
     * })
     * 
    **/
    create<T extends mapSolarSystemJumpsCreateArgs>(
      args: SelectSubset<T, mapSolarSystemJumpsCreateArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Create many MapSolarSystemJumps.
     *     @param {mapSolarSystemJumpsCreateManyArgs} args - Arguments to create many MapSolarSystemJumps.
     *     @example
     *     // Create many MapSolarSystemJumps
     *     const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapSolarSystemJumpsCreateManyArgs>(
      args?: SelectSubset<T, mapSolarSystemJumpsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsDeleteArgs} args - Arguments to delete one MapSolarSystemJumps.
     * @example
     * // Delete one MapSolarSystemJumps
     * const MapSolarSystemJumps = await prisma.mapSolarSystemJumps.delete({
     *   where: {
     *     // ... filter to delete one MapSolarSystemJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapSolarSystemJumpsDeleteArgs>(
      args: SelectSubset<T, mapSolarSystemJumpsDeleteArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Update one MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsUpdateArgs} args - Arguments to update one MapSolarSystemJumps.
     * @example
     * // Update one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapSolarSystemJumpsUpdateArgs>(
      args: SelectSubset<T, mapSolarSystemJumpsUpdateArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Delete zero or more MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsDeleteManyArgs} args - Arguments to filter MapSolarSystemJumps to delete.
     * @example
     * // Delete a few MapSolarSystemJumps
     * const { count } = await prisma.mapSolarSystemJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapSolarSystemJumpsDeleteManyArgs>(
      args?: SelectSubset<T, mapSolarSystemJumpsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapSolarSystemJumpsUpdateManyArgs>(
      args: SelectSubset<T, mapSolarSystemJumpsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsUpsertArgs} args - Arguments to update or create a MapSolarSystemJumps.
     * @example
     * // Update or create a MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.upsert({
     *   create: {
     *     // ... data to create a MapSolarSystemJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapSolarSystemJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapSolarSystemJumpsUpsertArgs>(
      args: SelectSubset<T, mapSolarSystemJumpsUpsertArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Find one MapSolarSystemJumps that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapSolarSystemJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapSolarSystemJumpsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindUniqueOrThrowArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Find the first MapSolarSystemJumps that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindFirstOrThrowArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapSolarSystemJumpsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindFirstOrThrowArgs>
    ): Prisma__mapSolarSystemJumpsClient<mapSolarSystemJumpsGetPayload<T>>

    /**
     * Count the number of MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsCountArgs} args - Arguments to filter MapSolarSystemJumps to count.
     * @example
     * // Count the number of MapSolarSystemJumps
     * const count = await prisma.mapSolarSystemJumps.count({
     *   where: {
     *     // ... the filter for the MapSolarSystemJumps we want to count
     *   }
     * })
    **/
    count<T extends mapSolarSystemJumpsCountArgs>(
      args?: Subset<T, mapSolarSystemJumpsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapSolarSystemJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapSolarSystemJumpsAggregateArgs>(args: Subset<T, MapSolarSystemJumpsAggregateArgs>): PrismaPromise<GetMapSolarSystemJumpsAggregateType<T>>

    /**
     * Group by MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapSolarSystemJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapSolarSystemJumpsGroupByArgs['orderBy'] }
        : { orderBy?: MapSolarSystemJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapSolarSystemJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapSolarSystemJumpsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapSolarSystemJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapSolarSystemJumpsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapSolarSystemJumps base type for findUnique actions
   */
  export type mapSolarSystemJumpsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     * 
    **/
    where: mapSolarSystemJumpsWhereUniqueInput
  }

  /**
   * mapSolarSystemJumps: findUnique
   */
  export interface mapSolarSystemJumpsFindUniqueArgs extends mapSolarSystemJumpsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapSolarSystemJumps base type for findFirst actions
   */
  export type mapSolarSystemJumpsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     * 
    **/
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystemJumps.
     * 
    **/
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystemJumps.
     * 
    **/
    distinct?: Enumerable<MapSolarSystemJumpsScalarFieldEnum>
  }

  /**
   * mapSolarSystemJumps: findFirst
   */
  export interface mapSolarSystemJumpsFindFirstArgs extends mapSolarSystemJumpsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapSolarSystemJumps findMany
   */
  export type mapSolarSystemJumpsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     * 
    **/
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemJumpsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapSolarSystemJumps.
     * 
    **/
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapSolarSystemJumpsScalarFieldEnum>
  }


  /**
   * mapSolarSystemJumps create
   */
  export type mapSolarSystemJumpsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * The data needed to create a mapSolarSystemJumps.
     * 
    **/
    data: XOR<mapSolarSystemJumpsCreateInput, mapSolarSystemJumpsUncheckedCreateInput>
  }


  /**
   * mapSolarSystemJumps createMany
   */
  export type mapSolarSystemJumpsCreateManyArgs = {
    /**
     * The data used to create many mapSolarSystemJumps.
     * 
    **/
    data: Enumerable<mapSolarSystemJumpsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapSolarSystemJumps update
   */
  export type mapSolarSystemJumpsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * The data needed to update a mapSolarSystemJumps.
     * 
    **/
    data: XOR<mapSolarSystemJumpsUpdateInput, mapSolarSystemJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapSolarSystemJumps to update.
     * 
    **/
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps updateMany
   */
  export type mapSolarSystemJumpsUpdateManyArgs = {
    /**
     * The data used to update mapSolarSystemJumps.
     * 
    **/
    data: XOR<mapSolarSystemJumpsUpdateManyMutationInput, mapSolarSystemJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapSolarSystemJumps to update
     * 
    **/
    where?: mapSolarSystemJumpsWhereInput
  }


  /**
   * mapSolarSystemJumps upsert
   */
  export type mapSolarSystemJumpsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * The filter to search for the mapSolarSystemJumps to update in case it exists.
     * 
    **/
    where: mapSolarSystemJumpsWhereUniqueInput
    /**
     * In case the mapSolarSystemJumps found by the `where` argument doesn't exist, create a new mapSolarSystemJumps with this data.
     * 
    **/
    create: XOR<mapSolarSystemJumpsCreateInput, mapSolarSystemJumpsUncheckedCreateInput>
    /**
     * In case the mapSolarSystemJumps was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapSolarSystemJumpsUpdateInput, mapSolarSystemJumpsUncheckedUpdateInput>
  }


  /**
   * mapSolarSystemJumps delete
   */
  export type mapSolarSystemJumpsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
    /**
     * Filter which mapSolarSystemJumps to delete.
     * 
    **/
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps deleteMany
   */
  export type mapSolarSystemJumpsDeleteManyArgs = {
    /**
     * Filter which mapSolarSystemJumps to delete
     * 
    **/
    where?: mapSolarSystemJumpsWhereInput
  }


  /**
   * mapSolarSystemJumps: findUniqueOrThrow
   */
  export type mapSolarSystemJumpsFindUniqueOrThrowArgs = mapSolarSystemJumpsFindUniqueArgsBase
      

  /**
   * mapSolarSystemJumps: findFirstOrThrow
   */
  export type mapSolarSystemJumpsFindFirstOrThrowArgs = mapSolarSystemJumpsFindFirstArgsBase
      

  /**
   * mapSolarSystemJumps without action
   */
  export type mapSolarSystemJumpsArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     * 
    **/
    select?: mapSolarSystemJumpsSelect | null
  }



  /**
   * Model mapSolarSystems
   */


  export type AggregateMapSolarSystems = {
    _count: MapSolarSystemsCountAggregateOutputType | null
    _avg: MapSolarSystemsAvgAggregateOutputType | null
    _sum: MapSolarSystemsSumAggregateOutputType | null
    _min: MapSolarSystemsMinAggregateOutputType | null
    _max: MapSolarSystemsMaxAggregateOutputType | null
  }

  export type MapSolarSystemsAvgAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
  }

  export type MapSolarSystemsSumAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
  }

  export type MapSolarSystemsMinAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
  }

  export type MapSolarSystemsMaxAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
  }

  export type MapSolarSystemsCountAggregateOutputType = {
    regionID: number
    constellationID: number
    solarSystemID: number
    solarSystemName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    luminosity: number
    border: number
    fringe: number
    corridor: number
    hub: number
    international: number
    regional: number
    constellation: number
    security: number
    factionID: number
    radius: number
    sunTypeID: number
    securityClass: number
    _all: number
  }


  export type MapSolarSystemsAvgAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
  }

  export type MapSolarSystemsSumAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
  }

  export type MapSolarSystemsMinAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
  }

  export type MapSolarSystemsMaxAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
  }

  export type MapSolarSystemsCountAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
    _all?: true
  }

  export type MapSolarSystemsAggregateArgs = {
    /**
     * Filter which mapSolarSystems to aggregate.
     * 
    **/
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapSolarSystems
    **/
    _count?: true | MapSolarSystemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapSolarSystemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSolarSystemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapSolarSystemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapSolarSystemsMaxAggregateInputType
  }

  export type GetMapSolarSystemsAggregateType<T extends MapSolarSystemsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapSolarSystems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapSolarSystems[P]>
      : GetScalarType<T[P], AggregateMapSolarSystems[P]>
  }




  export type MapSolarSystemsGroupByArgs = {
    where?: mapSolarSystemsWhereInput
    orderBy?: Enumerable<mapSolarSystemsOrderByWithAggregationInput>
    by: Array<MapSolarSystemsScalarFieldEnum>
    having?: mapSolarSystemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapSolarSystemsCountAggregateInputType | true
    _avg?: MapSolarSystemsAvgAggregateInputType
    _sum?: MapSolarSystemsSumAggregateInputType
    _min?: MapSolarSystemsMinAggregateInputType
    _max?: MapSolarSystemsMaxAggregateInputType
  }


  export type MapSolarSystemsGroupByOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
    _count: MapSolarSystemsCountAggregateOutputType | null
    _avg: MapSolarSystemsAvgAggregateOutputType | null
    _sum: MapSolarSystemsSumAggregateOutputType | null
    _min: MapSolarSystemsMinAggregateOutputType | null
    _max: MapSolarSystemsMaxAggregateOutputType | null
  }

  type GetMapSolarSystemsGroupByPayload<T extends MapSolarSystemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapSolarSystemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapSolarSystemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapSolarSystemsGroupByOutputType[P]>
            : GetScalarType<T[P], MapSolarSystemsGroupByOutputType[P]>
        }
      >
    >


  export type mapSolarSystemsSelect = {
    regionID?: boolean
    constellationID?: boolean
    solarSystemID?: boolean
    solarSystemName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    luminosity?: boolean
    border?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    international?: boolean
    regional?: boolean
    constellation?: boolean
    security?: boolean
    factionID?: boolean
    radius?: boolean
    sunTypeID?: boolean
    securityClass?: boolean
  }


  export type mapSolarSystemsGetPayload<S extends boolean | null | undefined | mapSolarSystemsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapSolarSystems :
    S extends undefined ? never :
    S extends { include: any } & (mapSolarSystemsArgs | mapSolarSystemsFindManyArgs)
    ? mapSolarSystems 
    : S extends { select: any } & (mapSolarSystemsArgs | mapSolarSystemsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapSolarSystems ? mapSolarSystems[P] : never
  } 
      : mapSolarSystems


  type mapSolarSystemsCountArgs = Merge<
    Omit<mapSolarSystemsFindManyArgs, 'select' | 'include'> & {
      select?: MapSolarSystemsCountAggregateInputType | true
    }
  >

  export interface mapSolarSystemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapSolarSystems that matches the filter.
     * @param {mapSolarSystemsFindUniqueArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapSolarSystemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapSolarSystemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapSolarSystems'> extends True ? Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>> : Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T> | null, null>

    /**
     * Find the first MapSolarSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindFirstArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapSolarSystemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapSolarSystemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapSolarSystems'> extends True ? Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>> : Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T> | null, null>

    /**
     * Find zero or more MapSolarSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findMany()
     * 
     * // Get first 10 MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapSolarSystemsWithRegionIDOnly = await prisma.mapSolarSystems.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapSolarSystemsFindManyArgs>(
      args?: SelectSubset<T, mapSolarSystemsFindManyArgs>
    ): PrismaPromise<Array<mapSolarSystemsGetPayload<T>>>

    /**
     * Create a MapSolarSystems.
     * @param {mapSolarSystemsCreateArgs} args - Arguments to create a MapSolarSystems.
     * @example
     * // Create one MapSolarSystems
     * const MapSolarSystems = await prisma.mapSolarSystems.create({
     *   data: {
     *     // ... data to create a MapSolarSystems
     *   }
     * })
     * 
    **/
    create<T extends mapSolarSystemsCreateArgs>(
      args: SelectSubset<T, mapSolarSystemsCreateArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Create many MapSolarSystems.
     *     @param {mapSolarSystemsCreateManyArgs} args - Arguments to create many MapSolarSystems.
     *     @example
     *     // Create many MapSolarSystems
     *     const mapSolarSystems = await prisma.mapSolarSystems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapSolarSystemsCreateManyArgs>(
      args?: SelectSubset<T, mapSolarSystemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapSolarSystems.
     * @param {mapSolarSystemsDeleteArgs} args - Arguments to delete one MapSolarSystems.
     * @example
     * // Delete one MapSolarSystems
     * const MapSolarSystems = await prisma.mapSolarSystems.delete({
     *   where: {
     *     // ... filter to delete one MapSolarSystems
     *   }
     * })
     * 
    **/
    delete<T extends mapSolarSystemsDeleteArgs>(
      args: SelectSubset<T, mapSolarSystemsDeleteArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Update one MapSolarSystems.
     * @param {mapSolarSystemsUpdateArgs} args - Arguments to update one MapSolarSystems.
     * @example
     * // Update one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapSolarSystemsUpdateArgs>(
      args: SelectSubset<T, mapSolarSystemsUpdateArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Delete zero or more MapSolarSystems.
     * @param {mapSolarSystemsDeleteManyArgs} args - Arguments to filter MapSolarSystems to delete.
     * @example
     * // Delete a few MapSolarSystems
     * const { count } = await prisma.mapSolarSystems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapSolarSystemsDeleteManyArgs>(
      args?: SelectSubset<T, mapSolarSystemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapSolarSystemsUpdateManyArgs>(
      args: SelectSubset<T, mapSolarSystemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapSolarSystems.
     * @param {mapSolarSystemsUpsertArgs} args - Arguments to update or create a MapSolarSystems.
     * @example
     * // Update or create a MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.upsert({
     *   create: {
     *     // ... data to create a MapSolarSystems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapSolarSystems we want to update
     *   }
     * })
    **/
    upsert<T extends mapSolarSystemsUpsertArgs>(
      args: SelectSubset<T, mapSolarSystemsUpsertArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Find one MapSolarSystems that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapSolarSystemsFindUniqueOrThrowArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapSolarSystemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapSolarSystemsFindUniqueOrThrowArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Find the first MapSolarSystems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindFirstOrThrowArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapSolarSystemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapSolarSystemsFindFirstOrThrowArgs>
    ): Prisma__mapSolarSystemsClient<mapSolarSystemsGetPayload<T>>

    /**
     * Count the number of MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsCountArgs} args - Arguments to filter MapSolarSystems to count.
     * @example
     * // Count the number of MapSolarSystems
     * const count = await prisma.mapSolarSystems.count({
     *   where: {
     *     // ... the filter for the MapSolarSystems we want to count
     *   }
     * })
    **/
    count<T extends mapSolarSystemsCountArgs>(
      args?: Subset<T, mapSolarSystemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapSolarSystemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapSolarSystemsAggregateArgs>(args: Subset<T, MapSolarSystemsAggregateArgs>): PrismaPromise<GetMapSolarSystemsAggregateType<T>>

    /**
     * Group by MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapSolarSystemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapSolarSystemsGroupByArgs['orderBy'] }
        : { orderBy?: MapSolarSystemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapSolarSystemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapSolarSystemsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapSolarSystems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapSolarSystemsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapSolarSystems base type for findUnique actions
   */
  export type mapSolarSystemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * Filter, which mapSolarSystems to fetch.
     * 
    **/
    where: mapSolarSystemsWhereUniqueInput
  }

  /**
   * mapSolarSystems: findUnique
   */
  export interface mapSolarSystemsFindUniqueArgs extends mapSolarSystemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapSolarSystems base type for findFirst actions
   */
  export type mapSolarSystemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * Filter, which mapSolarSystems to fetch.
     * 
    **/
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystems.
     * 
    **/
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystems.
     * 
    **/
    distinct?: Enumerable<MapSolarSystemsScalarFieldEnum>
  }

  /**
   * mapSolarSystems: findFirst
   */
  export interface mapSolarSystemsFindFirstArgs extends mapSolarSystemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapSolarSystems findMany
   */
  export type mapSolarSystemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * Filter, which mapSolarSystems to fetch.
     * 
    **/
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<mapSolarSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapSolarSystems.
     * 
    **/
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapSolarSystemsScalarFieldEnum>
  }


  /**
   * mapSolarSystems create
   */
  export type mapSolarSystemsCreateArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * The data needed to create a mapSolarSystems.
     * 
    **/
    data: XOR<mapSolarSystemsCreateInput, mapSolarSystemsUncheckedCreateInput>
  }


  /**
   * mapSolarSystems createMany
   */
  export type mapSolarSystemsCreateManyArgs = {
    /**
     * The data used to create many mapSolarSystems.
     * 
    **/
    data: Enumerable<mapSolarSystemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapSolarSystems update
   */
  export type mapSolarSystemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * The data needed to update a mapSolarSystems.
     * 
    **/
    data: XOR<mapSolarSystemsUpdateInput, mapSolarSystemsUncheckedUpdateInput>
    /**
     * Choose, which mapSolarSystems to update.
     * 
    **/
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems updateMany
   */
  export type mapSolarSystemsUpdateManyArgs = {
    /**
     * The data used to update mapSolarSystems.
     * 
    **/
    data: XOR<mapSolarSystemsUpdateManyMutationInput, mapSolarSystemsUncheckedUpdateManyInput>
    /**
     * Filter which mapSolarSystems to update
     * 
    **/
    where?: mapSolarSystemsWhereInput
  }


  /**
   * mapSolarSystems upsert
   */
  export type mapSolarSystemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * The filter to search for the mapSolarSystems to update in case it exists.
     * 
    **/
    where: mapSolarSystemsWhereUniqueInput
    /**
     * In case the mapSolarSystems found by the `where` argument doesn't exist, create a new mapSolarSystems with this data.
     * 
    **/
    create: XOR<mapSolarSystemsCreateInput, mapSolarSystemsUncheckedCreateInput>
    /**
     * In case the mapSolarSystems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapSolarSystemsUpdateInput, mapSolarSystemsUncheckedUpdateInput>
  }


  /**
   * mapSolarSystems delete
   */
  export type mapSolarSystemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
    /**
     * Filter which mapSolarSystems to delete.
     * 
    **/
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems deleteMany
   */
  export type mapSolarSystemsDeleteManyArgs = {
    /**
     * Filter which mapSolarSystems to delete
     * 
    **/
    where?: mapSolarSystemsWhereInput
  }


  /**
   * mapSolarSystems: findUniqueOrThrow
   */
  export type mapSolarSystemsFindUniqueOrThrowArgs = mapSolarSystemsFindUniqueArgsBase
      

  /**
   * mapSolarSystems: findFirstOrThrow
   */
  export type mapSolarSystemsFindFirstOrThrowArgs = mapSolarSystemsFindFirstArgsBase
      

  /**
   * mapSolarSystems without action
   */
  export type mapSolarSystemsArgs = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     * 
    **/
    select?: mapSolarSystemsSelect | null
  }



  /**
   * Model mapUniverse
   */


  export type AggregateMapUniverse = {
    _count: MapUniverseCountAggregateOutputType | null
    _avg: MapUniverseAvgAggregateOutputType | null
    _sum: MapUniverseSumAggregateOutputType | null
    _min: MapUniverseMinAggregateOutputType | null
    _max: MapUniverseMaxAggregateOutputType | null
  }

  export type MapUniverseAvgAggregateOutputType = {
    universeID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseSumAggregateOutputType = {
    universeID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseMinAggregateOutputType = {
    universeID: number | null
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseMaxAggregateOutputType = {
    universeID: number | null
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseCountAggregateOutputType = {
    universeID: number
    universeName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    radius: number
    _all: number
  }


  export type MapUniverseAvgAggregateInputType = {
    universeID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseSumAggregateInputType = {
    universeID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseMinAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseMaxAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseCountAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
    _all?: true
  }

  export type MapUniverseAggregateArgs = {
    /**
     * Filter which mapUniverse to aggregate.
     * 
    **/
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapUniverseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapUniverses
    **/
    _count?: true | MapUniverseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapUniverseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapUniverseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapUniverseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapUniverseMaxAggregateInputType
  }

  export type GetMapUniverseAggregateType<T extends MapUniverseAggregateArgs> = {
        [P in keyof T & keyof AggregateMapUniverse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapUniverse[P]>
      : GetScalarType<T[P], AggregateMapUniverse[P]>
  }




  export type MapUniverseGroupByArgs = {
    where?: mapUniverseWhereInput
    orderBy?: Enumerable<mapUniverseOrderByWithAggregationInput>
    by: Array<MapUniverseScalarFieldEnum>
    having?: mapUniverseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapUniverseCountAggregateInputType | true
    _avg?: MapUniverseAvgAggregateInputType
    _sum?: MapUniverseSumAggregateInputType
    _min?: MapUniverseMinAggregateInputType
    _max?: MapUniverseMaxAggregateInputType
  }


  export type MapUniverseGroupByOutputType = {
    universeID: number
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
    _count: MapUniverseCountAggregateOutputType | null
    _avg: MapUniverseAvgAggregateOutputType | null
    _sum: MapUniverseSumAggregateOutputType | null
    _min: MapUniverseMinAggregateOutputType | null
    _max: MapUniverseMaxAggregateOutputType | null
  }

  type GetMapUniverseGroupByPayload<T extends MapUniverseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MapUniverseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapUniverseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapUniverseGroupByOutputType[P]>
            : GetScalarType<T[P], MapUniverseGroupByOutputType[P]>
        }
      >
    >


  export type mapUniverseSelect = {
    universeID?: boolean
    universeName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    radius?: boolean
  }


  export type mapUniverseGetPayload<S extends boolean | null | undefined | mapUniverseArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mapUniverse :
    S extends undefined ? never :
    S extends { include: any } & (mapUniverseArgs | mapUniverseFindManyArgs)
    ? mapUniverse 
    : S extends { select: any } & (mapUniverseArgs | mapUniverseFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mapUniverse ? mapUniverse[P] : never
  } 
      : mapUniverse


  type mapUniverseCountArgs = Merge<
    Omit<mapUniverseFindManyArgs, 'select' | 'include'> & {
      select?: MapUniverseCountAggregateInputType | true
    }
  >

  export interface mapUniverseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MapUniverse that matches the filter.
     * @param {mapUniverseFindUniqueArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapUniverseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mapUniverseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mapUniverse'> extends True ? Prisma__mapUniverseClient<mapUniverseGetPayload<T>> : Prisma__mapUniverseClient<mapUniverseGetPayload<T> | null, null>

    /**
     * Find the first MapUniverse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindFirstArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapUniverseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mapUniverseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mapUniverse'> extends True ? Prisma__mapUniverseClient<mapUniverseGetPayload<T>> : Prisma__mapUniverseClient<mapUniverseGetPayload<T> | null, null>

    /**
     * Find zero or more MapUniverses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapUniverses
     * const mapUniverses = await prisma.mapUniverse.findMany()
     * 
     * // Get first 10 MapUniverses
     * const mapUniverses = await prisma.mapUniverse.findMany({ take: 10 })
     * 
     * // Only select the `universeID`
     * const mapUniverseWithUniverseIDOnly = await prisma.mapUniverse.findMany({ select: { universeID: true } })
     * 
    **/
    findMany<T extends mapUniverseFindManyArgs>(
      args?: SelectSubset<T, mapUniverseFindManyArgs>
    ): PrismaPromise<Array<mapUniverseGetPayload<T>>>

    /**
     * Create a MapUniverse.
     * @param {mapUniverseCreateArgs} args - Arguments to create a MapUniverse.
     * @example
     * // Create one MapUniverse
     * const MapUniverse = await prisma.mapUniverse.create({
     *   data: {
     *     // ... data to create a MapUniverse
     *   }
     * })
     * 
    **/
    create<T extends mapUniverseCreateArgs>(
      args: SelectSubset<T, mapUniverseCreateArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Create many MapUniverses.
     *     @param {mapUniverseCreateManyArgs} args - Arguments to create many MapUniverses.
     *     @example
     *     // Create many MapUniverses
     *     const mapUniverse = await prisma.mapUniverse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapUniverseCreateManyArgs>(
      args?: SelectSubset<T, mapUniverseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MapUniverse.
     * @param {mapUniverseDeleteArgs} args - Arguments to delete one MapUniverse.
     * @example
     * // Delete one MapUniverse
     * const MapUniverse = await prisma.mapUniverse.delete({
     *   where: {
     *     // ... filter to delete one MapUniverse
     *   }
     * })
     * 
    **/
    delete<T extends mapUniverseDeleteArgs>(
      args: SelectSubset<T, mapUniverseDeleteArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Update one MapUniverse.
     * @param {mapUniverseUpdateArgs} args - Arguments to update one MapUniverse.
     * @example
     * // Update one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapUniverseUpdateArgs>(
      args: SelectSubset<T, mapUniverseUpdateArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Delete zero or more MapUniverses.
     * @param {mapUniverseDeleteManyArgs} args - Arguments to filter MapUniverses to delete.
     * @example
     * // Delete a few MapUniverses
     * const { count } = await prisma.mapUniverse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapUniverseDeleteManyArgs>(
      args?: SelectSubset<T, mapUniverseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapUniverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapUniverses
     * const mapUniverse = await prisma.mapUniverse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapUniverseUpdateManyArgs>(
      args: SelectSubset<T, mapUniverseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MapUniverse.
     * @param {mapUniverseUpsertArgs} args - Arguments to update or create a MapUniverse.
     * @example
     * // Update or create a MapUniverse
     * const mapUniverse = await prisma.mapUniverse.upsert({
     *   create: {
     *     // ... data to create a MapUniverse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapUniverse we want to update
     *   }
     * })
    **/
    upsert<T extends mapUniverseUpsertArgs>(
      args: SelectSubset<T, mapUniverseUpsertArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Find one MapUniverse that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mapUniverseFindUniqueOrThrowArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapUniverseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mapUniverseFindUniqueOrThrowArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Find the first MapUniverse that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindFirstOrThrowArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapUniverseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mapUniverseFindFirstOrThrowArgs>
    ): Prisma__mapUniverseClient<mapUniverseGetPayload<T>>

    /**
     * Count the number of MapUniverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseCountArgs} args - Arguments to filter MapUniverses to count.
     * @example
     * // Count the number of MapUniverses
     * const count = await prisma.mapUniverse.count({
     *   where: {
     *     // ... the filter for the MapUniverses we want to count
     *   }
     * })
    **/
    count<T extends mapUniverseCountArgs>(
      args?: Subset<T, mapUniverseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapUniverseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapUniverse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUniverseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapUniverseAggregateArgs>(args: Subset<T, MapUniverseAggregateArgs>): PrismaPromise<GetMapUniverseAggregateType<T>>

    /**
     * Group by MapUniverse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUniverseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapUniverseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapUniverseGroupByArgs['orderBy'] }
        : { orderBy?: MapUniverseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapUniverseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapUniverseGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mapUniverse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mapUniverseClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mapUniverse base type for findUnique actions
   */
  export type mapUniverseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * Filter, which mapUniverse to fetch.
     * 
    **/
    where: mapUniverseWhereUniqueInput
  }

  /**
   * mapUniverse: findUnique
   */
  export interface mapUniverseFindUniqueArgs extends mapUniverseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapUniverse base type for findFirst actions
   */
  export type mapUniverseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * Filter, which mapUniverse to fetch.
     * 
    **/
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapUniverseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapUniverses.
     * 
    **/
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapUniverses.
     * 
    **/
    distinct?: Enumerable<MapUniverseScalarFieldEnum>
  }

  /**
   * mapUniverse: findFirst
   */
  export interface mapUniverseFindFirstArgs extends mapUniverseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mapUniverse findMany
   */
  export type mapUniverseFindManyArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * Filter, which mapUniverses to fetch.
     * 
    **/
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     * 
    **/
    orderBy?: Enumerable<mapUniverseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapUniverses.
     * 
    **/
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MapUniverseScalarFieldEnum>
  }


  /**
   * mapUniverse create
   */
  export type mapUniverseCreateArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * The data needed to create a mapUniverse.
     * 
    **/
    data: XOR<mapUniverseCreateInput, mapUniverseUncheckedCreateInput>
  }


  /**
   * mapUniverse createMany
   */
  export type mapUniverseCreateManyArgs = {
    /**
     * The data used to create many mapUniverses.
     * 
    **/
    data: Enumerable<mapUniverseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mapUniverse update
   */
  export type mapUniverseUpdateArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * The data needed to update a mapUniverse.
     * 
    **/
    data: XOR<mapUniverseUpdateInput, mapUniverseUncheckedUpdateInput>
    /**
     * Choose, which mapUniverse to update.
     * 
    **/
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse updateMany
   */
  export type mapUniverseUpdateManyArgs = {
    /**
     * The data used to update mapUniverses.
     * 
    **/
    data: XOR<mapUniverseUpdateManyMutationInput, mapUniverseUncheckedUpdateManyInput>
    /**
     * Filter which mapUniverses to update
     * 
    **/
    where?: mapUniverseWhereInput
  }


  /**
   * mapUniverse upsert
   */
  export type mapUniverseUpsertArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * The filter to search for the mapUniverse to update in case it exists.
     * 
    **/
    where: mapUniverseWhereUniqueInput
    /**
     * In case the mapUniverse found by the `where` argument doesn't exist, create a new mapUniverse with this data.
     * 
    **/
    create: XOR<mapUniverseCreateInput, mapUniverseUncheckedCreateInput>
    /**
     * In case the mapUniverse was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mapUniverseUpdateInput, mapUniverseUncheckedUpdateInput>
  }


  /**
   * mapUniverse delete
   */
  export type mapUniverseDeleteArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
    /**
     * Filter which mapUniverse to delete.
     * 
    **/
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse deleteMany
   */
  export type mapUniverseDeleteManyArgs = {
    /**
     * Filter which mapUniverses to delete
     * 
    **/
    where?: mapUniverseWhereInput
  }


  /**
   * mapUniverse: findUniqueOrThrow
   */
  export type mapUniverseFindUniqueOrThrowArgs = mapUniverseFindUniqueArgsBase
      

  /**
   * mapUniverse: findFirstOrThrow
   */
  export type mapUniverseFindFirstOrThrowArgs = mapUniverseFindFirstArgsBase
      

  /**
   * mapUniverse without action
   */
  export type mapUniverseArgs = {
    /**
     * Select specific fields to fetch from the mapUniverse
     * 
    **/
    select?: mapUniverseSelect | null
  }



  /**
   * Model planetSchematics
   */


  export type AggregatePlanetSchematics = {
    _count: PlanetSchematicsCountAggregateOutputType | null
    _avg: PlanetSchematicsAvgAggregateOutputType | null
    _sum: PlanetSchematicsSumAggregateOutputType | null
    _min: PlanetSchematicsMinAggregateOutputType | null
    _max: PlanetSchematicsMaxAggregateOutputType | null
  }

  export type PlanetSchematicsAvgAggregateOutputType = {
    schematicID: number | null
    cycleTime: number | null
  }

  export type PlanetSchematicsSumAggregateOutputType = {
    schematicID: number | null
    cycleTime: number | null
  }

  export type PlanetSchematicsMinAggregateOutputType = {
    schematicID: number | null
    schematicName: string | null
    cycleTime: number | null
  }

  export type PlanetSchematicsMaxAggregateOutputType = {
    schematicID: number | null
    schematicName: string | null
    cycleTime: number | null
  }

  export type PlanetSchematicsCountAggregateOutputType = {
    schematicID: number
    schematicName: number
    cycleTime: number
    _all: number
  }


  export type PlanetSchematicsAvgAggregateInputType = {
    schematicID?: true
    cycleTime?: true
  }

  export type PlanetSchematicsSumAggregateInputType = {
    schematicID?: true
    cycleTime?: true
  }

  export type PlanetSchematicsMinAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
  }

  export type PlanetSchematicsMaxAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
  }

  export type PlanetSchematicsCountAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
    _all?: true
  }

  export type PlanetSchematicsAggregateArgs = {
    /**
     * Filter which planetSchematics to aggregate.
     * 
    **/
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematics
    **/
    _count?: true | PlanetSchematicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsMaxAggregateInputType
  }

  export type GetPlanetSchematicsAggregateType<T extends PlanetSchematicsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematics[P]>
      : GetScalarType<T[P], AggregatePlanetSchematics[P]>
  }




  export type PlanetSchematicsGroupByArgs = {
    where?: planetSchematicsWhereInput
    orderBy?: Enumerable<planetSchematicsOrderByWithAggregationInput>
    by: Array<PlanetSchematicsScalarFieldEnum>
    having?: planetSchematicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsCountAggregateInputType | true
    _avg?: PlanetSchematicsAvgAggregateInputType
    _sum?: PlanetSchematicsSumAggregateInputType
    _min?: PlanetSchematicsMinAggregateInputType
    _max?: PlanetSchematicsMaxAggregateInputType
  }


  export type PlanetSchematicsGroupByOutputType = {
    schematicID: number
    schematicName: string | null
    cycleTime: number | null
    _count: PlanetSchematicsCountAggregateOutputType | null
    _avg: PlanetSchematicsAvgAggregateOutputType | null
    _sum: PlanetSchematicsSumAggregateOutputType | null
    _min: PlanetSchematicsMinAggregateOutputType | null
    _max: PlanetSchematicsMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsGroupByPayload<T extends PlanetSchematicsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlanetSchematicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsSelect = {
    schematicID?: boolean
    schematicName?: boolean
    cycleTime?: boolean
  }


  export type planetSchematicsGetPayload<S extends boolean | null | undefined | planetSchematicsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? planetSchematics :
    S extends undefined ? never :
    S extends { include: any } & (planetSchematicsArgs | planetSchematicsFindManyArgs)
    ? planetSchematics 
    : S extends { select: any } & (planetSchematicsArgs | planetSchematicsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof planetSchematics ? planetSchematics[P] : never
  } 
      : planetSchematics


  type planetSchematicsCountArgs = Merge<
    Omit<planetSchematicsFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsCountAggregateInputType | true
    }
  >

  export interface planetSchematicsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PlanetSchematics that matches the filter.
     * @param {planetSchematicsFindUniqueArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, planetSchematicsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'planetSchematics'> extends True ? Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>> : Prisma__planetSchematicsClient<planetSchematicsGetPayload<T> | null, null>

    /**
     * Find the first PlanetSchematics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindFirstArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, planetSchematicsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'planetSchematics'> extends True ? Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>> : Prisma__planetSchematicsClient<planetSchematicsGetPayload<T> | null, null>

    /**
     * Find zero or more PlanetSchematics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findMany()
     * 
     * // Get first 10 PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsWithSchematicIDOnly = await prisma.planetSchematics.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsFindManyArgs>(
      args?: SelectSubset<T, planetSchematicsFindManyArgs>
    ): PrismaPromise<Array<planetSchematicsGetPayload<T>>>

    /**
     * Create a PlanetSchematics.
     * @param {planetSchematicsCreateArgs} args - Arguments to create a PlanetSchematics.
     * @example
     * // Create one PlanetSchematics
     * const PlanetSchematics = await prisma.planetSchematics.create({
     *   data: {
     *     // ... data to create a PlanetSchematics
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsCreateArgs>(
      args: SelectSubset<T, planetSchematicsCreateArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Create many PlanetSchematics.
     *     @param {planetSchematicsCreateManyArgs} args - Arguments to create many PlanetSchematics.
     *     @example
     *     // Create many PlanetSchematics
     *     const planetSchematics = await prisma.planetSchematics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsCreateManyArgs>(
      args?: SelectSubset<T, planetSchematicsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematics.
     * @param {planetSchematicsDeleteArgs} args - Arguments to delete one PlanetSchematics.
     * @example
     * // Delete one PlanetSchematics
     * const PlanetSchematics = await prisma.planetSchematics.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematics
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsDeleteArgs>(
      args: SelectSubset<T, planetSchematicsDeleteArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Update one PlanetSchematics.
     * @param {planetSchematicsUpdateArgs} args - Arguments to update one PlanetSchematics.
     * @example
     * // Update one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsUpdateArgs>(
      args: SelectSubset<T, planetSchematicsUpdateArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Delete zero or more PlanetSchematics.
     * @param {planetSchematicsDeleteManyArgs} args - Arguments to filter PlanetSchematics to delete.
     * @example
     * // Delete a few PlanetSchematics
     * const { count } = await prisma.planetSchematics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsDeleteManyArgs>(
      args?: SelectSubset<T, planetSchematicsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsUpdateManyArgs>(
      args: SelectSubset<T, planetSchematicsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematics.
     * @param {planetSchematicsUpsertArgs} args - Arguments to update or create a PlanetSchematics.
     * @example
     * // Update or create a PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematics we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsUpsertArgs>(
      args: SelectSubset<T, planetSchematicsUpsertArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Find one PlanetSchematics that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {planetSchematicsFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsFindUniqueOrThrowArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Find the first PlanetSchematics that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsFindFirstOrThrowArgs>
    ): Prisma__planetSchematicsClient<planetSchematicsGetPayload<T>>

    /**
     * Count the number of PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsCountArgs} args - Arguments to filter PlanetSchematics to count.
     * @example
     * // Count the number of PlanetSchematics
     * const count = await prisma.planetSchematics.count({
     *   where: {
     *     // ... the filter for the PlanetSchematics we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsCountArgs>(
      args?: Subset<T, planetSchematicsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsAggregateArgs>(args: Subset<T, PlanetSchematicsAggregateArgs>): PrismaPromise<GetPlanetSchematicsAggregateType<T>>

    /**
     * Group by PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanetSchematicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanetSchematicsGroupByArgs['orderBy'] }
        : { orderBy?: PlanetSchematicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanetSchematicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__planetSchematicsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * planetSchematics base type for findUnique actions
   */
  export type planetSchematicsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * Filter, which planetSchematics to fetch.
     * 
    **/
    where: planetSchematicsWhereUniqueInput
  }

  /**
   * planetSchematics: findUnique
   */
  export interface planetSchematicsFindUniqueArgs extends planetSchematicsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematics base type for findFirst actions
   */
  export type planetSchematicsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * Filter, which planetSchematics to fetch.
     * 
    **/
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematics.
     * 
    **/
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematics.
     * 
    **/
    distinct?: Enumerable<PlanetSchematicsScalarFieldEnum>
  }

  /**
   * planetSchematics: findFirst
   */
  export interface planetSchematicsFindFirstArgs extends planetSchematicsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematics findMany
   */
  export type planetSchematicsFindManyArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * Filter, which planetSchematics to fetch.
     * 
    **/
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematics.
     * 
    **/
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlanetSchematicsScalarFieldEnum>
  }


  /**
   * planetSchematics create
   */
  export type planetSchematicsCreateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * The data needed to create a planetSchematics.
     * 
    **/
    data: XOR<planetSchematicsCreateInput, planetSchematicsUncheckedCreateInput>
  }


  /**
   * planetSchematics createMany
   */
  export type planetSchematicsCreateManyArgs = {
    /**
     * The data used to create many planetSchematics.
     * 
    **/
    data: Enumerable<planetSchematicsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * planetSchematics update
   */
  export type planetSchematicsUpdateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * The data needed to update a planetSchematics.
     * 
    **/
    data: XOR<planetSchematicsUpdateInput, planetSchematicsUncheckedUpdateInput>
    /**
     * Choose, which planetSchematics to update.
     * 
    **/
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics updateMany
   */
  export type planetSchematicsUpdateManyArgs = {
    /**
     * The data used to update planetSchematics.
     * 
    **/
    data: XOR<planetSchematicsUpdateManyMutationInput, planetSchematicsUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematics to update
     * 
    **/
    where?: planetSchematicsWhereInput
  }


  /**
   * planetSchematics upsert
   */
  export type planetSchematicsUpsertArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * The filter to search for the planetSchematics to update in case it exists.
     * 
    **/
    where: planetSchematicsWhereUniqueInput
    /**
     * In case the planetSchematics found by the `where` argument doesn't exist, create a new planetSchematics with this data.
     * 
    **/
    create: XOR<planetSchematicsCreateInput, planetSchematicsUncheckedCreateInput>
    /**
     * In case the planetSchematics was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<planetSchematicsUpdateInput, planetSchematicsUncheckedUpdateInput>
  }


  /**
   * planetSchematics delete
   */
  export type planetSchematicsDeleteArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
    /**
     * Filter which planetSchematics to delete.
     * 
    **/
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics deleteMany
   */
  export type planetSchematicsDeleteManyArgs = {
    /**
     * Filter which planetSchematics to delete
     * 
    **/
    where?: planetSchematicsWhereInput
  }


  /**
   * planetSchematics: findUniqueOrThrow
   */
  export type planetSchematicsFindUniqueOrThrowArgs = planetSchematicsFindUniqueArgsBase
      

  /**
   * planetSchematics: findFirstOrThrow
   */
  export type planetSchematicsFindFirstOrThrowArgs = planetSchematicsFindFirstArgsBase
      

  /**
   * planetSchematics without action
   */
  export type planetSchematicsArgs = {
    /**
     * Select specific fields to fetch from the planetSchematics
     * 
    **/
    select?: planetSchematicsSelect | null
  }



  /**
   * Model planetSchematicsPinMap
   */


  export type AggregatePlanetSchematicsPinMap = {
    _count: PlanetSchematicsPinMapCountAggregateOutputType | null
    _avg: PlanetSchematicsPinMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsPinMapSumAggregateOutputType | null
    _min: PlanetSchematicsPinMapMinAggregateOutputType | null
    _max: PlanetSchematicsPinMapMaxAggregateOutputType | null
  }

  export type PlanetSchematicsPinMapAvgAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapSumAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapMinAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapMaxAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapCountAggregateOutputType = {
    schematicID: number
    pinTypeID: number
    _all: number
  }


  export type PlanetSchematicsPinMapAvgAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapSumAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapMinAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapMaxAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapCountAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
    _all?: true
  }

  export type PlanetSchematicsPinMapAggregateArgs = {
    /**
     * Filter which planetSchematicsPinMap to aggregate.
     * 
    **/
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsPinMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematicsPinMaps
    **/
    _count?: true | PlanetSchematicsPinMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsPinMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsPinMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsPinMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsPinMapMaxAggregateInputType
  }

  export type GetPlanetSchematicsPinMapAggregateType<T extends PlanetSchematicsPinMapAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematicsPinMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematicsPinMap[P]>
      : GetScalarType<T[P], AggregatePlanetSchematicsPinMap[P]>
  }




  export type PlanetSchematicsPinMapGroupByArgs = {
    where?: planetSchematicsPinMapWhereInput
    orderBy?: Enumerable<planetSchematicsPinMapOrderByWithAggregationInput>
    by: Array<PlanetSchematicsPinMapScalarFieldEnum>
    having?: planetSchematicsPinMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsPinMapCountAggregateInputType | true
    _avg?: PlanetSchematicsPinMapAvgAggregateInputType
    _sum?: PlanetSchematicsPinMapSumAggregateInputType
    _min?: PlanetSchematicsPinMapMinAggregateInputType
    _max?: PlanetSchematicsPinMapMaxAggregateInputType
  }


  export type PlanetSchematicsPinMapGroupByOutputType = {
    schematicID: number
    pinTypeID: number
    _count: PlanetSchematicsPinMapCountAggregateOutputType | null
    _avg: PlanetSchematicsPinMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsPinMapSumAggregateOutputType | null
    _min: PlanetSchematicsPinMapMinAggregateOutputType | null
    _max: PlanetSchematicsPinMapMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsPinMapGroupByPayload<T extends PlanetSchematicsPinMapGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlanetSchematicsPinMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsPinMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsPinMapGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsPinMapGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsPinMapSelect = {
    schematicID?: boolean
    pinTypeID?: boolean
  }


  export type planetSchematicsPinMapGetPayload<S extends boolean | null | undefined | planetSchematicsPinMapArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? planetSchematicsPinMap :
    S extends undefined ? never :
    S extends { include: any } & (planetSchematicsPinMapArgs | planetSchematicsPinMapFindManyArgs)
    ? planetSchematicsPinMap 
    : S extends { select: any } & (planetSchematicsPinMapArgs | planetSchematicsPinMapFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof planetSchematicsPinMap ? planetSchematicsPinMap[P] : never
  } 
      : planetSchematicsPinMap


  type planetSchematicsPinMapCountArgs = Merge<
    Omit<planetSchematicsPinMapFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsPinMapCountAggregateInputType | true
    }
  >

  export interface planetSchematicsPinMapDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PlanetSchematicsPinMap that matches the filter.
     * @param {planetSchematicsPinMapFindUniqueArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsPinMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, planetSchematicsPinMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'planetSchematicsPinMap'> extends True ? Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>> : Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T> | null, null>

    /**
     * Find the first PlanetSchematicsPinMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindFirstArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsPinMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, planetSchematicsPinMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'planetSchematicsPinMap'> extends True ? Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>> : Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T> | null, null>

    /**
     * Find zero or more PlanetSchematicsPinMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematicsPinMaps
     * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany()
     * 
     * // Get first 10 PlanetSchematicsPinMaps
     * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsPinMapWithSchematicIDOnly = await prisma.planetSchematicsPinMap.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsPinMapFindManyArgs>(
      args?: SelectSubset<T, planetSchematicsPinMapFindManyArgs>
    ): PrismaPromise<Array<planetSchematicsPinMapGetPayload<T>>>

    /**
     * Create a PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapCreateArgs} args - Arguments to create a PlanetSchematicsPinMap.
     * @example
     * // Create one PlanetSchematicsPinMap
     * const PlanetSchematicsPinMap = await prisma.planetSchematicsPinMap.create({
     *   data: {
     *     // ... data to create a PlanetSchematicsPinMap
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsPinMapCreateArgs>(
      args: SelectSubset<T, planetSchematicsPinMapCreateArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Create many PlanetSchematicsPinMaps.
     *     @param {planetSchematicsPinMapCreateManyArgs} args - Arguments to create many PlanetSchematicsPinMaps.
     *     @example
     *     // Create many PlanetSchematicsPinMaps
     *     const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsPinMapCreateManyArgs>(
      args?: SelectSubset<T, planetSchematicsPinMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapDeleteArgs} args - Arguments to delete one PlanetSchematicsPinMap.
     * @example
     * // Delete one PlanetSchematicsPinMap
     * const PlanetSchematicsPinMap = await prisma.planetSchematicsPinMap.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematicsPinMap
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsPinMapDeleteArgs>(
      args: SelectSubset<T, planetSchematicsPinMapDeleteArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Update one PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapUpdateArgs} args - Arguments to update one PlanetSchematicsPinMap.
     * @example
     * // Update one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsPinMapUpdateArgs>(
      args: SelectSubset<T, planetSchematicsPinMapUpdateArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Delete zero or more PlanetSchematicsPinMaps.
     * @param {planetSchematicsPinMapDeleteManyArgs} args - Arguments to filter PlanetSchematicsPinMaps to delete.
     * @example
     * // Delete a few PlanetSchematicsPinMaps
     * const { count } = await prisma.planetSchematicsPinMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsPinMapDeleteManyArgs>(
      args?: SelectSubset<T, planetSchematicsPinMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematicsPinMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematicsPinMaps
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsPinMapUpdateManyArgs>(
      args: SelectSubset<T, planetSchematicsPinMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapUpsertArgs} args - Arguments to update or create a PlanetSchematicsPinMap.
     * @example
     * // Update or create a PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematicsPinMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematicsPinMap we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsPinMapUpsertArgs>(
      args: SelectSubset<T, planetSchematicsPinMapUpsertArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Find one PlanetSchematicsPinMap that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {planetSchematicsPinMapFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsPinMapFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsPinMapFindUniqueOrThrowArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Find the first PlanetSchematicsPinMap that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsPinMapFindFirstOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsPinMapFindFirstOrThrowArgs>
    ): Prisma__planetSchematicsPinMapClient<planetSchematicsPinMapGetPayload<T>>

    /**
     * Count the number of PlanetSchematicsPinMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapCountArgs} args - Arguments to filter PlanetSchematicsPinMaps to count.
     * @example
     * // Count the number of PlanetSchematicsPinMaps
     * const count = await prisma.planetSchematicsPinMap.count({
     *   where: {
     *     // ... the filter for the PlanetSchematicsPinMaps we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsPinMapCountArgs>(
      args?: Subset<T, planetSchematicsPinMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsPinMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematicsPinMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsPinMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsPinMapAggregateArgs>(args: Subset<T, PlanetSchematicsPinMapAggregateArgs>): PrismaPromise<GetPlanetSchematicsPinMapAggregateType<T>>

    /**
     * Group by PlanetSchematicsPinMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsPinMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanetSchematicsPinMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanetSchematicsPinMapGroupByArgs['orderBy'] }
        : { orderBy?: PlanetSchematicsPinMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanetSchematicsPinMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsPinMapGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematicsPinMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__planetSchematicsPinMapClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * planetSchematicsPinMap base type for findUnique actions
   */
  export type planetSchematicsPinMapFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     * 
    **/
    where: planetSchematicsPinMapWhereUniqueInput
  }

  /**
   * planetSchematicsPinMap: findUnique
   */
  export interface planetSchematicsPinMapFindUniqueArgs extends planetSchematicsPinMapFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematicsPinMap base type for findFirst actions
   */
  export type planetSchematicsPinMapFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     * 
    **/
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsPinMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsPinMaps.
     * 
    **/
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsPinMaps.
     * 
    **/
    distinct?: Enumerable<PlanetSchematicsPinMapScalarFieldEnum>
  }

  /**
   * planetSchematicsPinMap: findFirst
   */
  export interface planetSchematicsPinMapFindFirstArgs extends planetSchematicsPinMapFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematicsPinMap findMany
   */
  export type planetSchematicsPinMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * Filter, which planetSchematicsPinMaps to fetch.
     * 
    **/
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsPinMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematicsPinMaps.
     * 
    **/
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlanetSchematicsPinMapScalarFieldEnum>
  }


  /**
   * planetSchematicsPinMap create
   */
  export type planetSchematicsPinMapCreateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * The data needed to create a planetSchematicsPinMap.
     * 
    **/
    data: XOR<planetSchematicsPinMapCreateInput, planetSchematicsPinMapUncheckedCreateInput>
  }


  /**
   * planetSchematicsPinMap createMany
   */
  export type planetSchematicsPinMapCreateManyArgs = {
    /**
     * The data used to create many planetSchematicsPinMaps.
     * 
    **/
    data: Enumerable<planetSchematicsPinMapCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * planetSchematicsPinMap update
   */
  export type planetSchematicsPinMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * The data needed to update a planetSchematicsPinMap.
     * 
    **/
    data: XOR<planetSchematicsPinMapUpdateInput, planetSchematicsPinMapUncheckedUpdateInput>
    /**
     * Choose, which planetSchematicsPinMap to update.
     * 
    **/
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap updateMany
   */
  export type planetSchematicsPinMapUpdateManyArgs = {
    /**
     * The data used to update planetSchematicsPinMaps.
     * 
    **/
    data: XOR<planetSchematicsPinMapUpdateManyMutationInput, planetSchematicsPinMapUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematicsPinMaps to update
     * 
    **/
    where?: planetSchematicsPinMapWhereInput
  }


  /**
   * planetSchematicsPinMap upsert
   */
  export type planetSchematicsPinMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * The filter to search for the planetSchematicsPinMap to update in case it exists.
     * 
    **/
    where: planetSchematicsPinMapWhereUniqueInput
    /**
     * In case the planetSchematicsPinMap found by the `where` argument doesn't exist, create a new planetSchematicsPinMap with this data.
     * 
    **/
    create: XOR<planetSchematicsPinMapCreateInput, planetSchematicsPinMapUncheckedCreateInput>
    /**
     * In case the planetSchematicsPinMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<planetSchematicsPinMapUpdateInput, planetSchematicsPinMapUncheckedUpdateInput>
  }


  /**
   * planetSchematicsPinMap delete
   */
  export type planetSchematicsPinMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
    /**
     * Filter which planetSchematicsPinMap to delete.
     * 
    **/
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap deleteMany
   */
  export type planetSchematicsPinMapDeleteManyArgs = {
    /**
     * Filter which planetSchematicsPinMaps to delete
     * 
    **/
    where?: planetSchematicsPinMapWhereInput
  }


  /**
   * planetSchematicsPinMap: findUniqueOrThrow
   */
  export type planetSchematicsPinMapFindUniqueOrThrowArgs = planetSchematicsPinMapFindUniqueArgsBase
      

  /**
   * planetSchematicsPinMap: findFirstOrThrow
   */
  export type planetSchematicsPinMapFindFirstOrThrowArgs = planetSchematicsPinMapFindFirstArgsBase
      

  /**
   * planetSchematicsPinMap without action
   */
  export type planetSchematicsPinMapArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     * 
    **/
    select?: planetSchematicsPinMapSelect | null
  }



  /**
   * Model planetSchematicsTypeMap
   */


  export type AggregatePlanetSchematicsTypeMap = {
    _count: PlanetSchematicsTypeMapCountAggregateOutputType | null
    _avg: PlanetSchematicsTypeMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsTypeMapSumAggregateOutputType | null
    _min: PlanetSchematicsTypeMapMinAggregateOutputType | null
    _max: PlanetSchematicsTypeMapMaxAggregateOutputType | null
  }

  export type PlanetSchematicsTypeMapAvgAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type PlanetSchematicsTypeMapSumAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type PlanetSchematicsTypeMapMinAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
    isInput: boolean | null
  }

  export type PlanetSchematicsTypeMapMaxAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
    isInput: boolean | null
  }

  export type PlanetSchematicsTypeMapCountAggregateOutputType = {
    schematicID: number
    typeID: number
    quantity: number
    isInput: number
    _all: number
  }


  export type PlanetSchematicsTypeMapAvgAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
  }

  export type PlanetSchematicsTypeMapSumAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
  }

  export type PlanetSchematicsTypeMapMinAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
  }

  export type PlanetSchematicsTypeMapMaxAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
  }

  export type PlanetSchematicsTypeMapCountAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
    _all?: true
  }

  export type PlanetSchematicsTypeMapAggregateArgs = {
    /**
     * Filter which planetSchematicsTypeMap to aggregate.
     * 
    **/
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsTypeMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematicsTypeMaps
    **/
    _count?: true | PlanetSchematicsTypeMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsTypeMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsTypeMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsTypeMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsTypeMapMaxAggregateInputType
  }

  export type GetPlanetSchematicsTypeMapAggregateType<T extends PlanetSchematicsTypeMapAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematicsTypeMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematicsTypeMap[P]>
      : GetScalarType<T[P], AggregatePlanetSchematicsTypeMap[P]>
  }




  export type PlanetSchematicsTypeMapGroupByArgs = {
    where?: planetSchematicsTypeMapWhereInput
    orderBy?: Enumerable<planetSchematicsTypeMapOrderByWithAggregationInput>
    by: Array<PlanetSchematicsTypeMapScalarFieldEnum>
    having?: planetSchematicsTypeMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsTypeMapCountAggregateInputType | true
    _avg?: PlanetSchematicsTypeMapAvgAggregateInputType
    _sum?: PlanetSchematicsTypeMapSumAggregateInputType
    _min?: PlanetSchematicsTypeMapMinAggregateInputType
    _max?: PlanetSchematicsTypeMapMaxAggregateInputType
  }


  export type PlanetSchematicsTypeMapGroupByOutputType = {
    schematicID: number
    typeID: number
    quantity: number | null
    isInput: boolean | null
    _count: PlanetSchematicsTypeMapCountAggregateOutputType | null
    _avg: PlanetSchematicsTypeMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsTypeMapSumAggregateOutputType | null
    _min: PlanetSchematicsTypeMapMinAggregateOutputType | null
    _max: PlanetSchematicsTypeMapMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsTypeMapGroupByPayload<T extends PlanetSchematicsTypeMapGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlanetSchematicsTypeMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsTypeMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsTypeMapGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsTypeMapGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsTypeMapSelect = {
    schematicID?: boolean
    typeID?: boolean
    quantity?: boolean
    isInput?: boolean
  }


  export type planetSchematicsTypeMapGetPayload<S extends boolean | null | undefined | planetSchematicsTypeMapArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? planetSchematicsTypeMap :
    S extends undefined ? never :
    S extends { include: any } & (planetSchematicsTypeMapArgs | planetSchematicsTypeMapFindManyArgs)
    ? planetSchematicsTypeMap 
    : S extends { select: any } & (planetSchematicsTypeMapArgs | planetSchematicsTypeMapFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof planetSchematicsTypeMap ? planetSchematicsTypeMap[P] : never
  } 
      : planetSchematicsTypeMap


  type planetSchematicsTypeMapCountArgs = Merge<
    Omit<planetSchematicsTypeMapFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsTypeMapCountAggregateInputType | true
    }
  >

  export interface planetSchematicsTypeMapDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PlanetSchematicsTypeMap that matches the filter.
     * @param {planetSchematicsTypeMapFindUniqueArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsTypeMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, planetSchematicsTypeMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'planetSchematicsTypeMap'> extends True ? Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>> : Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T> | null, null>

    /**
     * Find the first PlanetSchematicsTypeMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindFirstArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsTypeMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'planetSchematicsTypeMap'> extends True ? Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>> : Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T> | null, null>

    /**
     * Find zero or more PlanetSchematicsTypeMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany()
     * 
     * // Get first 10 PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsTypeMapWithSchematicIDOnly = await prisma.planetSchematicsTypeMap.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsTypeMapFindManyArgs>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindManyArgs>
    ): PrismaPromise<Array<planetSchematicsTypeMapGetPayload<T>>>

    /**
     * Create a PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapCreateArgs} args - Arguments to create a PlanetSchematicsTypeMap.
     * @example
     * // Create one PlanetSchematicsTypeMap
     * const PlanetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.create({
     *   data: {
     *     // ... data to create a PlanetSchematicsTypeMap
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsTypeMapCreateArgs>(
      args: SelectSubset<T, planetSchematicsTypeMapCreateArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Create many PlanetSchematicsTypeMaps.
     *     @param {planetSchematicsTypeMapCreateManyArgs} args - Arguments to create many PlanetSchematicsTypeMaps.
     *     @example
     *     // Create many PlanetSchematicsTypeMaps
     *     const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsTypeMapCreateManyArgs>(
      args?: SelectSubset<T, planetSchematicsTypeMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapDeleteArgs} args - Arguments to delete one PlanetSchematicsTypeMap.
     * @example
     * // Delete one PlanetSchematicsTypeMap
     * const PlanetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematicsTypeMap
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsTypeMapDeleteArgs>(
      args: SelectSubset<T, planetSchematicsTypeMapDeleteArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Update one PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapUpdateArgs} args - Arguments to update one PlanetSchematicsTypeMap.
     * @example
     * // Update one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsTypeMapUpdateArgs>(
      args: SelectSubset<T, planetSchematicsTypeMapUpdateArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Delete zero or more PlanetSchematicsTypeMaps.
     * @param {planetSchematicsTypeMapDeleteManyArgs} args - Arguments to filter PlanetSchematicsTypeMaps to delete.
     * @example
     * // Delete a few PlanetSchematicsTypeMaps
     * const { count } = await prisma.planetSchematicsTypeMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsTypeMapDeleteManyArgs>(
      args?: SelectSubset<T, planetSchematicsTypeMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematicsTypeMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsTypeMapUpdateManyArgs>(
      args: SelectSubset<T, planetSchematicsTypeMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapUpsertArgs} args - Arguments to update or create a PlanetSchematicsTypeMap.
     * @example
     * // Update or create a PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematicsTypeMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematicsTypeMap we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsTypeMapUpsertArgs>(
      args: SelectSubset<T, planetSchematicsTypeMapUpsertArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Find one PlanetSchematicsTypeMap that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {planetSchematicsTypeMapFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsTypeMapFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindUniqueOrThrowArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Find the first PlanetSchematicsTypeMap that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsTypeMapFindFirstOrThrowArgs>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindFirstOrThrowArgs>
    ): Prisma__planetSchematicsTypeMapClient<planetSchematicsTypeMapGetPayload<T>>

    /**
     * Count the number of PlanetSchematicsTypeMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapCountArgs} args - Arguments to filter PlanetSchematicsTypeMaps to count.
     * @example
     * // Count the number of PlanetSchematicsTypeMaps
     * const count = await prisma.planetSchematicsTypeMap.count({
     *   where: {
     *     // ... the filter for the PlanetSchematicsTypeMaps we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsTypeMapCountArgs>(
      args?: Subset<T, planetSchematicsTypeMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsTypeMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematicsTypeMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsTypeMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsTypeMapAggregateArgs>(args: Subset<T, PlanetSchematicsTypeMapAggregateArgs>): PrismaPromise<GetPlanetSchematicsTypeMapAggregateType<T>>

    /**
     * Group by PlanetSchematicsTypeMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsTypeMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanetSchematicsTypeMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanetSchematicsTypeMapGroupByArgs['orderBy'] }
        : { orderBy?: PlanetSchematicsTypeMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanetSchematicsTypeMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsTypeMapGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematicsTypeMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__planetSchematicsTypeMapClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * planetSchematicsTypeMap base type for findUnique actions
   */
  export type planetSchematicsTypeMapFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     * 
    **/
    where: planetSchematicsTypeMapWhereUniqueInput
  }

  /**
   * planetSchematicsTypeMap: findUnique
   */
  export interface planetSchematicsTypeMapFindUniqueArgs extends planetSchematicsTypeMapFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematicsTypeMap base type for findFirst actions
   */
  export type planetSchematicsTypeMapFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     * 
    **/
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsTypeMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsTypeMaps.
     * 
    **/
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsTypeMaps.
     * 
    **/
    distinct?: Enumerable<PlanetSchematicsTypeMapScalarFieldEnum>
  }

  /**
   * planetSchematicsTypeMap: findFirst
   */
  export interface planetSchematicsTypeMapFindFirstArgs extends planetSchematicsTypeMapFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planetSchematicsTypeMap findMany
   */
  export type planetSchematicsTypeMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * Filter, which planetSchematicsTypeMaps to fetch.
     * 
    **/
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<planetSchematicsTypeMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematicsTypeMaps.
     * 
    **/
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlanetSchematicsTypeMapScalarFieldEnum>
  }


  /**
   * planetSchematicsTypeMap create
   */
  export type planetSchematicsTypeMapCreateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * The data needed to create a planetSchematicsTypeMap.
     * 
    **/
    data: XOR<planetSchematicsTypeMapCreateInput, planetSchematicsTypeMapUncheckedCreateInput>
  }


  /**
   * planetSchematicsTypeMap createMany
   */
  export type planetSchematicsTypeMapCreateManyArgs = {
    /**
     * The data used to create many planetSchematicsTypeMaps.
     * 
    **/
    data: Enumerable<planetSchematicsTypeMapCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * planetSchematicsTypeMap update
   */
  export type planetSchematicsTypeMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * The data needed to update a planetSchematicsTypeMap.
     * 
    **/
    data: XOR<planetSchematicsTypeMapUpdateInput, planetSchematicsTypeMapUncheckedUpdateInput>
    /**
     * Choose, which planetSchematicsTypeMap to update.
     * 
    **/
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap updateMany
   */
  export type planetSchematicsTypeMapUpdateManyArgs = {
    /**
     * The data used to update planetSchematicsTypeMaps.
     * 
    **/
    data: XOR<planetSchematicsTypeMapUpdateManyMutationInput, planetSchematicsTypeMapUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematicsTypeMaps to update
     * 
    **/
    where?: planetSchematicsTypeMapWhereInput
  }


  /**
   * planetSchematicsTypeMap upsert
   */
  export type planetSchematicsTypeMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * The filter to search for the planetSchematicsTypeMap to update in case it exists.
     * 
    **/
    where: planetSchematicsTypeMapWhereUniqueInput
    /**
     * In case the planetSchematicsTypeMap found by the `where` argument doesn't exist, create a new planetSchematicsTypeMap with this data.
     * 
    **/
    create: XOR<planetSchematicsTypeMapCreateInput, planetSchematicsTypeMapUncheckedCreateInput>
    /**
     * In case the planetSchematicsTypeMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<planetSchematicsTypeMapUpdateInput, planetSchematicsTypeMapUncheckedUpdateInput>
  }


  /**
   * planetSchematicsTypeMap delete
   */
  export type planetSchematicsTypeMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
    /**
     * Filter which planetSchematicsTypeMap to delete.
     * 
    **/
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap deleteMany
   */
  export type planetSchematicsTypeMapDeleteManyArgs = {
    /**
     * Filter which planetSchematicsTypeMaps to delete
     * 
    **/
    where?: planetSchematicsTypeMapWhereInput
  }


  /**
   * planetSchematicsTypeMap: findUniqueOrThrow
   */
  export type planetSchematicsTypeMapFindUniqueOrThrowArgs = planetSchematicsTypeMapFindUniqueArgsBase
      

  /**
   * planetSchematicsTypeMap: findFirstOrThrow
   */
  export type planetSchematicsTypeMapFindFirstOrThrowArgs = planetSchematicsTypeMapFindFirstArgsBase
      

  /**
   * planetSchematicsTypeMap without action
   */
  export type planetSchematicsTypeMapArgs = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     * 
    **/
    select?: planetSchematicsTypeMapSelect | null
  }



  /**
   * Model ramActivities
   */


  export type AggregateRamActivities = {
    _count: RamActivitiesCountAggregateOutputType | null
    _avg: RamActivitiesAvgAggregateOutputType | null
    _sum: RamActivitiesSumAggregateOutputType | null
    _min: RamActivitiesMinAggregateOutputType | null
    _max: RamActivitiesMaxAggregateOutputType | null
  }

  export type RamActivitiesAvgAggregateOutputType = {
    activityID: number | null
  }

  export type RamActivitiesSumAggregateOutputType = {
    activityID: number | null
  }

  export type RamActivitiesMinAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
  }

  export type RamActivitiesMaxAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
  }

  export type RamActivitiesCountAggregateOutputType = {
    activityID: number
    activityName: number
    iconNo: number
    description: number
    published: number
    _all: number
  }


  export type RamActivitiesAvgAggregateInputType = {
    activityID?: true
  }

  export type RamActivitiesSumAggregateInputType = {
    activityID?: true
  }

  export type RamActivitiesMinAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
  }

  export type RamActivitiesMaxAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
  }

  export type RamActivitiesCountAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
    _all?: true
  }

  export type RamActivitiesAggregateArgs = {
    /**
     * Filter which ramActivities to aggregate.
     * 
    **/
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<ramActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramActivities
    **/
    _count?: true | RamActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamActivitiesMaxAggregateInputType
  }

  export type GetRamActivitiesAggregateType<T extends RamActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateRamActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamActivities[P]>
      : GetScalarType<T[P], AggregateRamActivities[P]>
  }




  export type RamActivitiesGroupByArgs = {
    where?: ramActivitiesWhereInput
    orderBy?: Enumerable<ramActivitiesOrderByWithAggregationInput>
    by: Array<RamActivitiesScalarFieldEnum>
    having?: ramActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamActivitiesCountAggregateInputType | true
    _avg?: RamActivitiesAvgAggregateInputType
    _sum?: RamActivitiesSumAggregateInputType
    _min?: RamActivitiesMinAggregateInputType
    _max?: RamActivitiesMaxAggregateInputType
  }


  export type RamActivitiesGroupByOutputType = {
    activityID: number
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
    _count: RamActivitiesCountAggregateOutputType | null
    _avg: RamActivitiesAvgAggregateOutputType | null
    _sum: RamActivitiesSumAggregateOutputType | null
    _min: RamActivitiesMinAggregateOutputType | null
    _max: RamActivitiesMaxAggregateOutputType | null
  }

  type GetRamActivitiesGroupByPayload<T extends RamActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], RamActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type ramActivitiesSelect = {
    activityID?: boolean
    activityName?: boolean
    iconNo?: boolean
    description?: boolean
    published?: boolean
  }


  export type ramActivitiesGetPayload<S extends boolean | null | undefined | ramActivitiesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramActivities :
    S extends undefined ? never :
    S extends { include: any } & (ramActivitiesArgs | ramActivitiesFindManyArgs)
    ? ramActivities 
    : S extends { select: any } & (ramActivitiesArgs | ramActivitiesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramActivities ? ramActivities[P] : never
  } 
      : ramActivities


  type ramActivitiesCountArgs = Merge<
    Omit<ramActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: RamActivitiesCountAggregateInputType | true
    }
  >

  export interface ramActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamActivities that matches the filter.
     * @param {ramActivitiesFindUniqueArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramActivities'> extends True ? Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>> : Prisma__ramActivitiesClient<ramActivitiesGetPayload<T> | null, null>

    /**
     * Find the first RamActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindFirstArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramActivities'> extends True ? Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>> : Prisma__ramActivitiesClient<ramActivitiesGetPayload<T> | null, null>

    /**
     * Find zero or more RamActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamActivities
     * const ramActivities = await prisma.ramActivities.findMany()
     * 
     * // Get first 10 RamActivities
     * const ramActivities = await prisma.ramActivities.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const ramActivitiesWithActivityIDOnly = await prisma.ramActivities.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends ramActivitiesFindManyArgs>(
      args?: SelectSubset<T, ramActivitiesFindManyArgs>
    ): PrismaPromise<Array<ramActivitiesGetPayload<T>>>

    /**
     * Create a RamActivities.
     * @param {ramActivitiesCreateArgs} args - Arguments to create a RamActivities.
     * @example
     * // Create one RamActivities
     * const RamActivities = await prisma.ramActivities.create({
     *   data: {
     *     // ... data to create a RamActivities
     *   }
     * })
     * 
    **/
    create<T extends ramActivitiesCreateArgs>(
      args: SelectSubset<T, ramActivitiesCreateArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Create many RamActivities.
     *     @param {ramActivitiesCreateManyArgs} args - Arguments to create many RamActivities.
     *     @example
     *     // Create many RamActivities
     *     const ramActivities = await prisma.ramActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramActivitiesCreateManyArgs>(
      args?: SelectSubset<T, ramActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamActivities.
     * @param {ramActivitiesDeleteArgs} args - Arguments to delete one RamActivities.
     * @example
     * // Delete one RamActivities
     * const RamActivities = await prisma.ramActivities.delete({
     *   where: {
     *     // ... filter to delete one RamActivities
     *   }
     * })
     * 
    **/
    delete<T extends ramActivitiesDeleteArgs>(
      args: SelectSubset<T, ramActivitiesDeleteArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Update one RamActivities.
     * @param {ramActivitiesUpdateArgs} args - Arguments to update one RamActivities.
     * @example
     * // Update one RamActivities
     * const ramActivities = await prisma.ramActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramActivitiesUpdateArgs>(
      args: SelectSubset<T, ramActivitiesUpdateArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Delete zero or more RamActivities.
     * @param {ramActivitiesDeleteManyArgs} args - Arguments to filter RamActivities to delete.
     * @example
     * // Delete a few RamActivities
     * const { count } = await prisma.ramActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, ramActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamActivities
     * const ramActivities = await prisma.ramActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramActivitiesUpdateManyArgs>(
      args: SelectSubset<T, ramActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamActivities.
     * @param {ramActivitiesUpsertArgs} args - Arguments to update or create a RamActivities.
     * @example
     * // Update or create a RamActivities
     * const ramActivities = await prisma.ramActivities.upsert({
     *   create: {
     *     // ... data to create a RamActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamActivities we want to update
     *   }
     * })
    **/
    upsert<T extends ramActivitiesUpsertArgs>(
      args: SelectSubset<T, ramActivitiesUpsertArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Find one RamActivities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramActivitiesFindUniqueOrThrowArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramActivitiesFindUniqueOrThrowArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Find the first RamActivities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindFirstOrThrowArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramActivitiesFindFirstOrThrowArgs>
    ): Prisma__ramActivitiesClient<ramActivitiesGetPayload<T>>

    /**
     * Count the number of RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesCountArgs} args - Arguments to filter RamActivities to count.
     * @example
     * // Count the number of RamActivities
     * const count = await prisma.ramActivities.count({
     *   where: {
     *     // ... the filter for the RamActivities we want to count
     *   }
     * })
    **/
    count<T extends ramActivitiesCountArgs>(
      args?: Subset<T, ramActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamActivitiesAggregateArgs>(args: Subset<T, RamActivitiesAggregateArgs>): PrismaPromise<GetRamActivitiesAggregateType<T>>

    /**
     * Group by RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: RamActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramActivities base type for findUnique actions
   */
  export type ramActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * Filter, which ramActivities to fetch.
     * 
    **/
    where: ramActivitiesWhereUniqueInput
  }

  /**
   * ramActivities: findUnique
   */
  export interface ramActivitiesFindUniqueArgs extends ramActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramActivities base type for findFirst actions
   */
  export type ramActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * Filter, which ramActivities to fetch.
     * 
    **/
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<ramActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramActivities.
     * 
    **/
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramActivities.
     * 
    **/
    distinct?: Enumerable<RamActivitiesScalarFieldEnum>
  }

  /**
   * ramActivities: findFirst
   */
  export interface ramActivitiesFindFirstArgs extends ramActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramActivities findMany
   */
  export type ramActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * Filter, which ramActivities to fetch.
     * 
    **/
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<ramActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramActivities.
     * 
    **/
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamActivitiesScalarFieldEnum>
  }


  /**
   * ramActivities create
   */
  export type ramActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * The data needed to create a ramActivities.
     * 
    **/
    data: XOR<ramActivitiesCreateInput, ramActivitiesUncheckedCreateInput>
  }


  /**
   * ramActivities createMany
   */
  export type ramActivitiesCreateManyArgs = {
    /**
     * The data used to create many ramActivities.
     * 
    **/
    data: Enumerable<ramActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramActivities update
   */
  export type ramActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * The data needed to update a ramActivities.
     * 
    **/
    data: XOR<ramActivitiesUpdateInput, ramActivitiesUncheckedUpdateInput>
    /**
     * Choose, which ramActivities to update.
     * 
    **/
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities updateMany
   */
  export type ramActivitiesUpdateManyArgs = {
    /**
     * The data used to update ramActivities.
     * 
    **/
    data: XOR<ramActivitiesUpdateManyMutationInput, ramActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which ramActivities to update
     * 
    **/
    where?: ramActivitiesWhereInput
  }


  /**
   * ramActivities upsert
   */
  export type ramActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * The filter to search for the ramActivities to update in case it exists.
     * 
    **/
    where: ramActivitiesWhereUniqueInput
    /**
     * In case the ramActivities found by the `where` argument doesn't exist, create a new ramActivities with this data.
     * 
    **/
    create: XOR<ramActivitiesCreateInput, ramActivitiesUncheckedCreateInput>
    /**
     * In case the ramActivities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramActivitiesUpdateInput, ramActivitiesUncheckedUpdateInput>
  }


  /**
   * ramActivities delete
   */
  export type ramActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
    /**
     * Filter which ramActivities to delete.
     * 
    **/
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities deleteMany
   */
  export type ramActivitiesDeleteManyArgs = {
    /**
     * Filter which ramActivities to delete
     * 
    **/
    where?: ramActivitiesWhereInput
  }


  /**
   * ramActivities: findUniqueOrThrow
   */
  export type ramActivitiesFindUniqueOrThrowArgs = ramActivitiesFindUniqueArgsBase
      

  /**
   * ramActivities: findFirstOrThrow
   */
  export type ramActivitiesFindFirstOrThrowArgs = ramActivitiesFindFirstArgsBase
      

  /**
   * ramActivities without action
   */
  export type ramActivitiesArgs = {
    /**
     * Select specific fields to fetch from the ramActivities
     * 
    **/
    select?: ramActivitiesSelect | null
  }



  /**
   * Model ramAssemblyLineStations
   */


  export type AggregateRamAssemblyLineStations = {
    _count: RamAssemblyLineStationsCountAggregateOutputType | null
    _avg: RamAssemblyLineStationsAvgAggregateOutputType | null
    _sum: RamAssemblyLineStationsSumAggregateOutputType | null
    _min: RamAssemblyLineStationsMinAggregateOutputType | null
    _max: RamAssemblyLineStationsMaxAggregateOutputType | null
  }

  export type RamAssemblyLineStationsAvgAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsSumAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsMinAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsMaxAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsCountAggregateOutputType = {
    stationID: number
    assemblyLineTypeID: number
    quantity: number
    stationTypeID: number
    ownerID: number
    solarSystemID: number
    regionID: number
    _all: number
  }


  export type RamAssemblyLineStationsAvgAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsSumAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsMinAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsMaxAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsCountAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
    _all?: true
  }

  export type RamAssemblyLineStationsAggregateArgs = {
    /**
     * Filter which ramAssemblyLineStations to aggregate.
     * 
    **/
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineStations
    **/
    _count?: true | RamAssemblyLineStationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineStationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineStationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineStationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineStationsMaxAggregateInputType
  }

  export type GetRamAssemblyLineStationsAggregateType<T extends RamAssemblyLineStationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineStations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineStations[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineStations[P]>
  }




  export type RamAssemblyLineStationsGroupByArgs = {
    where?: ramAssemblyLineStationsWhereInput
    orderBy?: Enumerable<ramAssemblyLineStationsOrderByWithAggregationInput>
    by: Array<RamAssemblyLineStationsScalarFieldEnum>
    having?: ramAssemblyLineStationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineStationsCountAggregateInputType | true
    _avg?: RamAssemblyLineStationsAvgAggregateInputType
    _sum?: RamAssemblyLineStationsSumAggregateInputType
    _min?: RamAssemblyLineStationsMinAggregateInputType
    _max?: RamAssemblyLineStationsMaxAggregateInputType
  }


  export type RamAssemblyLineStationsGroupByOutputType = {
    stationID: number
    assemblyLineTypeID: number
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
    _count: RamAssemblyLineStationsCountAggregateOutputType | null
    _avg: RamAssemblyLineStationsAvgAggregateOutputType | null
    _sum: RamAssemblyLineStationsSumAggregateOutputType | null
    _min: RamAssemblyLineStationsMinAggregateOutputType | null
    _max: RamAssemblyLineStationsMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineStationsGroupByPayload<T extends RamAssemblyLineStationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamAssemblyLineStationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineStationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineStationsGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineStationsGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineStationsSelect = {
    stationID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
    stationTypeID?: boolean
    ownerID?: boolean
    solarSystemID?: boolean
    regionID?: boolean
  }


  export type ramAssemblyLineStationsGetPayload<S extends boolean | null | undefined | ramAssemblyLineStationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramAssemblyLineStations :
    S extends undefined ? never :
    S extends { include: any } & (ramAssemblyLineStationsArgs | ramAssemblyLineStationsFindManyArgs)
    ? ramAssemblyLineStations 
    : S extends { select: any } & (ramAssemblyLineStationsArgs | ramAssemblyLineStationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramAssemblyLineStations ? ramAssemblyLineStations[P] : never
  } 
      : ramAssemblyLineStations


  type ramAssemblyLineStationsCountArgs = Merge<
    Omit<ramAssemblyLineStationsFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineStationsCountAggregateInputType | true
    }
  >

  export interface ramAssemblyLineStationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamAssemblyLineStations that matches the filter.
     * @param {ramAssemblyLineStationsFindUniqueArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineStationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramAssemblyLineStationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramAssemblyLineStations'> extends True ? Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>> : Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T> | null, null>

    /**
     * Find the first RamAssemblyLineStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindFirstArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineStationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramAssemblyLineStations'> extends True ? Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>> : Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T> | null, null>

    /**
     * Find zero or more RamAssemblyLineStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany()
     * 
     * // Get first 10 RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany({ take: 10 })
     * 
     * // Only select the `stationID`
     * const ramAssemblyLineStationsWithStationIDOnly = await prisma.ramAssemblyLineStations.findMany({ select: { stationID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineStationsFindManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindManyArgs>
    ): PrismaPromise<Array<ramAssemblyLineStationsGetPayload<T>>>

    /**
     * Create a RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsCreateArgs} args - Arguments to create a RamAssemblyLineStations.
     * @example
     * // Create one RamAssemblyLineStations
     * const RamAssemblyLineStations = await prisma.ramAssemblyLineStations.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineStations
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineStationsCreateArgs>(
      args: SelectSubset<T, ramAssemblyLineStationsCreateArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Create many RamAssemblyLineStations.
     *     @param {ramAssemblyLineStationsCreateManyArgs} args - Arguments to create many RamAssemblyLineStations.
     *     @example
     *     // Create many RamAssemblyLineStations
     *     const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineStationsCreateManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineStationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsDeleteArgs} args - Arguments to delete one RamAssemblyLineStations.
     * @example
     * // Delete one RamAssemblyLineStations
     * const RamAssemblyLineStations = await prisma.ramAssemblyLineStations.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineStations
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineStationsDeleteArgs>(
      args: SelectSubset<T, ramAssemblyLineStationsDeleteArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Update one RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsUpdateArgs} args - Arguments to update one RamAssemblyLineStations.
     * @example
     * // Update one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineStationsUpdateArgs>(
      args: SelectSubset<T, ramAssemblyLineStationsUpdateArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Delete zero or more RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsDeleteManyArgs} args - Arguments to filter RamAssemblyLineStations to delete.
     * @example
     * // Delete a few RamAssemblyLineStations
     * const { count } = await prisma.ramAssemblyLineStations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineStationsDeleteManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineStationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineStationsUpdateManyArgs>(
      args: SelectSubset<T, ramAssemblyLineStationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsUpsertArgs} args - Arguments to update or create a RamAssemblyLineStations.
     * @example
     * // Update or create a RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineStations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineStations we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineStationsUpsertArgs>(
      args: SelectSubset<T, ramAssemblyLineStationsUpsertArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Find one RamAssemblyLineStations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramAssemblyLineStationsFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineStationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindUniqueOrThrowArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Find the first RamAssemblyLineStations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineStationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindFirstOrThrowArgs>
    ): Prisma__ramAssemblyLineStationsClient<ramAssemblyLineStationsGetPayload<T>>

    /**
     * Count the number of RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsCountArgs} args - Arguments to filter RamAssemblyLineStations to count.
     * @example
     * // Count the number of RamAssemblyLineStations
     * const count = await prisma.ramAssemblyLineStations.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineStations we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineStationsCountArgs>(
      args?: Subset<T, ramAssemblyLineStationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineStationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineStationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineStationsAggregateArgs>(args: Subset<T, RamAssemblyLineStationsAggregateArgs>): PrismaPromise<GetRamAssemblyLineStationsAggregateType<T>>

    /**
     * Group by RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineStationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamAssemblyLineStationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamAssemblyLineStationsGroupByArgs['orderBy'] }
        : { orderBy?: RamAssemblyLineStationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamAssemblyLineStationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineStationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineStations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramAssemblyLineStationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramAssemblyLineStations base type for findUnique actions
   */
  export type ramAssemblyLineStationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     * 
    **/
    where: ramAssemblyLineStationsWhereUniqueInput
  }

  /**
   * ramAssemblyLineStations: findUnique
   */
  export interface ramAssemblyLineStationsFindUniqueArgs extends ramAssemblyLineStationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineStations base type for findFirst actions
   */
  export type ramAssemblyLineStationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     * 
    **/
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineStations.
     * 
    **/
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineStations.
     * 
    **/
    distinct?: Enumerable<RamAssemblyLineStationsScalarFieldEnum>
  }

  /**
   * ramAssemblyLineStations: findFirst
   */
  export interface ramAssemblyLineStationsFindFirstArgs extends ramAssemblyLineStationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineStations findMany
   */
  export type ramAssemblyLineStationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     * 
    **/
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineStations.
     * 
    **/
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamAssemblyLineStationsScalarFieldEnum>
  }


  /**
   * ramAssemblyLineStations create
   */
  export type ramAssemblyLineStationsCreateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * The data needed to create a ramAssemblyLineStations.
     * 
    **/
    data: XOR<ramAssemblyLineStationsCreateInput, ramAssemblyLineStationsUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineStations createMany
   */
  export type ramAssemblyLineStationsCreateManyArgs = {
    /**
     * The data used to create many ramAssemblyLineStations.
     * 
    **/
    data: Enumerable<ramAssemblyLineStationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineStations update
   */
  export type ramAssemblyLineStationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * The data needed to update a ramAssemblyLineStations.
     * 
    **/
    data: XOR<ramAssemblyLineStationsUpdateInput, ramAssemblyLineStationsUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineStations to update.
     * 
    **/
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations updateMany
   */
  export type ramAssemblyLineStationsUpdateManyArgs = {
    /**
     * The data used to update ramAssemblyLineStations.
     * 
    **/
    data: XOR<ramAssemblyLineStationsUpdateManyMutationInput, ramAssemblyLineStationsUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineStations to update
     * 
    **/
    where?: ramAssemblyLineStationsWhereInput
  }


  /**
   * ramAssemblyLineStations upsert
   */
  export type ramAssemblyLineStationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * The filter to search for the ramAssemblyLineStations to update in case it exists.
     * 
    **/
    where: ramAssemblyLineStationsWhereUniqueInput
    /**
     * In case the ramAssemblyLineStations found by the `where` argument doesn't exist, create a new ramAssemblyLineStations with this data.
     * 
    **/
    create: XOR<ramAssemblyLineStationsCreateInput, ramAssemblyLineStationsUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineStations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramAssemblyLineStationsUpdateInput, ramAssemblyLineStationsUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineStations delete
   */
  export type ramAssemblyLineStationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
    /**
     * Filter which ramAssemblyLineStations to delete.
     * 
    **/
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations deleteMany
   */
  export type ramAssemblyLineStationsDeleteManyArgs = {
    /**
     * Filter which ramAssemblyLineStations to delete
     * 
    **/
    where?: ramAssemblyLineStationsWhereInput
  }


  /**
   * ramAssemblyLineStations: findUniqueOrThrow
   */
  export type ramAssemblyLineStationsFindUniqueOrThrowArgs = ramAssemblyLineStationsFindUniqueArgsBase
      

  /**
   * ramAssemblyLineStations: findFirstOrThrow
   */
  export type ramAssemblyLineStationsFindFirstOrThrowArgs = ramAssemblyLineStationsFindFirstArgsBase
      

  /**
   * ramAssemblyLineStations without action
   */
  export type ramAssemblyLineStationsArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     * 
    **/
    select?: ramAssemblyLineStationsSelect | null
  }



  /**
   * Model ramAssemblyLineTypeDetailPerCategory
   */


  export type AggregateRamAssemblyLineTypeDetailPerCategory = {
    _count: RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier: number
    materialMultiplier: number
    costMultiplier: number
    _all: number
  }


  export type RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategorySumAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
    _all?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryAggregateArgs = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategory to aggregate.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypeDetailPerCategories
    **/
    _count?: true | RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypeDetailPerCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypeDetailPerCategoryAggregateType<T extends RamAssemblyLineTypeDetailPerCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypeDetailPerCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerCategory[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerCategory[P]>
  }




  export type RamAssemblyLineTypeDetailPerCategoryGroupByArgs = {
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerCategoryOrderByWithAggregationInput>
    by: Array<RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum>
    having?: ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType | true
    _avg?: RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType
    _sum?: RamAssemblyLineTypeDetailPerCategorySumAggregateInputType
    _min?: RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType
    _max?: RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType
  }


  export type RamAssemblyLineTypeDetailPerCategoryGroupByOutputType = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
    _count: RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypeDetailPerCategoryGroupByPayload<T extends RamAssemblyLineTypeDetailPerCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamAssemblyLineTypeDetailPerCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypeDetailPerCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypeDetailPerCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypeDetailPerCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypeDetailPerCategorySelect = {
    assemblyLineTypeID?: boolean
    categoryID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }


  export type ramAssemblyLineTypeDetailPerCategoryGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypeDetailPerCategoryArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramAssemblyLineTypeDetailPerCategory :
    S extends undefined ? never :
    S extends { include: any } & (ramAssemblyLineTypeDetailPerCategoryArgs | ramAssemblyLineTypeDetailPerCategoryFindManyArgs)
    ? ramAssemblyLineTypeDetailPerCategory 
    : S extends { select: any } & (ramAssemblyLineTypeDetailPerCategoryArgs | ramAssemblyLineTypeDetailPerCategoryFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramAssemblyLineTypeDetailPerCategory ? ramAssemblyLineTypeDetailPerCategory[P] : never
  } 
      : ramAssemblyLineTypeDetailPerCategory


  type ramAssemblyLineTypeDetailPerCategoryCountArgs = Merge<
    Omit<ramAssemblyLineTypeDetailPerCategoryFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType | true
    }
  >

  export interface ramAssemblyLineTypeDetailPerCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamAssemblyLineTypeDetailPerCategory that matches the filter.
     * @param {ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramAssemblyLineTypeDetailPerCategory'> extends True ? Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>> : Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T> | null, null>

    /**
     * Find the first RamAssemblyLineTypeDetailPerCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindFirstArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypeDetailPerCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramAssemblyLineTypeDetailPerCategory'> extends True ? Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>> : Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T> | null, null>

    /**
     * Find zero or more RamAssemblyLineTypeDetailPerCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypeDetailPerCategoryWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypeDetailPerCategoryFindManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindManyArgs>
    ): PrismaPromise<Array<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>>

    /**
     * Create a RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryCreateArgs} args - Arguments to create a RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Create one RamAssemblyLineTypeDetailPerCategory
     * const RamAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerCategory
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypeDetailPerCategoryCreateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryCreateArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Create many RamAssemblyLineTypeDetailPerCategories.
     *     @param {ramAssemblyLineTypeDetailPerCategoryCreateManyArgs} args - Arguments to create many RamAssemblyLineTypeDetailPerCategories.
     *     @example
     *     // Create many RamAssemblyLineTypeDetailPerCategories
     *     const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypeDetailPerCategoryCreateManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryDeleteArgs} args - Arguments to delete one RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Delete one RamAssemblyLineTypeDetailPerCategory
     * const RamAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypeDetailPerCategory
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypeDetailPerCategoryDeleteArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryDeleteArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Update one RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryUpdateArgs} args - Arguments to update one RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Update one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypeDetailPerCategoryUpdateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpdateArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Delete zero or more RamAssemblyLineTypeDetailPerCategories.
     * @param {ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerCategories to delete.
     * @example
     * // Delete a few RamAssemblyLineTypeDetailPerCategories
     * const { count } = await prisma.ramAssemblyLineTypeDetailPerCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypeDetailPerCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Update or create a RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypeDetailPerCategoryUpsertArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpsertArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Find one RamAssemblyLineTypeDetailPerCategory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Find the first RamAssemblyLineTypeDetailPerCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<ramAssemblyLineTypeDetailPerCategoryGetPayload<T>>

    /**
     * Count the number of RamAssemblyLineTypeDetailPerCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryCountArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerCategories to count.
     * @example
     * // Count the number of RamAssemblyLineTypeDetailPerCategories
     * const count = await prisma.ramAssemblyLineTypeDetailPerCategory.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerCategories we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypeDetailPerCategoryCountArgs>(
      args?: Subset<T, ramAssemblyLineTypeDetailPerCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypeDetailPerCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypeDetailPerCategoryAggregateArgs>(args: Subset<T, RamAssemblyLineTypeDetailPerCategoryAggregateArgs>): PrismaPromise<GetRamAssemblyLineTypeDetailPerCategoryAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypeDetailPerCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamAssemblyLineTypeDetailPerCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamAssemblyLineTypeDetailPerCategoryGroupByArgs['orderBy'] }
        : { orderBy?: RamAssemblyLineTypeDetailPerCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamAssemblyLineTypeDetailPerCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypeDetailPerCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypeDetailPerCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramAssemblyLineTypeDetailPerCategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramAssemblyLineTypeDetailPerCategory base type for findUnique actions
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }

  /**
   * ramAssemblyLineTypeDetailPerCategory: findUnique
   */
  export interface ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs extends ramAssemblyLineTypeDetailPerCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypeDetailPerCategory base type for findFirst actions
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    distinct?: Enumerable<RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum>
  }

  /**
   * ramAssemblyLineTypeDetailPerCategory: findFirst
   */
  export interface ramAssemblyLineTypeDetailPerCategoryFindFirstArgs extends ramAssemblyLineTypeDetailPerCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypeDetailPerCategory findMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategories to fetch.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum>
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory create
   */
  export type ramAssemblyLineTypeDetailPerCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * The data needed to create a ramAssemblyLineTypeDetailPerCategory.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerCategoryCreateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory createMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryCreateManyArgs = {
    /**
     * The data used to create many ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    data: Enumerable<ramAssemblyLineTypeDetailPerCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory update
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * The data needed to update a ramAssemblyLineTypeDetailPerCategory.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypeDetailPerCategory to update.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory updateMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs = {
    /**
     * The data used to update ramAssemblyLineTypeDetailPerCategories.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateManyMutationInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategories to update
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory upsert
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * The filter to search for the ramAssemblyLineTypeDetailPerCategory to update in case it exists.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypeDetailPerCategory found by the `where` argument doesn't exist, create a new ramAssemblyLineTypeDetailPerCategory with this data.
     * 
    **/
    create: XOR<ramAssemblyLineTypeDetailPerCategoryCreateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypeDetailPerCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory delete
   */
  export type ramAssemblyLineTypeDetailPerCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategory to delete.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory deleteMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategories to delete
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory: findUniqueOrThrow
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs = ramAssemblyLineTypeDetailPerCategoryFindUniqueArgsBase
      

  /**
   * ramAssemblyLineTypeDetailPerCategory: findFirstOrThrow
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs = ramAssemblyLineTypeDetailPerCategoryFindFirstArgsBase
      

  /**
   * ramAssemblyLineTypeDetailPerCategory without action
   */
  export type ramAssemblyLineTypeDetailPerCategoryArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerCategorySelect | null
  }



  /**
   * Model ramAssemblyLineTypeDetailPerGroup
   */


  export type AggregateRamAssemblyLineTypeDetailPerGroup = {
    _count: RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier: number
    materialMultiplier: number
    costMultiplier: number
    _all: number
  }


  export type RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupSumAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupMinAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupCountAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
    _all?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupAggregateArgs = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroup to aggregate.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypeDetailPerGroups
    **/
    _count?: true | RamAssemblyLineTypeDetailPerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypeDetailPerGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypeDetailPerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypeDetailPerGroupAggregateType<T extends RamAssemblyLineTypeDetailPerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypeDetailPerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerGroup[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerGroup[P]>
  }




  export type RamAssemblyLineTypeDetailPerGroupGroupByArgs = {
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerGroupOrderByWithAggregationInput>
    by: Array<RamAssemblyLineTypeDetailPerGroupScalarFieldEnum>
    having?: ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypeDetailPerGroupCountAggregateInputType | true
    _avg?: RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType
    _sum?: RamAssemblyLineTypeDetailPerGroupSumAggregateInputType
    _min?: RamAssemblyLineTypeDetailPerGroupMinAggregateInputType
    _max?: RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType
  }


  export type RamAssemblyLineTypeDetailPerGroupGroupByOutputType = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
    _count: RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypeDetailPerGroupGroupByPayload<T extends RamAssemblyLineTypeDetailPerGroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamAssemblyLineTypeDetailPerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypeDetailPerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypeDetailPerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypeDetailPerGroupGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypeDetailPerGroupSelect = {
    assemblyLineTypeID?: boolean
    groupID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }


  export type ramAssemblyLineTypeDetailPerGroupGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypeDetailPerGroupArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramAssemblyLineTypeDetailPerGroup :
    S extends undefined ? never :
    S extends { include: any } & (ramAssemblyLineTypeDetailPerGroupArgs | ramAssemblyLineTypeDetailPerGroupFindManyArgs)
    ? ramAssemblyLineTypeDetailPerGroup 
    : S extends { select: any } & (ramAssemblyLineTypeDetailPerGroupArgs | ramAssemblyLineTypeDetailPerGroupFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramAssemblyLineTypeDetailPerGroup ? ramAssemblyLineTypeDetailPerGroup[P] : never
  } 
      : ramAssemblyLineTypeDetailPerGroup


  type ramAssemblyLineTypeDetailPerGroupCountArgs = Merge<
    Omit<ramAssemblyLineTypeDetailPerGroupFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypeDetailPerGroupCountAggregateInputType | true
    }
  >

  export interface ramAssemblyLineTypeDetailPerGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamAssemblyLineTypeDetailPerGroup that matches the filter.
     * @param {ramAssemblyLineTypeDetailPerGroupFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypeDetailPerGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramAssemblyLineTypeDetailPerGroup'> extends True ? Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>> : Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T> | null, null>

    /**
     * Find the first RamAssemblyLineTypeDetailPerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindFirstArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypeDetailPerGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramAssemblyLineTypeDetailPerGroup'> extends True ? Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>> : Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T> | null, null>

    /**
     * Find zero or more RamAssemblyLineTypeDetailPerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypeDetailPerGroupWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypeDetailPerGroupFindManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindManyArgs>
    ): PrismaPromise<Array<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>>

    /**
     * Create a RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupCreateArgs} args - Arguments to create a RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Create one RamAssemblyLineTypeDetailPerGroup
     * const RamAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerGroup
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypeDetailPerGroupCreateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupCreateArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Create many RamAssemblyLineTypeDetailPerGroups.
     *     @param {ramAssemblyLineTypeDetailPerGroupCreateManyArgs} args - Arguments to create many RamAssemblyLineTypeDetailPerGroups.
     *     @example
     *     // Create many RamAssemblyLineTypeDetailPerGroups
     *     const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypeDetailPerGroupCreateManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupDeleteArgs} args - Arguments to delete one RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Delete one RamAssemblyLineTypeDetailPerGroup
     * const RamAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypeDetailPerGroup
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypeDetailPerGroupDeleteArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupDeleteArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Update one RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupUpdateArgs} args - Arguments to update one RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Update one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypeDetailPerGroupUpdateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpdateArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Delete zero or more RamAssemblyLineTypeDetailPerGroups.
     * @param {ramAssemblyLineTypeDetailPerGroupDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerGroups to delete.
     * @example
     * // Delete a few RamAssemblyLineTypeDetailPerGroups
     * const { count } = await prisma.ramAssemblyLineTypeDetailPerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypeDetailPerGroupDeleteManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypeDetailPerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypeDetailPerGroupUpdateManyArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Update or create a RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerGroup we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypeDetailPerGroupUpsertArgs>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpsertArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Find one RamAssemblyLineTypeDetailPerGroup that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Find the first RamAssemblyLineTypeDetailPerGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<ramAssemblyLineTypeDetailPerGroupGetPayload<T>>

    /**
     * Count the number of RamAssemblyLineTypeDetailPerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupCountArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerGroups to count.
     * @example
     * // Count the number of RamAssemblyLineTypeDetailPerGroups
     * const count = await prisma.ramAssemblyLineTypeDetailPerGroup.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerGroups we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypeDetailPerGroupCountArgs>(
      args?: Subset<T, ramAssemblyLineTypeDetailPerGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypeDetailPerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypeDetailPerGroupAggregateArgs>(args: Subset<T, RamAssemblyLineTypeDetailPerGroupAggregateArgs>): PrismaPromise<GetRamAssemblyLineTypeDetailPerGroupAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypeDetailPerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamAssemblyLineTypeDetailPerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamAssemblyLineTypeDetailPerGroupGroupByArgs['orderBy'] }
        : { orderBy?: RamAssemblyLineTypeDetailPerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamAssemblyLineTypeDetailPerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypeDetailPerGroupGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypeDetailPerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramAssemblyLineTypeDetailPerGroupClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramAssemblyLineTypeDetailPerGroup base type for findUnique actions
   */
  export type ramAssemblyLineTypeDetailPerGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }

  /**
   * ramAssemblyLineTypeDetailPerGroup: findUnique
   */
  export interface ramAssemblyLineTypeDetailPerGroupFindUniqueArgs extends ramAssemblyLineTypeDetailPerGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypeDetailPerGroup base type for findFirst actions
   */
  export type ramAssemblyLineTypeDetailPerGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    distinct?: Enumerable<RamAssemblyLineTypeDetailPerGroupScalarFieldEnum>
  }

  /**
   * ramAssemblyLineTypeDetailPerGroup: findFirst
   */
  export interface ramAssemblyLineTypeDetailPerGroupFindFirstArgs extends ramAssemblyLineTypeDetailPerGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypeDetailPerGroup findMany
   */
  export type ramAssemblyLineTypeDetailPerGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroups to fetch.
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamAssemblyLineTypeDetailPerGroupScalarFieldEnum>
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup create
   */
  export type ramAssemblyLineTypeDetailPerGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * The data needed to create a ramAssemblyLineTypeDetailPerGroup.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerGroupCreateInput, ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup createMany
   */
  export type ramAssemblyLineTypeDetailPerGroupCreateManyArgs = {
    /**
     * The data used to create many ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    data: Enumerable<ramAssemblyLineTypeDetailPerGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup update
   */
  export type ramAssemblyLineTypeDetailPerGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * The data needed to update a ramAssemblyLineTypeDetailPerGroup.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerGroupUpdateInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypeDetailPerGroup to update.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup updateMany
   */
  export type ramAssemblyLineTypeDetailPerGroupUpdateManyArgs = {
    /**
     * The data used to update ramAssemblyLineTypeDetailPerGroups.
     * 
    **/
    data: XOR<ramAssemblyLineTypeDetailPerGroupUpdateManyMutationInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroups to update
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup upsert
   */
  export type ramAssemblyLineTypeDetailPerGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * The filter to search for the ramAssemblyLineTypeDetailPerGroup to update in case it exists.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypeDetailPerGroup found by the `where` argument doesn't exist, create a new ramAssemblyLineTypeDetailPerGroup with this data.
     * 
    **/
    create: XOR<ramAssemblyLineTypeDetailPerGroupCreateInput, ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypeDetailPerGroup was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramAssemblyLineTypeDetailPerGroupUpdateInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup delete
   */
  export type ramAssemblyLineTypeDetailPerGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroup to delete.
     * 
    **/
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup deleteMany
   */
  export type ramAssemblyLineTypeDetailPerGroupDeleteManyArgs = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroups to delete
     * 
    **/
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup: findUniqueOrThrow
   */
  export type ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs = ramAssemblyLineTypeDetailPerGroupFindUniqueArgsBase
      

  /**
   * ramAssemblyLineTypeDetailPerGroup: findFirstOrThrow
   */
  export type ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs = ramAssemblyLineTypeDetailPerGroupFindFirstArgsBase
      

  /**
   * ramAssemblyLineTypeDetailPerGroup without action
   */
  export type ramAssemblyLineTypeDetailPerGroupArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     * 
    **/
    select?: ramAssemblyLineTypeDetailPerGroupSelect | null
  }



  /**
   * Model ramAssemblyLineTypes
   */


  export type AggregateRamAssemblyLineTypes = {
    _count: RamAssemblyLineTypesCountAggregateOutputType | null
    _avg: RamAssemblyLineTypesAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypesSumAggregateOutputType | null
    _min: RamAssemblyLineTypesMinAggregateOutputType | null
    _max: RamAssemblyLineTypesMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypesAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesSumAggregateOutputType = {
    assemblyLineTypeID: number | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesCountAggregateOutputType = {
    assemblyLineTypeID: number
    assemblyLineTypeName: number
    description: number
    baseTimeMultiplier: number
    baseMaterialMultiplier: number
    baseCostMultiplier: number
    volume: number
    activityID: number
    minCostPerHour: number
    _all: number
  }


  export type RamAssemblyLineTypesAvgAggregateInputType = {
    assemblyLineTypeID?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesSumAggregateInputType = {
    assemblyLineTypeID?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesMinAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesMaxAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesCountAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
    _all?: true
  }

  export type RamAssemblyLineTypesAggregateArgs = {
    /**
     * Filter which ramAssemblyLineTypes to aggregate.
     * 
    **/
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypes
    **/
    _count?: true | RamAssemblyLineTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypesMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypesAggregateType<T extends RamAssemblyLineTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypes[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypes[P]>
  }




  export type RamAssemblyLineTypesGroupByArgs = {
    where?: ramAssemblyLineTypesWhereInput
    orderBy?: Enumerable<ramAssemblyLineTypesOrderByWithAggregationInput>
    by: Array<RamAssemblyLineTypesScalarFieldEnum>
    having?: ramAssemblyLineTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypesCountAggregateInputType | true
    _avg?: RamAssemblyLineTypesAvgAggregateInputType
    _sum?: RamAssemblyLineTypesSumAggregateInputType
    _min?: RamAssemblyLineTypesMinAggregateInputType
    _max?: RamAssemblyLineTypesMaxAggregateInputType
  }


  export type RamAssemblyLineTypesGroupByOutputType = {
    assemblyLineTypeID: number
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
    _count: RamAssemblyLineTypesCountAggregateOutputType | null
    _avg: RamAssemblyLineTypesAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypesSumAggregateOutputType | null
    _min: RamAssemblyLineTypesMinAggregateOutputType | null
    _max: RamAssemblyLineTypesMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypesGroupByPayload<T extends RamAssemblyLineTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamAssemblyLineTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypesGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypesGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypesSelect = {
    assemblyLineTypeID?: boolean
    assemblyLineTypeName?: boolean
    description?: boolean
    baseTimeMultiplier?: boolean
    baseMaterialMultiplier?: boolean
    baseCostMultiplier?: boolean
    volume?: boolean
    activityID?: boolean
    minCostPerHour?: boolean
  }


  export type ramAssemblyLineTypesGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramAssemblyLineTypes :
    S extends undefined ? never :
    S extends { include: any } & (ramAssemblyLineTypesArgs | ramAssemblyLineTypesFindManyArgs)
    ? ramAssemblyLineTypes 
    : S extends { select: any } & (ramAssemblyLineTypesArgs | ramAssemblyLineTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramAssemblyLineTypes ? ramAssemblyLineTypes[P] : never
  } 
      : ramAssemblyLineTypes


  type ramAssemblyLineTypesCountArgs = Merge<
    Omit<ramAssemblyLineTypesFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypesCountAggregateInputType | true
    }
  >

  export interface ramAssemblyLineTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamAssemblyLineTypes that matches the filter.
     * @param {ramAssemblyLineTypesFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramAssemblyLineTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramAssemblyLineTypes'> extends True ? Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>> : Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T> | null, null>

    /**
     * Find the first RamAssemblyLineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindFirstArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramAssemblyLineTypes'> extends True ? Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>> : Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T> | null, null>

    /**
     * Find zero or more RamAssemblyLineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypesWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypes.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypesFindManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindManyArgs>
    ): PrismaPromise<Array<ramAssemblyLineTypesGetPayload<T>>>

    /**
     * Create a RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesCreateArgs} args - Arguments to create a RamAssemblyLineTypes.
     * @example
     * // Create one RamAssemblyLineTypes
     * const RamAssemblyLineTypes = await prisma.ramAssemblyLineTypes.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypes
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypesCreateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypesCreateArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Create many RamAssemblyLineTypes.
     *     @param {ramAssemblyLineTypesCreateManyArgs} args - Arguments to create many RamAssemblyLineTypes.
     *     @example
     *     // Create many RamAssemblyLineTypes
     *     const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypesCreateManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesDeleteArgs} args - Arguments to delete one RamAssemblyLineTypes.
     * @example
     * // Delete one RamAssemblyLineTypes
     * const RamAssemblyLineTypes = await prisma.ramAssemblyLineTypes.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypes
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypesDeleteArgs>(
      args: SelectSubset<T, ramAssemblyLineTypesDeleteArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Update one RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesUpdateArgs} args - Arguments to update one RamAssemblyLineTypes.
     * @example
     * // Update one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypesUpdateArgs>(
      args: SelectSubset<T, ramAssemblyLineTypesUpdateArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Delete zero or more RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypes to delete.
     * @example
     * // Delete a few RamAssemblyLineTypes
     * const { count } = await prisma.ramAssemblyLineTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypesDeleteManyArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypesUpdateManyArgs>(
      args: SelectSubset<T, ramAssemblyLineTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypes.
     * @example
     * // Update or create a RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypes we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypesUpsertArgs>(
      args: SelectSubset<T, ramAssemblyLineTypesUpsertArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Find one RamAssemblyLineTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramAssemblyLineTypesFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindUniqueOrThrowArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Find the first RamAssemblyLineTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindFirstOrThrowArgs>
    ): Prisma__ramAssemblyLineTypesClient<ramAssemblyLineTypesGetPayload<T>>

    /**
     * Count the number of RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesCountArgs} args - Arguments to filter RamAssemblyLineTypes to count.
     * @example
     * // Count the number of RamAssemblyLineTypes
     * const count = await prisma.ramAssemblyLineTypes.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypes we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypesCountArgs>(
      args?: Subset<T, ramAssemblyLineTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypesAggregateArgs>(args: Subset<T, RamAssemblyLineTypesAggregateArgs>): PrismaPromise<GetRamAssemblyLineTypesAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamAssemblyLineTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamAssemblyLineTypesGroupByArgs['orderBy'] }
        : { orderBy?: RamAssemblyLineTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamAssemblyLineTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramAssemblyLineTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramAssemblyLineTypes base type for findUnique actions
   */
  export type ramAssemblyLineTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     * 
    **/
    where: ramAssemblyLineTypesWhereUniqueInput
  }

  /**
   * ramAssemblyLineTypes: findUnique
   */
  export interface ramAssemblyLineTypesFindUniqueArgs extends ramAssemblyLineTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypes base type for findFirst actions
   */
  export type ramAssemblyLineTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     * 
    **/
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypes.
     * 
    **/
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypes.
     * 
    **/
    distinct?: Enumerable<RamAssemblyLineTypesScalarFieldEnum>
  }

  /**
   * ramAssemblyLineTypes: findFirst
   */
  export interface ramAssemblyLineTypesFindFirstArgs extends ramAssemblyLineTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramAssemblyLineTypes findMany
   */
  export type ramAssemblyLineTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     * 
    **/
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ramAssemblyLineTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypes.
     * 
    **/
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamAssemblyLineTypesScalarFieldEnum>
  }


  /**
   * ramAssemblyLineTypes create
   */
  export type ramAssemblyLineTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * The data needed to create a ramAssemblyLineTypes.
     * 
    **/
    data: XOR<ramAssemblyLineTypesCreateInput, ramAssemblyLineTypesUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypes createMany
   */
  export type ramAssemblyLineTypesCreateManyArgs = {
    /**
     * The data used to create many ramAssemblyLineTypes.
     * 
    **/
    data: Enumerable<ramAssemblyLineTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypes update
   */
  export type ramAssemblyLineTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * The data needed to update a ramAssemblyLineTypes.
     * 
    **/
    data: XOR<ramAssemblyLineTypesUpdateInput, ramAssemblyLineTypesUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypes to update.
     * 
    **/
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes updateMany
   */
  export type ramAssemblyLineTypesUpdateManyArgs = {
    /**
     * The data used to update ramAssemblyLineTypes.
     * 
    **/
    data: XOR<ramAssemblyLineTypesUpdateManyMutationInput, ramAssemblyLineTypesUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypes to update
     * 
    **/
    where?: ramAssemblyLineTypesWhereInput
  }


  /**
   * ramAssemblyLineTypes upsert
   */
  export type ramAssemblyLineTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * The filter to search for the ramAssemblyLineTypes to update in case it exists.
     * 
    **/
    where: ramAssemblyLineTypesWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypes found by the `where` argument doesn't exist, create a new ramAssemblyLineTypes with this data.
     * 
    **/
    create: XOR<ramAssemblyLineTypesCreateInput, ramAssemblyLineTypesUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramAssemblyLineTypesUpdateInput, ramAssemblyLineTypesUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypes delete
   */
  export type ramAssemblyLineTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
    /**
     * Filter which ramAssemblyLineTypes to delete.
     * 
    **/
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes deleteMany
   */
  export type ramAssemblyLineTypesDeleteManyArgs = {
    /**
     * Filter which ramAssemblyLineTypes to delete
     * 
    **/
    where?: ramAssemblyLineTypesWhereInput
  }


  /**
   * ramAssemblyLineTypes: findUniqueOrThrow
   */
  export type ramAssemblyLineTypesFindUniqueOrThrowArgs = ramAssemblyLineTypesFindUniqueArgsBase
      

  /**
   * ramAssemblyLineTypes: findFirstOrThrow
   */
  export type ramAssemblyLineTypesFindFirstOrThrowArgs = ramAssemblyLineTypesFindFirstArgsBase
      

  /**
   * ramAssemblyLineTypes without action
   */
  export type ramAssemblyLineTypesArgs = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     * 
    **/
    select?: ramAssemblyLineTypesSelect | null
  }



  /**
   * Model ramInstallationTypeContents
   */


  export type AggregateRamInstallationTypeContents = {
    _count: RamInstallationTypeContentsCountAggregateOutputType | null
    _avg: RamInstallationTypeContentsAvgAggregateOutputType | null
    _sum: RamInstallationTypeContentsSumAggregateOutputType | null
    _min: RamInstallationTypeContentsMinAggregateOutputType | null
    _max: RamInstallationTypeContentsMaxAggregateOutputType | null
  }

  export type RamInstallationTypeContentsAvgAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsSumAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsMinAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsMaxAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsCountAggregateOutputType = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity: number
    _all: number
  }


  export type RamInstallationTypeContentsAvgAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsSumAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsMinAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsMaxAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsCountAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
    _all?: true
  }

  export type RamInstallationTypeContentsAggregateArgs = {
    /**
     * Filter which ramInstallationTypeContents to aggregate.
     * 
    **/
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     * 
    **/
    orderBy?: Enumerable<ramInstallationTypeContentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramInstallationTypeContents
    **/
    _count?: true | RamInstallationTypeContentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamInstallationTypeContentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamInstallationTypeContentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamInstallationTypeContentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamInstallationTypeContentsMaxAggregateInputType
  }

  export type GetRamInstallationTypeContentsAggregateType<T extends RamInstallationTypeContentsAggregateArgs> = {
        [P in keyof T & keyof AggregateRamInstallationTypeContents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamInstallationTypeContents[P]>
      : GetScalarType<T[P], AggregateRamInstallationTypeContents[P]>
  }




  export type RamInstallationTypeContentsGroupByArgs = {
    where?: ramInstallationTypeContentsWhereInput
    orderBy?: Enumerable<ramInstallationTypeContentsOrderByWithAggregationInput>
    by: Array<RamInstallationTypeContentsScalarFieldEnum>
    having?: ramInstallationTypeContentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamInstallationTypeContentsCountAggregateInputType | true
    _avg?: RamInstallationTypeContentsAvgAggregateInputType
    _sum?: RamInstallationTypeContentsSumAggregateInputType
    _min?: RamInstallationTypeContentsMinAggregateInputType
    _max?: RamInstallationTypeContentsMaxAggregateInputType
  }


  export type RamInstallationTypeContentsGroupByOutputType = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity: number | null
    _count: RamInstallationTypeContentsCountAggregateOutputType | null
    _avg: RamInstallationTypeContentsAvgAggregateOutputType | null
    _sum: RamInstallationTypeContentsSumAggregateOutputType | null
    _min: RamInstallationTypeContentsMinAggregateOutputType | null
    _max: RamInstallationTypeContentsMaxAggregateOutputType | null
  }

  type GetRamInstallationTypeContentsGroupByPayload<T extends RamInstallationTypeContentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RamInstallationTypeContentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamInstallationTypeContentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamInstallationTypeContentsGroupByOutputType[P]>
            : GetScalarType<T[P], RamInstallationTypeContentsGroupByOutputType[P]>
        }
      >
    >


  export type ramInstallationTypeContentsSelect = {
    installationTypeID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
  }


  export type ramInstallationTypeContentsGetPayload<S extends boolean | null | undefined | ramInstallationTypeContentsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ramInstallationTypeContents :
    S extends undefined ? never :
    S extends { include: any } & (ramInstallationTypeContentsArgs | ramInstallationTypeContentsFindManyArgs)
    ? ramInstallationTypeContents 
    : S extends { select: any } & (ramInstallationTypeContentsArgs | ramInstallationTypeContentsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ramInstallationTypeContents ? ramInstallationTypeContents[P] : never
  } 
      : ramInstallationTypeContents


  type ramInstallationTypeContentsCountArgs = Merge<
    Omit<ramInstallationTypeContentsFindManyArgs, 'select' | 'include'> & {
      select?: RamInstallationTypeContentsCountAggregateInputType | true
    }
  >

  export interface ramInstallationTypeContentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RamInstallationTypeContents that matches the filter.
     * @param {ramInstallationTypeContentsFindUniqueArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramInstallationTypeContentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ramInstallationTypeContentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ramInstallationTypeContents'> extends True ? Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>> : Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T> | null, null>

    /**
     * Find the first RamInstallationTypeContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindFirstArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramInstallationTypeContentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ramInstallationTypeContents'> extends True ? Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>> : Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T> | null, null>

    /**
     * Find zero or more RamInstallationTypeContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany()
     * 
     * // Get first 10 RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany({ take: 10 })
     * 
     * // Only select the `installationTypeID`
     * const ramInstallationTypeContentsWithInstallationTypeIDOnly = await prisma.ramInstallationTypeContents.findMany({ select: { installationTypeID: true } })
     * 
    **/
    findMany<T extends ramInstallationTypeContentsFindManyArgs>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindManyArgs>
    ): PrismaPromise<Array<ramInstallationTypeContentsGetPayload<T>>>

    /**
     * Create a RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsCreateArgs} args - Arguments to create a RamInstallationTypeContents.
     * @example
     * // Create one RamInstallationTypeContents
     * const RamInstallationTypeContents = await prisma.ramInstallationTypeContents.create({
     *   data: {
     *     // ... data to create a RamInstallationTypeContents
     *   }
     * })
     * 
    **/
    create<T extends ramInstallationTypeContentsCreateArgs>(
      args: SelectSubset<T, ramInstallationTypeContentsCreateArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Create many RamInstallationTypeContents.
     *     @param {ramInstallationTypeContentsCreateManyArgs} args - Arguments to create many RamInstallationTypeContents.
     *     @example
     *     // Create many RamInstallationTypeContents
     *     const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramInstallationTypeContentsCreateManyArgs>(
      args?: SelectSubset<T, ramInstallationTypeContentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsDeleteArgs} args - Arguments to delete one RamInstallationTypeContents.
     * @example
     * // Delete one RamInstallationTypeContents
     * const RamInstallationTypeContents = await prisma.ramInstallationTypeContents.delete({
     *   where: {
     *     // ... filter to delete one RamInstallationTypeContents
     *   }
     * })
     * 
    **/
    delete<T extends ramInstallationTypeContentsDeleteArgs>(
      args: SelectSubset<T, ramInstallationTypeContentsDeleteArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Update one RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsUpdateArgs} args - Arguments to update one RamInstallationTypeContents.
     * @example
     * // Update one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramInstallationTypeContentsUpdateArgs>(
      args: SelectSubset<T, ramInstallationTypeContentsUpdateArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Delete zero or more RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsDeleteManyArgs} args - Arguments to filter RamInstallationTypeContents to delete.
     * @example
     * // Delete a few RamInstallationTypeContents
     * const { count } = await prisma.ramInstallationTypeContents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramInstallationTypeContentsDeleteManyArgs>(
      args?: SelectSubset<T, ramInstallationTypeContentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramInstallationTypeContentsUpdateManyArgs>(
      args: SelectSubset<T, ramInstallationTypeContentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsUpsertArgs} args - Arguments to update or create a RamInstallationTypeContents.
     * @example
     * // Update or create a RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.upsert({
     *   create: {
     *     // ... data to create a RamInstallationTypeContents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamInstallationTypeContents we want to update
     *   }
     * })
    **/
    upsert<T extends ramInstallationTypeContentsUpsertArgs>(
      args: SelectSubset<T, ramInstallationTypeContentsUpsertArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Find one RamInstallationTypeContents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ramInstallationTypeContentsFindUniqueOrThrowArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramInstallationTypeContentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindUniqueOrThrowArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Find the first RamInstallationTypeContents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindFirstOrThrowArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramInstallationTypeContentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindFirstOrThrowArgs>
    ): Prisma__ramInstallationTypeContentsClient<ramInstallationTypeContentsGetPayload<T>>

    /**
     * Count the number of RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsCountArgs} args - Arguments to filter RamInstallationTypeContents to count.
     * @example
     * // Count the number of RamInstallationTypeContents
     * const count = await prisma.ramInstallationTypeContents.count({
     *   where: {
     *     // ... the filter for the RamInstallationTypeContents we want to count
     *   }
     * })
    **/
    count<T extends ramInstallationTypeContentsCountArgs>(
      args?: Subset<T, ramInstallationTypeContentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamInstallationTypeContentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamInstallationTypeContentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamInstallationTypeContentsAggregateArgs>(args: Subset<T, RamInstallationTypeContentsAggregateArgs>): PrismaPromise<GetRamInstallationTypeContentsAggregateType<T>>

    /**
     * Group by RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamInstallationTypeContentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RamInstallationTypeContentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RamInstallationTypeContentsGroupByArgs['orderBy'] }
        : { orderBy?: RamInstallationTypeContentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RamInstallationTypeContentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamInstallationTypeContentsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ramInstallationTypeContents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ramInstallationTypeContentsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ramInstallationTypeContents base type for findUnique actions
   */
  export type ramInstallationTypeContentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     * 
    **/
    where: ramInstallationTypeContentsWhereUniqueInput
  }

  /**
   * ramInstallationTypeContents: findUnique
   */
  export interface ramInstallationTypeContentsFindUniqueArgs extends ramInstallationTypeContentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramInstallationTypeContents base type for findFirst actions
   */
  export type ramInstallationTypeContentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     * 
    **/
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     * 
    **/
    orderBy?: Enumerable<ramInstallationTypeContentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramInstallationTypeContents.
     * 
    **/
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramInstallationTypeContents.
     * 
    **/
    distinct?: Enumerable<RamInstallationTypeContentsScalarFieldEnum>
  }

  /**
   * ramInstallationTypeContents: findFirst
   */
  export interface ramInstallationTypeContentsFindFirstArgs extends ramInstallationTypeContentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ramInstallationTypeContents findMany
   */
  export type ramInstallationTypeContentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     * 
    **/
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     * 
    **/
    orderBy?: Enumerable<ramInstallationTypeContentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramInstallationTypeContents.
     * 
    **/
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RamInstallationTypeContentsScalarFieldEnum>
  }


  /**
   * ramInstallationTypeContents create
   */
  export type ramInstallationTypeContentsCreateArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * The data needed to create a ramInstallationTypeContents.
     * 
    **/
    data: XOR<ramInstallationTypeContentsCreateInput, ramInstallationTypeContentsUncheckedCreateInput>
  }


  /**
   * ramInstallationTypeContents createMany
   */
  export type ramInstallationTypeContentsCreateManyArgs = {
    /**
     * The data used to create many ramInstallationTypeContents.
     * 
    **/
    data: Enumerable<ramInstallationTypeContentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ramInstallationTypeContents update
   */
  export type ramInstallationTypeContentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * The data needed to update a ramInstallationTypeContents.
     * 
    **/
    data: XOR<ramInstallationTypeContentsUpdateInput, ramInstallationTypeContentsUncheckedUpdateInput>
    /**
     * Choose, which ramInstallationTypeContents to update.
     * 
    **/
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents updateMany
   */
  export type ramInstallationTypeContentsUpdateManyArgs = {
    /**
     * The data used to update ramInstallationTypeContents.
     * 
    **/
    data: XOR<ramInstallationTypeContentsUpdateManyMutationInput, ramInstallationTypeContentsUncheckedUpdateManyInput>
    /**
     * Filter which ramInstallationTypeContents to update
     * 
    **/
    where?: ramInstallationTypeContentsWhereInput
  }


  /**
   * ramInstallationTypeContents upsert
   */
  export type ramInstallationTypeContentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * The filter to search for the ramInstallationTypeContents to update in case it exists.
     * 
    **/
    where: ramInstallationTypeContentsWhereUniqueInput
    /**
     * In case the ramInstallationTypeContents found by the `where` argument doesn't exist, create a new ramInstallationTypeContents with this data.
     * 
    **/
    create: XOR<ramInstallationTypeContentsCreateInput, ramInstallationTypeContentsUncheckedCreateInput>
    /**
     * In case the ramInstallationTypeContents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ramInstallationTypeContentsUpdateInput, ramInstallationTypeContentsUncheckedUpdateInput>
  }


  /**
   * ramInstallationTypeContents delete
   */
  export type ramInstallationTypeContentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
    /**
     * Filter which ramInstallationTypeContents to delete.
     * 
    **/
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents deleteMany
   */
  export type ramInstallationTypeContentsDeleteManyArgs = {
    /**
     * Filter which ramInstallationTypeContents to delete
     * 
    **/
    where?: ramInstallationTypeContentsWhereInput
  }


  /**
   * ramInstallationTypeContents: findUniqueOrThrow
   */
  export type ramInstallationTypeContentsFindUniqueOrThrowArgs = ramInstallationTypeContentsFindUniqueArgsBase
      

  /**
   * ramInstallationTypeContents: findFirstOrThrow
   */
  export type ramInstallationTypeContentsFindFirstOrThrowArgs = ramInstallationTypeContentsFindFirstArgsBase
      

  /**
   * ramInstallationTypeContents without action
   */
  export type ramInstallationTypeContentsArgs = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     * 
    **/
    select?: ramInstallationTypeContentsSelect | null
  }



  /**
   * Model skinLicense
   */


  export type AggregateSkinLicense = {
    _count: SkinLicenseCountAggregateOutputType | null
    _avg: SkinLicenseAvgAggregateOutputType | null
    _sum: SkinLicenseSumAggregateOutputType | null
    _min: SkinLicenseMinAggregateOutputType | null
    _max: SkinLicenseMaxAggregateOutputType | null
  }

  export type SkinLicenseAvgAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseSumAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseMinAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseMaxAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseCountAggregateOutputType = {
    licenseTypeID: number
    duration: number
    skinID: number
    _all: number
  }


  export type SkinLicenseAvgAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseSumAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseMinAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseMaxAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseCountAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
    _all?: true
  }

  export type SkinLicenseAggregateArgs = {
    /**
     * Filter which skinLicense to aggregate.
     * 
    **/
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     * 
    **/
    orderBy?: Enumerable<skinLicenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skinLicenses
    **/
    _count?: true | SkinLicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinLicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinLicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinLicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinLicenseMaxAggregateInputType
  }

  export type GetSkinLicenseAggregateType<T extends SkinLicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateSkinLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkinLicense[P]>
      : GetScalarType<T[P], AggregateSkinLicense[P]>
  }




  export type SkinLicenseGroupByArgs = {
    where?: skinLicenseWhereInput
    orderBy?: Enumerable<skinLicenseOrderByWithAggregationInput>
    by: Array<SkinLicenseScalarFieldEnum>
    having?: skinLicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinLicenseCountAggregateInputType | true
    _avg?: SkinLicenseAvgAggregateInputType
    _sum?: SkinLicenseSumAggregateInputType
    _min?: SkinLicenseMinAggregateInputType
    _max?: SkinLicenseMaxAggregateInputType
  }


  export type SkinLicenseGroupByOutputType = {
    licenseTypeID: number
    duration: number | null
    skinID: number | null
    _count: SkinLicenseCountAggregateOutputType | null
    _avg: SkinLicenseAvgAggregateOutputType | null
    _sum: SkinLicenseSumAggregateOutputType | null
    _min: SkinLicenseMinAggregateOutputType | null
    _max: SkinLicenseMaxAggregateOutputType | null
  }

  type GetSkinLicenseGroupByPayload<T extends SkinLicenseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SkinLicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinLicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinLicenseGroupByOutputType[P]>
            : GetScalarType<T[P], SkinLicenseGroupByOutputType[P]>
        }
      >
    >


  export type skinLicenseSelect = {
    licenseTypeID?: boolean
    duration?: boolean
    skinID?: boolean
  }


  export type skinLicenseGetPayload<S extends boolean | null | undefined | skinLicenseArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skinLicense :
    S extends undefined ? never :
    S extends { include: any } & (skinLicenseArgs | skinLicenseFindManyArgs)
    ? skinLicense 
    : S extends { select: any } & (skinLicenseArgs | skinLicenseFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof skinLicense ? skinLicense[P] : never
  } 
      : skinLicense


  type skinLicenseCountArgs = Merge<
    Omit<skinLicenseFindManyArgs, 'select' | 'include'> & {
      select?: SkinLicenseCountAggregateInputType | true
    }
  >

  export interface skinLicenseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SkinLicense that matches the filter.
     * @param {skinLicenseFindUniqueArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinLicenseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skinLicenseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skinLicense'> extends True ? Prisma__skinLicenseClient<skinLicenseGetPayload<T>> : Prisma__skinLicenseClient<skinLicenseGetPayload<T> | null, null>

    /**
     * Find the first SkinLicense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindFirstArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinLicenseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skinLicenseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skinLicense'> extends True ? Prisma__skinLicenseClient<skinLicenseGetPayload<T>> : Prisma__skinLicenseClient<skinLicenseGetPayload<T> | null, null>

    /**
     * Find zero or more SkinLicenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkinLicenses
     * const skinLicenses = await prisma.skinLicense.findMany()
     * 
     * // Get first 10 SkinLicenses
     * const skinLicenses = await prisma.skinLicense.findMany({ take: 10 })
     * 
     * // Only select the `licenseTypeID`
     * const skinLicenseWithLicenseTypeIDOnly = await prisma.skinLicense.findMany({ select: { licenseTypeID: true } })
     * 
    **/
    findMany<T extends skinLicenseFindManyArgs>(
      args?: SelectSubset<T, skinLicenseFindManyArgs>
    ): PrismaPromise<Array<skinLicenseGetPayload<T>>>

    /**
     * Create a SkinLicense.
     * @param {skinLicenseCreateArgs} args - Arguments to create a SkinLicense.
     * @example
     * // Create one SkinLicense
     * const SkinLicense = await prisma.skinLicense.create({
     *   data: {
     *     // ... data to create a SkinLicense
     *   }
     * })
     * 
    **/
    create<T extends skinLicenseCreateArgs>(
      args: SelectSubset<T, skinLicenseCreateArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Create many SkinLicenses.
     *     @param {skinLicenseCreateManyArgs} args - Arguments to create many SkinLicenses.
     *     @example
     *     // Create many SkinLicenses
     *     const skinLicense = await prisma.skinLicense.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinLicenseCreateManyArgs>(
      args?: SelectSubset<T, skinLicenseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SkinLicense.
     * @param {skinLicenseDeleteArgs} args - Arguments to delete one SkinLicense.
     * @example
     * // Delete one SkinLicense
     * const SkinLicense = await prisma.skinLicense.delete({
     *   where: {
     *     // ... filter to delete one SkinLicense
     *   }
     * })
     * 
    **/
    delete<T extends skinLicenseDeleteArgs>(
      args: SelectSubset<T, skinLicenseDeleteArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Update one SkinLicense.
     * @param {skinLicenseUpdateArgs} args - Arguments to update one SkinLicense.
     * @example
     * // Update one SkinLicense
     * const skinLicense = await prisma.skinLicense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinLicenseUpdateArgs>(
      args: SelectSubset<T, skinLicenseUpdateArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Delete zero or more SkinLicenses.
     * @param {skinLicenseDeleteManyArgs} args - Arguments to filter SkinLicenses to delete.
     * @example
     * // Delete a few SkinLicenses
     * const { count } = await prisma.skinLicense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinLicenseDeleteManyArgs>(
      args?: SelectSubset<T, skinLicenseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkinLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkinLicenses
     * const skinLicense = await prisma.skinLicense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinLicenseUpdateManyArgs>(
      args: SelectSubset<T, skinLicenseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SkinLicense.
     * @param {skinLicenseUpsertArgs} args - Arguments to update or create a SkinLicense.
     * @example
     * // Update or create a SkinLicense
     * const skinLicense = await prisma.skinLicense.upsert({
     *   create: {
     *     // ... data to create a SkinLicense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkinLicense we want to update
     *   }
     * })
    **/
    upsert<T extends skinLicenseUpsertArgs>(
      args: SelectSubset<T, skinLicenseUpsertArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Find one SkinLicense that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {skinLicenseFindUniqueOrThrowArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinLicenseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skinLicenseFindUniqueOrThrowArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Find the first SkinLicense that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindFirstOrThrowArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinLicenseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skinLicenseFindFirstOrThrowArgs>
    ): Prisma__skinLicenseClient<skinLicenseGetPayload<T>>

    /**
     * Count the number of SkinLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseCountArgs} args - Arguments to filter SkinLicenses to count.
     * @example
     * // Count the number of SkinLicenses
     * const count = await prisma.skinLicense.count({
     *   where: {
     *     // ... the filter for the SkinLicenses we want to count
     *   }
     * })
    **/
    count<T extends skinLicenseCountArgs>(
      args?: Subset<T, skinLicenseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinLicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkinLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinLicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinLicenseAggregateArgs>(args: Subset<T, SkinLicenseAggregateArgs>): PrismaPromise<GetSkinLicenseAggregateType<T>>

    /**
     * Group by SkinLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinLicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkinLicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkinLicenseGroupByArgs['orderBy'] }
        : { orderBy?: SkinLicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkinLicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinLicenseGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skinLicense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skinLicenseClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skinLicense base type for findUnique actions
   */
  export type skinLicenseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * Filter, which skinLicense to fetch.
     * 
    **/
    where: skinLicenseWhereUniqueInput
  }

  /**
   * skinLicense: findUnique
   */
  export interface skinLicenseFindUniqueArgs extends skinLicenseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skinLicense base type for findFirst actions
   */
  export type skinLicenseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * Filter, which skinLicense to fetch.
     * 
    **/
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     * 
    **/
    orderBy?: Enumerable<skinLicenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinLicenses.
     * 
    **/
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinLicenses.
     * 
    **/
    distinct?: Enumerable<SkinLicenseScalarFieldEnum>
  }

  /**
   * skinLicense: findFirst
   */
  export interface skinLicenseFindFirstArgs extends skinLicenseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skinLicense findMany
   */
  export type skinLicenseFindManyArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * Filter, which skinLicenses to fetch.
     * 
    **/
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     * 
    **/
    orderBy?: Enumerable<skinLicenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skinLicenses.
     * 
    **/
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SkinLicenseScalarFieldEnum>
  }


  /**
   * skinLicense create
   */
  export type skinLicenseCreateArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * The data needed to create a skinLicense.
     * 
    **/
    data: XOR<skinLicenseCreateInput, skinLicenseUncheckedCreateInput>
  }


  /**
   * skinLicense createMany
   */
  export type skinLicenseCreateManyArgs = {
    /**
     * The data used to create many skinLicenses.
     * 
    **/
    data: Enumerable<skinLicenseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skinLicense update
   */
  export type skinLicenseUpdateArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * The data needed to update a skinLicense.
     * 
    **/
    data: XOR<skinLicenseUpdateInput, skinLicenseUncheckedUpdateInput>
    /**
     * Choose, which skinLicense to update.
     * 
    **/
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense updateMany
   */
  export type skinLicenseUpdateManyArgs = {
    /**
     * The data used to update skinLicenses.
     * 
    **/
    data: XOR<skinLicenseUpdateManyMutationInput, skinLicenseUncheckedUpdateManyInput>
    /**
     * Filter which skinLicenses to update
     * 
    **/
    where?: skinLicenseWhereInput
  }


  /**
   * skinLicense upsert
   */
  export type skinLicenseUpsertArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * The filter to search for the skinLicense to update in case it exists.
     * 
    **/
    where: skinLicenseWhereUniqueInput
    /**
     * In case the skinLicense found by the `where` argument doesn't exist, create a new skinLicense with this data.
     * 
    **/
    create: XOR<skinLicenseCreateInput, skinLicenseUncheckedCreateInput>
    /**
     * In case the skinLicense was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<skinLicenseUpdateInput, skinLicenseUncheckedUpdateInput>
  }


  /**
   * skinLicense delete
   */
  export type skinLicenseDeleteArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
    /**
     * Filter which skinLicense to delete.
     * 
    **/
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense deleteMany
   */
  export type skinLicenseDeleteManyArgs = {
    /**
     * Filter which skinLicenses to delete
     * 
    **/
    where?: skinLicenseWhereInput
  }


  /**
   * skinLicense: findUniqueOrThrow
   */
  export type skinLicenseFindUniqueOrThrowArgs = skinLicenseFindUniqueArgsBase
      

  /**
   * skinLicense: findFirstOrThrow
   */
  export type skinLicenseFindFirstOrThrowArgs = skinLicenseFindFirstArgsBase
      

  /**
   * skinLicense without action
   */
  export type skinLicenseArgs = {
    /**
     * Select specific fields to fetch from the skinLicense
     * 
    **/
    select?: skinLicenseSelect | null
  }



  /**
   * Model skinMaterials
   */


  export type AggregateSkinMaterials = {
    _count: SkinMaterialsCountAggregateOutputType | null
    _avg: SkinMaterialsAvgAggregateOutputType | null
    _sum: SkinMaterialsSumAggregateOutputType | null
    _min: SkinMaterialsMinAggregateOutputType | null
    _max: SkinMaterialsMaxAggregateOutputType | null
  }

  export type SkinMaterialsAvgAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsSumAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsMinAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsMaxAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsCountAggregateOutputType = {
    skinMaterialID: number
    displayNameID: number
    materialSetID: number
    _all: number
  }


  export type SkinMaterialsAvgAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsSumAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsMinAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsMaxAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsCountAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
    _all?: true
  }

  export type SkinMaterialsAggregateArgs = {
    /**
     * Filter which skinMaterials to aggregate.
     * 
    **/
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<skinMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skinMaterials
    **/
    _count?: true | SkinMaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinMaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinMaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinMaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinMaterialsMaxAggregateInputType
  }

  export type GetSkinMaterialsAggregateType<T extends SkinMaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkinMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkinMaterials[P]>
      : GetScalarType<T[P], AggregateSkinMaterials[P]>
  }




  export type SkinMaterialsGroupByArgs = {
    where?: skinMaterialsWhereInput
    orderBy?: Enumerable<skinMaterialsOrderByWithAggregationInput>
    by: Array<SkinMaterialsScalarFieldEnum>
    having?: skinMaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinMaterialsCountAggregateInputType | true
    _avg?: SkinMaterialsAvgAggregateInputType
    _sum?: SkinMaterialsSumAggregateInputType
    _min?: SkinMaterialsMinAggregateInputType
    _max?: SkinMaterialsMaxAggregateInputType
  }


  export type SkinMaterialsGroupByOutputType = {
    skinMaterialID: number
    displayNameID: number | null
    materialSetID: number | null
    _count: SkinMaterialsCountAggregateOutputType | null
    _avg: SkinMaterialsAvgAggregateOutputType | null
    _sum: SkinMaterialsSumAggregateOutputType | null
    _min: SkinMaterialsMinAggregateOutputType | null
    _max: SkinMaterialsMaxAggregateOutputType | null
  }

  type GetSkinMaterialsGroupByPayload<T extends SkinMaterialsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SkinMaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinMaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinMaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], SkinMaterialsGroupByOutputType[P]>
        }
      >
    >


  export type skinMaterialsSelect = {
    skinMaterialID?: boolean
    displayNameID?: boolean
    materialSetID?: boolean
  }


  export type skinMaterialsGetPayload<S extends boolean | null | undefined | skinMaterialsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skinMaterials :
    S extends undefined ? never :
    S extends { include: any } & (skinMaterialsArgs | skinMaterialsFindManyArgs)
    ? skinMaterials 
    : S extends { select: any } & (skinMaterialsArgs | skinMaterialsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof skinMaterials ? skinMaterials[P] : never
  } 
      : skinMaterials


  type skinMaterialsCountArgs = Merge<
    Omit<skinMaterialsFindManyArgs, 'select' | 'include'> & {
      select?: SkinMaterialsCountAggregateInputType | true
    }
  >

  export interface skinMaterialsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SkinMaterials that matches the filter.
     * @param {skinMaterialsFindUniqueArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinMaterialsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skinMaterialsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skinMaterials'> extends True ? Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>> : Prisma__skinMaterialsClient<skinMaterialsGetPayload<T> | null, null>

    /**
     * Find the first SkinMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindFirstArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinMaterialsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skinMaterialsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skinMaterials'> extends True ? Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>> : Prisma__skinMaterialsClient<skinMaterialsGetPayload<T> | null, null>

    /**
     * Find zero or more SkinMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findMany()
     * 
     * // Get first 10 SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findMany({ take: 10 })
     * 
     * // Only select the `skinMaterialID`
     * const skinMaterialsWithSkinMaterialIDOnly = await prisma.skinMaterials.findMany({ select: { skinMaterialID: true } })
     * 
    **/
    findMany<T extends skinMaterialsFindManyArgs>(
      args?: SelectSubset<T, skinMaterialsFindManyArgs>
    ): PrismaPromise<Array<skinMaterialsGetPayload<T>>>

    /**
     * Create a SkinMaterials.
     * @param {skinMaterialsCreateArgs} args - Arguments to create a SkinMaterials.
     * @example
     * // Create one SkinMaterials
     * const SkinMaterials = await prisma.skinMaterials.create({
     *   data: {
     *     // ... data to create a SkinMaterials
     *   }
     * })
     * 
    **/
    create<T extends skinMaterialsCreateArgs>(
      args: SelectSubset<T, skinMaterialsCreateArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Create many SkinMaterials.
     *     @param {skinMaterialsCreateManyArgs} args - Arguments to create many SkinMaterials.
     *     @example
     *     // Create many SkinMaterials
     *     const skinMaterials = await prisma.skinMaterials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinMaterialsCreateManyArgs>(
      args?: SelectSubset<T, skinMaterialsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SkinMaterials.
     * @param {skinMaterialsDeleteArgs} args - Arguments to delete one SkinMaterials.
     * @example
     * // Delete one SkinMaterials
     * const SkinMaterials = await prisma.skinMaterials.delete({
     *   where: {
     *     // ... filter to delete one SkinMaterials
     *   }
     * })
     * 
    **/
    delete<T extends skinMaterialsDeleteArgs>(
      args: SelectSubset<T, skinMaterialsDeleteArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Update one SkinMaterials.
     * @param {skinMaterialsUpdateArgs} args - Arguments to update one SkinMaterials.
     * @example
     * // Update one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinMaterialsUpdateArgs>(
      args: SelectSubset<T, skinMaterialsUpdateArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Delete zero or more SkinMaterials.
     * @param {skinMaterialsDeleteManyArgs} args - Arguments to filter SkinMaterials to delete.
     * @example
     * // Delete a few SkinMaterials
     * const { count } = await prisma.skinMaterials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinMaterialsDeleteManyArgs>(
      args?: SelectSubset<T, skinMaterialsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinMaterialsUpdateManyArgs>(
      args: SelectSubset<T, skinMaterialsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SkinMaterials.
     * @param {skinMaterialsUpsertArgs} args - Arguments to update or create a SkinMaterials.
     * @example
     * // Update or create a SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.upsert({
     *   create: {
     *     // ... data to create a SkinMaterials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkinMaterials we want to update
     *   }
     * })
    **/
    upsert<T extends skinMaterialsUpsertArgs>(
      args: SelectSubset<T, skinMaterialsUpsertArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Find one SkinMaterials that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {skinMaterialsFindUniqueOrThrowArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinMaterialsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skinMaterialsFindUniqueOrThrowArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Find the first SkinMaterials that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindFirstOrThrowArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinMaterialsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skinMaterialsFindFirstOrThrowArgs>
    ): Prisma__skinMaterialsClient<skinMaterialsGetPayload<T>>

    /**
     * Count the number of SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsCountArgs} args - Arguments to filter SkinMaterials to count.
     * @example
     * // Count the number of SkinMaterials
     * const count = await prisma.skinMaterials.count({
     *   where: {
     *     // ... the filter for the SkinMaterials we want to count
     *   }
     * })
    **/
    count<T extends skinMaterialsCountArgs>(
      args?: Subset<T, skinMaterialsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinMaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinMaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinMaterialsAggregateArgs>(args: Subset<T, SkinMaterialsAggregateArgs>): PrismaPromise<GetSkinMaterialsAggregateType<T>>

    /**
     * Group by SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinMaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkinMaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkinMaterialsGroupByArgs['orderBy'] }
        : { orderBy?: SkinMaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkinMaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinMaterialsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skinMaterials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skinMaterialsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skinMaterials base type for findUnique actions
   */
  export type skinMaterialsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * Filter, which skinMaterials to fetch.
     * 
    **/
    where: skinMaterialsWhereUniqueInput
  }

  /**
   * skinMaterials: findUnique
   */
  export interface skinMaterialsFindUniqueArgs extends skinMaterialsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skinMaterials base type for findFirst actions
   */
  export type skinMaterialsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * Filter, which skinMaterials to fetch.
     * 
    **/
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<skinMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinMaterials.
     * 
    **/
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinMaterials.
     * 
    **/
    distinct?: Enumerable<SkinMaterialsScalarFieldEnum>
  }

  /**
   * skinMaterials: findFirst
   */
  export interface skinMaterialsFindFirstArgs extends skinMaterialsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skinMaterials findMany
   */
  export type skinMaterialsFindManyArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * Filter, which skinMaterials to fetch.
     * 
    **/
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     * 
    **/
    orderBy?: Enumerable<skinMaterialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skinMaterials.
     * 
    **/
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SkinMaterialsScalarFieldEnum>
  }


  /**
   * skinMaterials create
   */
  export type skinMaterialsCreateArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * The data needed to create a skinMaterials.
     * 
    **/
    data: XOR<skinMaterialsCreateInput, skinMaterialsUncheckedCreateInput>
  }


  /**
   * skinMaterials createMany
   */
  export type skinMaterialsCreateManyArgs = {
    /**
     * The data used to create many skinMaterials.
     * 
    **/
    data: Enumerable<skinMaterialsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skinMaterials update
   */
  export type skinMaterialsUpdateArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * The data needed to update a skinMaterials.
     * 
    **/
    data: XOR<skinMaterialsUpdateInput, skinMaterialsUncheckedUpdateInput>
    /**
     * Choose, which skinMaterials to update.
     * 
    **/
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials updateMany
   */
  export type skinMaterialsUpdateManyArgs = {
    /**
     * The data used to update skinMaterials.
     * 
    **/
    data: XOR<skinMaterialsUpdateManyMutationInput, skinMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which skinMaterials to update
     * 
    **/
    where?: skinMaterialsWhereInput
  }


  /**
   * skinMaterials upsert
   */
  export type skinMaterialsUpsertArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * The filter to search for the skinMaterials to update in case it exists.
     * 
    **/
    where: skinMaterialsWhereUniqueInput
    /**
     * In case the skinMaterials found by the `where` argument doesn't exist, create a new skinMaterials with this data.
     * 
    **/
    create: XOR<skinMaterialsCreateInput, skinMaterialsUncheckedCreateInput>
    /**
     * In case the skinMaterials was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<skinMaterialsUpdateInput, skinMaterialsUncheckedUpdateInput>
  }


  /**
   * skinMaterials delete
   */
  export type skinMaterialsDeleteArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
    /**
     * Filter which skinMaterials to delete.
     * 
    **/
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials deleteMany
   */
  export type skinMaterialsDeleteManyArgs = {
    /**
     * Filter which skinMaterials to delete
     * 
    **/
    where?: skinMaterialsWhereInput
  }


  /**
   * skinMaterials: findUniqueOrThrow
   */
  export type skinMaterialsFindUniqueOrThrowArgs = skinMaterialsFindUniqueArgsBase
      

  /**
   * skinMaterials: findFirstOrThrow
   */
  export type skinMaterialsFindFirstOrThrowArgs = skinMaterialsFindFirstArgsBase
      

  /**
   * skinMaterials without action
   */
  export type skinMaterialsArgs = {
    /**
     * Select specific fields to fetch from the skinMaterials
     * 
    **/
    select?: skinMaterialsSelect | null
  }



  /**
   * Model skins
   */


  export type AggregateSkins = {
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  export type SkinsAvgAggregateOutputType = {
    skinID: number | null
    skinMaterialID: number | null
  }

  export type SkinsSumAggregateOutputType = {
    skinID: number | null
    skinMaterialID: number | null
  }

  export type SkinsMinAggregateOutputType = {
    skinID: number | null
    internalName: string | null
    skinMaterialID: number | null
  }

  export type SkinsMaxAggregateOutputType = {
    skinID: number | null
    internalName: string | null
    skinMaterialID: number | null
  }

  export type SkinsCountAggregateOutputType = {
    skinID: number
    internalName: number
    skinMaterialID: number
    _all: number
  }


  export type SkinsAvgAggregateInputType = {
    skinID?: true
    skinMaterialID?: true
  }

  export type SkinsSumAggregateInputType = {
    skinID?: true
    skinMaterialID?: true
  }

  export type SkinsMinAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
  }

  export type SkinsMaxAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
  }

  export type SkinsCountAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
    _all?: true
  }

  export type SkinsAggregateArgs = {
    /**
     * Filter which skins to aggregate.
     * 
    **/
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     * 
    **/
    orderBy?: Enumerable<skinsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skins
    **/
    _count?: true | SkinsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinsMaxAggregateInputType
  }

  export type GetSkinsAggregateType<T extends SkinsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkins[P]>
      : GetScalarType<T[P], AggregateSkins[P]>
  }




  export type SkinsGroupByArgs = {
    where?: skinsWhereInput
    orderBy?: Enumerable<skinsOrderByWithAggregationInput>
    by: Array<SkinsScalarFieldEnum>
    having?: skinsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinsCountAggregateInputType | true
    _avg?: SkinsAvgAggregateInputType
    _sum?: SkinsSumAggregateInputType
    _min?: SkinsMinAggregateInputType
    _max?: SkinsMaxAggregateInputType
  }


  export type SkinsGroupByOutputType = {
    skinID: number
    internalName: string | null
    skinMaterialID: number | null
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  type GetSkinsGroupByPayload<T extends SkinsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SkinsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinsGroupByOutputType[P]>
            : GetScalarType<T[P], SkinsGroupByOutputType[P]>
        }
      >
    >


  export type skinsSelect = {
    skinID?: boolean
    internalName?: boolean
    skinMaterialID?: boolean
  }


  export type skinsGetPayload<S extends boolean | null | undefined | skinsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skins :
    S extends undefined ? never :
    S extends { include: any } & (skinsArgs | skinsFindManyArgs)
    ? skins 
    : S extends { select: any } & (skinsArgs | skinsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof skins ? skins[P] : never
  } 
      : skins


  type skinsCountArgs = Merge<
    Omit<skinsFindManyArgs, 'select' | 'include'> & {
      select?: SkinsCountAggregateInputType | true
    }
  >

  export interface skinsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Skins that matches the filter.
     * @param {skinsFindUniqueArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skinsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skins'> extends True ? Prisma__skinsClient<skinsGetPayload<T>> : Prisma__skinsClient<skinsGetPayload<T> | null, null>

    /**
     * Find the first Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindFirstArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skinsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skins'> extends True ? Prisma__skinsClient<skinsGetPayload<T>> : Prisma__skinsClient<skinsGetPayload<T> | null, null>

    /**
     * Find zero or more Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skins
     * const skins = await prisma.skins.findMany()
     * 
     * // Get first 10 Skins
     * const skins = await prisma.skins.findMany({ take: 10 })
     * 
     * // Only select the `skinID`
     * const skinsWithSkinIDOnly = await prisma.skins.findMany({ select: { skinID: true } })
     * 
    **/
    findMany<T extends skinsFindManyArgs>(
      args?: SelectSubset<T, skinsFindManyArgs>
    ): PrismaPromise<Array<skinsGetPayload<T>>>

    /**
     * Create a Skins.
     * @param {skinsCreateArgs} args - Arguments to create a Skins.
     * @example
     * // Create one Skins
     * const Skins = await prisma.skins.create({
     *   data: {
     *     // ... data to create a Skins
     *   }
     * })
     * 
    **/
    create<T extends skinsCreateArgs>(
      args: SelectSubset<T, skinsCreateArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Create many Skins.
     *     @param {skinsCreateManyArgs} args - Arguments to create many Skins.
     *     @example
     *     // Create many Skins
     *     const skins = await prisma.skins.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinsCreateManyArgs>(
      args?: SelectSubset<T, skinsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Skins.
     * @param {skinsDeleteArgs} args - Arguments to delete one Skins.
     * @example
     * // Delete one Skins
     * const Skins = await prisma.skins.delete({
     *   where: {
     *     // ... filter to delete one Skins
     *   }
     * })
     * 
    **/
    delete<T extends skinsDeleteArgs>(
      args: SelectSubset<T, skinsDeleteArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Update one Skins.
     * @param {skinsUpdateArgs} args - Arguments to update one Skins.
     * @example
     * // Update one Skins
     * const skins = await prisma.skins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinsUpdateArgs>(
      args: SelectSubset<T, skinsUpdateArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Delete zero or more Skins.
     * @param {skinsDeleteManyArgs} args - Arguments to filter Skins to delete.
     * @example
     * // Delete a few Skins
     * const { count } = await prisma.skins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinsDeleteManyArgs>(
      args?: SelectSubset<T, skinsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skins
     * const skins = await prisma.skins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinsUpdateManyArgs>(
      args: SelectSubset<T, skinsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Skins.
     * @param {skinsUpsertArgs} args - Arguments to update or create a Skins.
     * @example
     * // Update or create a Skins
     * const skins = await prisma.skins.upsert({
     *   create: {
     *     // ... data to create a Skins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skins we want to update
     *   }
     * })
    **/
    upsert<T extends skinsUpsertArgs>(
      args: SelectSubset<T, skinsUpsertArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Find one Skins that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {skinsFindUniqueOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skinsFindUniqueOrThrowArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Find the first Skins that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindFirstOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skinsFindFirstOrThrowArgs>
    ): Prisma__skinsClient<skinsGetPayload<T>>

    /**
     * Count the number of Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsCountArgs} args - Arguments to filter Skins to count.
     * @example
     * // Count the number of Skins
     * const count = await prisma.skins.count({
     *   where: {
     *     // ... the filter for the Skins we want to count
     *   }
     * })
    **/
    count<T extends skinsCountArgs>(
      args?: Subset<T, skinsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinsAggregateArgs>(args: Subset<T, SkinsAggregateArgs>): PrismaPromise<GetSkinsAggregateType<T>>

    /**
     * Group by Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkinsGroupByArgs['orderBy'] }
        : { orderBy?: SkinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skinsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skins base type for findUnique actions
   */
  export type skinsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * Filter, which skins to fetch.
     * 
    **/
    where: skinsWhereUniqueInput
  }

  /**
   * skins: findUnique
   */
  export interface skinsFindUniqueArgs extends skinsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skins base type for findFirst actions
   */
  export type skinsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * Filter, which skins to fetch.
     * 
    **/
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     * 
    **/
    orderBy?: Enumerable<skinsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skins.
     * 
    **/
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skins.
     * 
    **/
    distinct?: Enumerable<SkinsScalarFieldEnum>
  }

  /**
   * skins: findFirst
   */
  export interface skinsFindFirstArgs extends skinsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skins findMany
   */
  export type skinsFindManyArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * Filter, which skins to fetch.
     * 
    **/
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     * 
    **/
    orderBy?: Enumerable<skinsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skins.
     * 
    **/
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SkinsScalarFieldEnum>
  }


  /**
   * skins create
   */
  export type skinsCreateArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * The data needed to create a skins.
     * 
    **/
    data: XOR<skinsCreateInput, skinsUncheckedCreateInput>
  }


  /**
   * skins createMany
   */
  export type skinsCreateManyArgs = {
    /**
     * The data used to create many skins.
     * 
    **/
    data: Enumerable<skinsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skins update
   */
  export type skinsUpdateArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * The data needed to update a skins.
     * 
    **/
    data: XOR<skinsUpdateInput, skinsUncheckedUpdateInput>
    /**
     * Choose, which skins to update.
     * 
    **/
    where: skinsWhereUniqueInput
  }


  /**
   * skins updateMany
   */
  export type skinsUpdateManyArgs = {
    /**
     * The data used to update skins.
     * 
    **/
    data: XOR<skinsUpdateManyMutationInput, skinsUncheckedUpdateManyInput>
    /**
     * Filter which skins to update
     * 
    **/
    where?: skinsWhereInput
  }


  /**
   * skins upsert
   */
  export type skinsUpsertArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * The filter to search for the skins to update in case it exists.
     * 
    **/
    where: skinsWhereUniqueInput
    /**
     * In case the skins found by the `where` argument doesn't exist, create a new skins with this data.
     * 
    **/
    create: XOR<skinsCreateInput, skinsUncheckedCreateInput>
    /**
     * In case the skins was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<skinsUpdateInput, skinsUncheckedUpdateInput>
  }


  /**
   * skins delete
   */
  export type skinsDeleteArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
    /**
     * Filter which skins to delete.
     * 
    **/
    where: skinsWhereUniqueInput
  }


  /**
   * skins deleteMany
   */
  export type skinsDeleteManyArgs = {
    /**
     * Filter which skins to delete
     * 
    **/
    where?: skinsWhereInput
  }


  /**
   * skins: findUniqueOrThrow
   */
  export type skinsFindUniqueOrThrowArgs = skinsFindUniqueArgsBase
      

  /**
   * skins: findFirstOrThrow
   */
  export type skinsFindFirstOrThrowArgs = skinsFindFirstArgsBase
      

  /**
   * skins without action
   */
  export type skinsArgs = {
    /**
     * Select specific fields to fetch from the skins
     * 
    **/
    select?: skinsSelect | null
  }



  /**
   * Model staOperationServices
   */


  export type AggregateStaOperationServices = {
    _count: StaOperationServicesCountAggregateOutputType | null
    _avg: StaOperationServicesAvgAggregateOutputType | null
    _sum: StaOperationServicesSumAggregateOutputType | null
    _min: StaOperationServicesMinAggregateOutputType | null
    _max: StaOperationServicesMaxAggregateOutputType | null
  }

  export type StaOperationServicesAvgAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesSumAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesMinAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesMaxAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesCountAggregateOutputType = {
    operationID: number
    serviceID: number
    _all: number
  }


  export type StaOperationServicesAvgAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesSumAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesMinAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesMaxAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesCountAggregateInputType = {
    operationID?: true
    serviceID?: true
    _all?: true
  }

  export type StaOperationServicesAggregateArgs = {
    /**
     * Filter which staOperationServices to aggregate.
     * 
    **/
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staOperationServices
    **/
    _count?: true | StaOperationServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaOperationServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaOperationServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaOperationServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaOperationServicesMaxAggregateInputType
  }

  export type GetStaOperationServicesAggregateType<T extends StaOperationServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaOperationServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaOperationServices[P]>
      : GetScalarType<T[P], AggregateStaOperationServices[P]>
  }




  export type StaOperationServicesGroupByArgs = {
    where?: staOperationServicesWhereInput
    orderBy?: Enumerable<staOperationServicesOrderByWithAggregationInput>
    by: Array<StaOperationServicesScalarFieldEnum>
    having?: staOperationServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaOperationServicesCountAggregateInputType | true
    _avg?: StaOperationServicesAvgAggregateInputType
    _sum?: StaOperationServicesSumAggregateInputType
    _min?: StaOperationServicesMinAggregateInputType
    _max?: StaOperationServicesMaxAggregateInputType
  }


  export type StaOperationServicesGroupByOutputType = {
    operationID: number
    serviceID: number
    _count: StaOperationServicesCountAggregateOutputType | null
    _avg: StaOperationServicesAvgAggregateOutputType | null
    _sum: StaOperationServicesSumAggregateOutputType | null
    _min: StaOperationServicesMinAggregateOutputType | null
    _max: StaOperationServicesMaxAggregateOutputType | null
  }

  type GetStaOperationServicesGroupByPayload<T extends StaOperationServicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaOperationServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaOperationServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaOperationServicesGroupByOutputType[P]>
            : GetScalarType<T[P], StaOperationServicesGroupByOutputType[P]>
        }
      >
    >


  export type staOperationServicesSelect = {
    operationID?: boolean
    serviceID?: boolean
  }


  export type staOperationServicesGetPayload<S extends boolean | null | undefined | staOperationServicesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? staOperationServices :
    S extends undefined ? never :
    S extends { include: any } & (staOperationServicesArgs | staOperationServicesFindManyArgs)
    ? staOperationServices 
    : S extends { select: any } & (staOperationServicesArgs | staOperationServicesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staOperationServices ? staOperationServices[P] : never
  } 
      : staOperationServices


  type staOperationServicesCountArgs = Merge<
    Omit<staOperationServicesFindManyArgs, 'select' | 'include'> & {
      select?: StaOperationServicesCountAggregateInputType | true
    }
  >

  export interface staOperationServicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StaOperationServices that matches the filter.
     * @param {staOperationServicesFindUniqueArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staOperationServicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staOperationServicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staOperationServices'> extends True ? Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>> : Prisma__staOperationServicesClient<staOperationServicesGetPayload<T> | null, null>

    /**
     * Find the first StaOperationServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindFirstArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staOperationServicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staOperationServicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staOperationServices'> extends True ? Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>> : Prisma__staOperationServicesClient<staOperationServicesGetPayload<T> | null, null>

    /**
     * Find zero or more StaOperationServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findMany()
     * 
     * // Get first 10 StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findMany({ take: 10 })
     * 
     * // Only select the `operationID`
     * const staOperationServicesWithOperationIDOnly = await prisma.staOperationServices.findMany({ select: { operationID: true } })
     * 
    **/
    findMany<T extends staOperationServicesFindManyArgs>(
      args?: SelectSubset<T, staOperationServicesFindManyArgs>
    ): PrismaPromise<Array<staOperationServicesGetPayload<T>>>

    /**
     * Create a StaOperationServices.
     * @param {staOperationServicesCreateArgs} args - Arguments to create a StaOperationServices.
     * @example
     * // Create one StaOperationServices
     * const StaOperationServices = await prisma.staOperationServices.create({
     *   data: {
     *     // ... data to create a StaOperationServices
     *   }
     * })
     * 
    **/
    create<T extends staOperationServicesCreateArgs>(
      args: SelectSubset<T, staOperationServicesCreateArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Create many StaOperationServices.
     *     @param {staOperationServicesCreateManyArgs} args - Arguments to create many StaOperationServices.
     *     @example
     *     // Create many StaOperationServices
     *     const staOperationServices = await prisma.staOperationServices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staOperationServicesCreateManyArgs>(
      args?: SelectSubset<T, staOperationServicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StaOperationServices.
     * @param {staOperationServicesDeleteArgs} args - Arguments to delete one StaOperationServices.
     * @example
     * // Delete one StaOperationServices
     * const StaOperationServices = await prisma.staOperationServices.delete({
     *   where: {
     *     // ... filter to delete one StaOperationServices
     *   }
     * })
     * 
    **/
    delete<T extends staOperationServicesDeleteArgs>(
      args: SelectSubset<T, staOperationServicesDeleteArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Update one StaOperationServices.
     * @param {staOperationServicesUpdateArgs} args - Arguments to update one StaOperationServices.
     * @example
     * // Update one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staOperationServicesUpdateArgs>(
      args: SelectSubset<T, staOperationServicesUpdateArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Delete zero or more StaOperationServices.
     * @param {staOperationServicesDeleteManyArgs} args - Arguments to filter StaOperationServices to delete.
     * @example
     * // Delete a few StaOperationServices
     * const { count } = await prisma.staOperationServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staOperationServicesDeleteManyArgs>(
      args?: SelectSubset<T, staOperationServicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staOperationServicesUpdateManyArgs>(
      args: SelectSubset<T, staOperationServicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StaOperationServices.
     * @param {staOperationServicesUpsertArgs} args - Arguments to update or create a StaOperationServices.
     * @example
     * // Update or create a StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.upsert({
     *   create: {
     *     // ... data to create a StaOperationServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaOperationServices we want to update
     *   }
     * })
    **/
    upsert<T extends staOperationServicesUpsertArgs>(
      args: SelectSubset<T, staOperationServicesUpsertArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Find one StaOperationServices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staOperationServicesFindUniqueOrThrowArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staOperationServicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staOperationServicesFindUniqueOrThrowArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Find the first StaOperationServices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindFirstOrThrowArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staOperationServicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staOperationServicesFindFirstOrThrowArgs>
    ): Prisma__staOperationServicesClient<staOperationServicesGetPayload<T>>

    /**
     * Count the number of StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesCountArgs} args - Arguments to filter StaOperationServices to count.
     * @example
     * // Count the number of StaOperationServices
     * const count = await prisma.staOperationServices.count({
     *   where: {
     *     // ... the filter for the StaOperationServices we want to count
     *   }
     * })
    **/
    count<T extends staOperationServicesCountArgs>(
      args?: Subset<T, staOperationServicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaOperationServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaOperationServicesAggregateArgs>(args: Subset<T, StaOperationServicesAggregateArgs>): PrismaPromise<GetStaOperationServicesAggregateType<T>>

    /**
     * Group by StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaOperationServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaOperationServicesGroupByArgs['orderBy'] }
        : { orderBy?: StaOperationServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaOperationServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaOperationServicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for staOperationServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staOperationServicesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * staOperationServices base type for findUnique actions
   */
  export type staOperationServicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * Filter, which staOperationServices to fetch.
     * 
    **/
    where: staOperationServicesWhereUniqueInput
  }

  /**
   * staOperationServices: findUnique
   */
  export interface staOperationServicesFindUniqueArgs extends staOperationServicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staOperationServices base type for findFirst actions
   */
  export type staOperationServicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * Filter, which staOperationServices to fetch.
     * 
    **/
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperationServices.
     * 
    **/
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperationServices.
     * 
    **/
    distinct?: Enumerable<StaOperationServicesScalarFieldEnum>
  }

  /**
   * staOperationServices: findFirst
   */
  export interface staOperationServicesFindFirstArgs extends staOperationServicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staOperationServices findMany
   */
  export type staOperationServicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * Filter, which staOperationServices to fetch.
     * 
    **/
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staOperationServices.
     * 
    **/
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaOperationServicesScalarFieldEnum>
  }


  /**
   * staOperationServices create
   */
  export type staOperationServicesCreateArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * The data needed to create a staOperationServices.
     * 
    **/
    data: XOR<staOperationServicesCreateInput, staOperationServicesUncheckedCreateInput>
  }


  /**
   * staOperationServices createMany
   */
  export type staOperationServicesCreateManyArgs = {
    /**
     * The data used to create many staOperationServices.
     * 
    **/
    data: Enumerable<staOperationServicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staOperationServices update
   */
  export type staOperationServicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * The data needed to update a staOperationServices.
     * 
    **/
    data: XOR<staOperationServicesUpdateInput, staOperationServicesUncheckedUpdateInput>
    /**
     * Choose, which staOperationServices to update.
     * 
    **/
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices updateMany
   */
  export type staOperationServicesUpdateManyArgs = {
    /**
     * The data used to update staOperationServices.
     * 
    **/
    data: XOR<staOperationServicesUpdateManyMutationInput, staOperationServicesUncheckedUpdateManyInput>
    /**
     * Filter which staOperationServices to update
     * 
    **/
    where?: staOperationServicesWhereInput
  }


  /**
   * staOperationServices upsert
   */
  export type staOperationServicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * The filter to search for the staOperationServices to update in case it exists.
     * 
    **/
    where: staOperationServicesWhereUniqueInput
    /**
     * In case the staOperationServices found by the `where` argument doesn't exist, create a new staOperationServices with this data.
     * 
    **/
    create: XOR<staOperationServicesCreateInput, staOperationServicesUncheckedCreateInput>
    /**
     * In case the staOperationServices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staOperationServicesUpdateInput, staOperationServicesUncheckedUpdateInput>
  }


  /**
   * staOperationServices delete
   */
  export type staOperationServicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
    /**
     * Filter which staOperationServices to delete.
     * 
    **/
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices deleteMany
   */
  export type staOperationServicesDeleteManyArgs = {
    /**
     * Filter which staOperationServices to delete
     * 
    **/
    where?: staOperationServicesWhereInput
  }


  /**
   * staOperationServices: findUniqueOrThrow
   */
  export type staOperationServicesFindUniqueOrThrowArgs = staOperationServicesFindUniqueArgsBase
      

  /**
   * staOperationServices: findFirstOrThrow
   */
  export type staOperationServicesFindFirstOrThrowArgs = staOperationServicesFindFirstArgsBase
      

  /**
   * staOperationServices without action
   */
  export type staOperationServicesArgs = {
    /**
     * Select specific fields to fetch from the staOperationServices
     * 
    **/
    select?: staOperationServicesSelect | null
  }



  /**
   * Model staOperations
   */


  export type AggregateStaOperations = {
    _count: StaOperationsCountAggregateOutputType | null
    _avg: StaOperationsAvgAggregateOutputType | null
    _sum: StaOperationsSumAggregateOutputType | null
    _min: StaOperationsMinAggregateOutputType | null
    _max: StaOperationsMaxAggregateOutputType | null
  }

  export type StaOperationsAvgAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsSumAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsMinAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsMaxAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsCountAggregateOutputType = {
    activityID: number
    operationID: number
    operationName: number
    description: number
    fringe: number
    corridor: number
    hub: number
    border: number
    ratio: number
    caldariStationTypeID: number
    minmatarStationTypeID: number
    amarrStationTypeID: number
    gallenteStationTypeID: number
    joveStationTypeID: number
    _all: number
  }


  export type StaOperationsAvgAggregateInputType = {
    activityID?: true
    operationID?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsSumAggregateInputType = {
    activityID?: true
    operationID?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsMinAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsMaxAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsCountAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
    _all?: true
  }

  export type StaOperationsAggregateArgs = {
    /**
     * Filter which staOperations to aggregate.
     * 
    **/
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staOperations
    **/
    _count?: true | StaOperationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaOperationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaOperationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaOperationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaOperationsMaxAggregateInputType
  }

  export type GetStaOperationsAggregateType<T extends StaOperationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStaOperations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaOperations[P]>
      : GetScalarType<T[P], AggregateStaOperations[P]>
  }




  export type StaOperationsGroupByArgs = {
    where?: staOperationsWhereInput
    orderBy?: Enumerable<staOperationsOrderByWithAggregationInput>
    by: Array<StaOperationsScalarFieldEnum>
    having?: staOperationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaOperationsCountAggregateInputType | true
    _avg?: StaOperationsAvgAggregateInputType
    _sum?: StaOperationsSumAggregateInputType
    _min?: StaOperationsMinAggregateInputType
    _max?: StaOperationsMaxAggregateInputType
  }


  export type StaOperationsGroupByOutputType = {
    activityID: number | null
    operationID: number
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
    _count: StaOperationsCountAggregateOutputType | null
    _avg: StaOperationsAvgAggregateOutputType | null
    _sum: StaOperationsSumAggregateOutputType | null
    _min: StaOperationsMinAggregateOutputType | null
    _max: StaOperationsMaxAggregateOutputType | null
  }

  type GetStaOperationsGroupByPayload<T extends StaOperationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaOperationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaOperationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaOperationsGroupByOutputType[P]>
            : GetScalarType<T[P], StaOperationsGroupByOutputType[P]>
        }
      >
    >


  export type staOperationsSelect = {
    activityID?: boolean
    operationID?: boolean
    operationName?: boolean
    description?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    ratio?: boolean
    caldariStationTypeID?: boolean
    minmatarStationTypeID?: boolean
    amarrStationTypeID?: boolean
    gallenteStationTypeID?: boolean
    joveStationTypeID?: boolean
  }


  export type staOperationsGetPayload<S extends boolean | null | undefined | staOperationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? staOperations :
    S extends undefined ? never :
    S extends { include: any } & (staOperationsArgs | staOperationsFindManyArgs)
    ? staOperations 
    : S extends { select: any } & (staOperationsArgs | staOperationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staOperations ? staOperations[P] : never
  } 
      : staOperations


  type staOperationsCountArgs = Merge<
    Omit<staOperationsFindManyArgs, 'select' | 'include'> & {
      select?: StaOperationsCountAggregateInputType | true
    }
  >

  export interface staOperationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StaOperations that matches the filter.
     * @param {staOperationsFindUniqueArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staOperationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staOperationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staOperations'> extends True ? Prisma__staOperationsClient<staOperationsGetPayload<T>> : Prisma__staOperationsClient<staOperationsGetPayload<T> | null, null>

    /**
     * Find the first StaOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindFirstArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staOperationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staOperationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staOperations'> extends True ? Prisma__staOperationsClient<staOperationsGetPayload<T>> : Prisma__staOperationsClient<staOperationsGetPayload<T> | null, null>

    /**
     * Find zero or more StaOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaOperations
     * const staOperations = await prisma.staOperations.findMany()
     * 
     * // Get first 10 StaOperations
     * const staOperations = await prisma.staOperations.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const staOperationsWithActivityIDOnly = await prisma.staOperations.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends staOperationsFindManyArgs>(
      args?: SelectSubset<T, staOperationsFindManyArgs>
    ): PrismaPromise<Array<staOperationsGetPayload<T>>>

    /**
     * Create a StaOperations.
     * @param {staOperationsCreateArgs} args - Arguments to create a StaOperations.
     * @example
     * // Create one StaOperations
     * const StaOperations = await prisma.staOperations.create({
     *   data: {
     *     // ... data to create a StaOperations
     *   }
     * })
     * 
    **/
    create<T extends staOperationsCreateArgs>(
      args: SelectSubset<T, staOperationsCreateArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Create many StaOperations.
     *     @param {staOperationsCreateManyArgs} args - Arguments to create many StaOperations.
     *     @example
     *     // Create many StaOperations
     *     const staOperations = await prisma.staOperations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staOperationsCreateManyArgs>(
      args?: SelectSubset<T, staOperationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StaOperations.
     * @param {staOperationsDeleteArgs} args - Arguments to delete one StaOperations.
     * @example
     * // Delete one StaOperations
     * const StaOperations = await prisma.staOperations.delete({
     *   where: {
     *     // ... filter to delete one StaOperations
     *   }
     * })
     * 
    **/
    delete<T extends staOperationsDeleteArgs>(
      args: SelectSubset<T, staOperationsDeleteArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Update one StaOperations.
     * @param {staOperationsUpdateArgs} args - Arguments to update one StaOperations.
     * @example
     * // Update one StaOperations
     * const staOperations = await prisma.staOperations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staOperationsUpdateArgs>(
      args: SelectSubset<T, staOperationsUpdateArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Delete zero or more StaOperations.
     * @param {staOperationsDeleteManyArgs} args - Arguments to filter StaOperations to delete.
     * @example
     * // Delete a few StaOperations
     * const { count } = await prisma.staOperations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staOperationsDeleteManyArgs>(
      args?: SelectSubset<T, staOperationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaOperations
     * const staOperations = await prisma.staOperations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staOperationsUpdateManyArgs>(
      args: SelectSubset<T, staOperationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StaOperations.
     * @param {staOperationsUpsertArgs} args - Arguments to update or create a StaOperations.
     * @example
     * // Update or create a StaOperations
     * const staOperations = await prisma.staOperations.upsert({
     *   create: {
     *     // ... data to create a StaOperations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaOperations we want to update
     *   }
     * })
    **/
    upsert<T extends staOperationsUpsertArgs>(
      args: SelectSubset<T, staOperationsUpsertArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Find one StaOperations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staOperationsFindUniqueOrThrowArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staOperationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staOperationsFindUniqueOrThrowArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Find the first StaOperations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindFirstOrThrowArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staOperationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staOperationsFindFirstOrThrowArgs>
    ): Prisma__staOperationsClient<staOperationsGetPayload<T>>

    /**
     * Count the number of StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsCountArgs} args - Arguments to filter StaOperations to count.
     * @example
     * // Count the number of StaOperations
     * const count = await prisma.staOperations.count({
     *   where: {
     *     // ... the filter for the StaOperations we want to count
     *   }
     * })
    **/
    count<T extends staOperationsCountArgs>(
      args?: Subset<T, staOperationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaOperationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaOperationsAggregateArgs>(args: Subset<T, StaOperationsAggregateArgs>): PrismaPromise<GetStaOperationsAggregateType<T>>

    /**
     * Group by StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaOperationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaOperationsGroupByArgs['orderBy'] }
        : { orderBy?: StaOperationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaOperationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaOperationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for staOperations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staOperationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * staOperations base type for findUnique actions
   */
  export type staOperationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * Filter, which staOperations to fetch.
     * 
    **/
    where: staOperationsWhereUniqueInput
  }

  /**
   * staOperations: findUnique
   */
  export interface staOperationsFindUniqueArgs extends staOperationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staOperations base type for findFirst actions
   */
  export type staOperationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * Filter, which staOperations to fetch.
     * 
    **/
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperations.
     * 
    **/
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperations.
     * 
    **/
    distinct?: Enumerable<StaOperationsScalarFieldEnum>
  }

  /**
   * staOperations: findFirst
   */
  export interface staOperationsFindFirstArgs extends staOperationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staOperations findMany
   */
  export type staOperationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * Filter, which staOperations to fetch.
     * 
    **/
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     * 
    **/
    orderBy?: Enumerable<staOperationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staOperations.
     * 
    **/
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaOperationsScalarFieldEnum>
  }


  /**
   * staOperations create
   */
  export type staOperationsCreateArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * The data needed to create a staOperations.
     * 
    **/
    data: XOR<staOperationsCreateInput, staOperationsUncheckedCreateInput>
  }


  /**
   * staOperations createMany
   */
  export type staOperationsCreateManyArgs = {
    /**
     * The data used to create many staOperations.
     * 
    **/
    data: Enumerable<staOperationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staOperations update
   */
  export type staOperationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * The data needed to update a staOperations.
     * 
    **/
    data: XOR<staOperationsUpdateInput, staOperationsUncheckedUpdateInput>
    /**
     * Choose, which staOperations to update.
     * 
    **/
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations updateMany
   */
  export type staOperationsUpdateManyArgs = {
    /**
     * The data used to update staOperations.
     * 
    **/
    data: XOR<staOperationsUpdateManyMutationInput, staOperationsUncheckedUpdateManyInput>
    /**
     * Filter which staOperations to update
     * 
    **/
    where?: staOperationsWhereInput
  }


  /**
   * staOperations upsert
   */
  export type staOperationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * The filter to search for the staOperations to update in case it exists.
     * 
    **/
    where: staOperationsWhereUniqueInput
    /**
     * In case the staOperations found by the `where` argument doesn't exist, create a new staOperations with this data.
     * 
    **/
    create: XOR<staOperationsCreateInput, staOperationsUncheckedCreateInput>
    /**
     * In case the staOperations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staOperationsUpdateInput, staOperationsUncheckedUpdateInput>
  }


  /**
   * staOperations delete
   */
  export type staOperationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
    /**
     * Filter which staOperations to delete.
     * 
    **/
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations deleteMany
   */
  export type staOperationsDeleteManyArgs = {
    /**
     * Filter which staOperations to delete
     * 
    **/
    where?: staOperationsWhereInput
  }


  /**
   * staOperations: findUniqueOrThrow
   */
  export type staOperationsFindUniqueOrThrowArgs = staOperationsFindUniqueArgsBase
      

  /**
   * staOperations: findFirstOrThrow
   */
  export type staOperationsFindFirstOrThrowArgs = staOperationsFindFirstArgsBase
      

  /**
   * staOperations without action
   */
  export type staOperationsArgs = {
    /**
     * Select specific fields to fetch from the staOperations
     * 
    **/
    select?: staOperationsSelect | null
  }



  /**
   * Model staServices
   */


  export type AggregateStaServices = {
    _count: StaServicesCountAggregateOutputType | null
    _avg: StaServicesAvgAggregateOutputType | null
    _sum: StaServicesSumAggregateOutputType | null
    _min: StaServicesMinAggregateOutputType | null
    _max: StaServicesMaxAggregateOutputType | null
  }

  export type StaServicesAvgAggregateOutputType = {
    serviceID: number | null
  }

  export type StaServicesSumAggregateOutputType = {
    serviceID: number | null
  }

  export type StaServicesMinAggregateOutputType = {
    serviceID: number | null
    serviceName: string | null
    description: string | null
  }

  export type StaServicesMaxAggregateOutputType = {
    serviceID: number | null
    serviceName: string | null
    description: string | null
  }

  export type StaServicesCountAggregateOutputType = {
    serviceID: number
    serviceName: number
    description: number
    _all: number
  }


  export type StaServicesAvgAggregateInputType = {
    serviceID?: true
  }

  export type StaServicesSumAggregateInputType = {
    serviceID?: true
  }

  export type StaServicesMinAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
  }

  export type StaServicesMaxAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
  }

  export type StaServicesCountAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
    _all?: true
  }

  export type StaServicesAggregateArgs = {
    /**
     * Filter which staServices to aggregate.
     * 
    **/
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staServices
    **/
    _count?: true | StaServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaServicesMaxAggregateInputType
  }

  export type GetStaServicesAggregateType<T extends StaServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaServices[P]>
      : GetScalarType<T[P], AggregateStaServices[P]>
  }




  export type StaServicesGroupByArgs = {
    where?: staServicesWhereInput
    orderBy?: Enumerable<staServicesOrderByWithAggregationInput>
    by: Array<StaServicesScalarFieldEnum>
    having?: staServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaServicesCountAggregateInputType | true
    _avg?: StaServicesAvgAggregateInputType
    _sum?: StaServicesSumAggregateInputType
    _min?: StaServicesMinAggregateInputType
    _max?: StaServicesMaxAggregateInputType
  }


  export type StaServicesGroupByOutputType = {
    serviceID: number
    serviceName: string | null
    description: string | null
    _count: StaServicesCountAggregateOutputType | null
    _avg: StaServicesAvgAggregateOutputType | null
    _sum: StaServicesSumAggregateOutputType | null
    _min: StaServicesMinAggregateOutputType | null
    _max: StaServicesMaxAggregateOutputType | null
  }

  type GetStaServicesGroupByPayload<T extends StaServicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaServicesGroupByOutputType[P]>
            : GetScalarType<T[P], StaServicesGroupByOutputType[P]>
        }
      >
    >


  export type staServicesSelect = {
    serviceID?: boolean
    serviceName?: boolean
    description?: boolean
  }


  export type staServicesGetPayload<S extends boolean | null | undefined | staServicesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? staServices :
    S extends undefined ? never :
    S extends { include: any } & (staServicesArgs | staServicesFindManyArgs)
    ? staServices 
    : S extends { select: any } & (staServicesArgs | staServicesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staServices ? staServices[P] : never
  } 
      : staServices


  type staServicesCountArgs = Merge<
    Omit<staServicesFindManyArgs, 'select' | 'include'> & {
      select?: StaServicesCountAggregateInputType | true
    }
  >

  export interface staServicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StaServices that matches the filter.
     * @param {staServicesFindUniqueArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staServicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staServicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staServices'> extends True ? Prisma__staServicesClient<staServicesGetPayload<T>> : Prisma__staServicesClient<staServicesGetPayload<T> | null, null>

    /**
     * Find the first StaServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindFirstArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staServicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staServicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staServices'> extends True ? Prisma__staServicesClient<staServicesGetPayload<T>> : Prisma__staServicesClient<staServicesGetPayload<T> | null, null>

    /**
     * Find zero or more StaServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaServices
     * const staServices = await prisma.staServices.findMany()
     * 
     * // Get first 10 StaServices
     * const staServices = await prisma.staServices.findMany({ take: 10 })
     * 
     * // Only select the `serviceID`
     * const staServicesWithServiceIDOnly = await prisma.staServices.findMany({ select: { serviceID: true } })
     * 
    **/
    findMany<T extends staServicesFindManyArgs>(
      args?: SelectSubset<T, staServicesFindManyArgs>
    ): PrismaPromise<Array<staServicesGetPayload<T>>>

    /**
     * Create a StaServices.
     * @param {staServicesCreateArgs} args - Arguments to create a StaServices.
     * @example
     * // Create one StaServices
     * const StaServices = await prisma.staServices.create({
     *   data: {
     *     // ... data to create a StaServices
     *   }
     * })
     * 
    **/
    create<T extends staServicesCreateArgs>(
      args: SelectSubset<T, staServicesCreateArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Create many StaServices.
     *     @param {staServicesCreateManyArgs} args - Arguments to create many StaServices.
     *     @example
     *     // Create many StaServices
     *     const staServices = await prisma.staServices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staServicesCreateManyArgs>(
      args?: SelectSubset<T, staServicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StaServices.
     * @param {staServicesDeleteArgs} args - Arguments to delete one StaServices.
     * @example
     * // Delete one StaServices
     * const StaServices = await prisma.staServices.delete({
     *   where: {
     *     // ... filter to delete one StaServices
     *   }
     * })
     * 
    **/
    delete<T extends staServicesDeleteArgs>(
      args: SelectSubset<T, staServicesDeleteArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Update one StaServices.
     * @param {staServicesUpdateArgs} args - Arguments to update one StaServices.
     * @example
     * // Update one StaServices
     * const staServices = await prisma.staServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staServicesUpdateArgs>(
      args: SelectSubset<T, staServicesUpdateArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Delete zero or more StaServices.
     * @param {staServicesDeleteManyArgs} args - Arguments to filter StaServices to delete.
     * @example
     * // Delete a few StaServices
     * const { count } = await prisma.staServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staServicesDeleteManyArgs>(
      args?: SelectSubset<T, staServicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaServices
     * const staServices = await prisma.staServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staServicesUpdateManyArgs>(
      args: SelectSubset<T, staServicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StaServices.
     * @param {staServicesUpsertArgs} args - Arguments to update or create a StaServices.
     * @example
     * // Update or create a StaServices
     * const staServices = await prisma.staServices.upsert({
     *   create: {
     *     // ... data to create a StaServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaServices we want to update
     *   }
     * })
    **/
    upsert<T extends staServicesUpsertArgs>(
      args: SelectSubset<T, staServicesUpsertArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Find one StaServices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staServicesFindUniqueOrThrowArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staServicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staServicesFindUniqueOrThrowArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Find the first StaServices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindFirstOrThrowArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staServicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staServicesFindFirstOrThrowArgs>
    ): Prisma__staServicesClient<staServicesGetPayload<T>>

    /**
     * Count the number of StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesCountArgs} args - Arguments to filter StaServices to count.
     * @example
     * // Count the number of StaServices
     * const count = await prisma.staServices.count({
     *   where: {
     *     // ... the filter for the StaServices we want to count
     *   }
     * })
    **/
    count<T extends staServicesCountArgs>(
      args?: Subset<T, staServicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaServicesAggregateArgs>(args: Subset<T, StaServicesAggregateArgs>): PrismaPromise<GetStaServicesAggregateType<T>>

    /**
     * Group by StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaServicesGroupByArgs['orderBy'] }
        : { orderBy?: StaServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaServicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for staServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staServicesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * staServices base type for findUnique actions
   */
  export type staServicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * Filter, which staServices to fetch.
     * 
    **/
    where: staServicesWhereUniqueInput
  }

  /**
   * staServices: findUnique
   */
  export interface staServicesFindUniqueArgs extends staServicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staServices base type for findFirst actions
   */
  export type staServicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * Filter, which staServices to fetch.
     * 
    **/
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staServices.
     * 
    **/
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staServices.
     * 
    **/
    distinct?: Enumerable<StaServicesScalarFieldEnum>
  }

  /**
   * staServices: findFirst
   */
  export interface staServicesFindFirstArgs extends staServicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staServices findMany
   */
  export type staServicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * Filter, which staServices to fetch.
     * 
    **/
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     * 
    **/
    orderBy?: Enumerable<staServicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staServices.
     * 
    **/
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaServicesScalarFieldEnum>
  }


  /**
   * staServices create
   */
  export type staServicesCreateArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * The data needed to create a staServices.
     * 
    **/
    data: XOR<staServicesCreateInput, staServicesUncheckedCreateInput>
  }


  /**
   * staServices createMany
   */
  export type staServicesCreateManyArgs = {
    /**
     * The data used to create many staServices.
     * 
    **/
    data: Enumerable<staServicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staServices update
   */
  export type staServicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * The data needed to update a staServices.
     * 
    **/
    data: XOR<staServicesUpdateInput, staServicesUncheckedUpdateInput>
    /**
     * Choose, which staServices to update.
     * 
    **/
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices updateMany
   */
  export type staServicesUpdateManyArgs = {
    /**
     * The data used to update staServices.
     * 
    **/
    data: XOR<staServicesUpdateManyMutationInput, staServicesUncheckedUpdateManyInput>
    /**
     * Filter which staServices to update
     * 
    **/
    where?: staServicesWhereInput
  }


  /**
   * staServices upsert
   */
  export type staServicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * The filter to search for the staServices to update in case it exists.
     * 
    **/
    where: staServicesWhereUniqueInput
    /**
     * In case the staServices found by the `where` argument doesn't exist, create a new staServices with this data.
     * 
    **/
    create: XOR<staServicesCreateInput, staServicesUncheckedCreateInput>
    /**
     * In case the staServices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staServicesUpdateInput, staServicesUncheckedUpdateInput>
  }


  /**
   * staServices delete
   */
  export type staServicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
    /**
     * Filter which staServices to delete.
     * 
    **/
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices deleteMany
   */
  export type staServicesDeleteManyArgs = {
    /**
     * Filter which staServices to delete
     * 
    **/
    where?: staServicesWhereInput
  }


  /**
   * staServices: findUniqueOrThrow
   */
  export type staServicesFindUniqueOrThrowArgs = staServicesFindUniqueArgsBase
      

  /**
   * staServices: findFirstOrThrow
   */
  export type staServicesFindFirstOrThrowArgs = staServicesFindFirstArgsBase
      

  /**
   * staServices without action
   */
  export type staServicesArgs = {
    /**
     * Select specific fields to fetch from the staServices
     * 
    **/
    select?: staServicesSelect | null
  }



  /**
   * Model staStationTypes
   */


  export type AggregateStaStationTypes = {
    _count: StaStationTypesCountAggregateOutputType | null
    _avg: StaStationTypesAvgAggregateOutputType | null
    _sum: StaStationTypesSumAggregateOutputType | null
    _min: StaStationTypesMinAggregateOutputType | null
    _max: StaStationTypesMaxAggregateOutputType | null
  }

  export type StaStationTypesAvgAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
  }

  export type StaStationTypesSumAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
  }

  export type StaStationTypesMinAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
  }

  export type StaStationTypesMaxAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
  }

  export type StaStationTypesCountAggregateOutputType = {
    stationTypeID: number
    dockEntryX: number
    dockEntryY: number
    dockEntryZ: number
    dockOrientationX: number
    dockOrientationY: number
    dockOrientationZ: number
    operationID: number
    officeSlots: number
    reprocessingEfficiency: number
    conquerable: number
    _all: number
  }


  export type StaStationTypesAvgAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
  }

  export type StaStationTypesSumAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
  }

  export type StaStationTypesMinAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
  }

  export type StaStationTypesMaxAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
  }

  export type StaStationTypesCountAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
    _all?: true
  }

  export type StaStationTypesAggregateArgs = {
    /**
     * Filter which staStationTypes to aggregate.
     * 
    **/
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staStationTypes
    **/
    _count?: true | StaStationTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaStationTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaStationTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaStationTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaStationTypesMaxAggregateInputType
  }

  export type GetStaStationTypesAggregateType<T extends StaStationTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaStationTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaStationTypes[P]>
      : GetScalarType<T[P], AggregateStaStationTypes[P]>
  }




  export type StaStationTypesGroupByArgs = {
    where?: staStationTypesWhereInput
    orderBy?: Enumerable<staStationTypesOrderByWithAggregationInput>
    by: Array<StaStationTypesScalarFieldEnum>
    having?: staStationTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaStationTypesCountAggregateInputType | true
    _avg?: StaStationTypesAvgAggregateInputType
    _sum?: StaStationTypesSumAggregateInputType
    _min?: StaStationTypesMinAggregateInputType
    _max?: StaStationTypesMaxAggregateInputType
  }


  export type StaStationTypesGroupByOutputType = {
    stationTypeID: number
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
    _count: StaStationTypesCountAggregateOutputType | null
    _avg: StaStationTypesAvgAggregateOutputType | null
    _sum: StaStationTypesSumAggregateOutputType | null
    _min: StaStationTypesMinAggregateOutputType | null
    _max: StaStationTypesMaxAggregateOutputType | null
  }

  type GetStaStationTypesGroupByPayload<T extends StaStationTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaStationTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaStationTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaStationTypesGroupByOutputType[P]>
            : GetScalarType<T[P], StaStationTypesGroupByOutputType[P]>
        }
      >
    >


  export type staStationTypesSelect = {
    stationTypeID?: boolean
    dockEntryX?: boolean
    dockEntryY?: boolean
    dockEntryZ?: boolean
    dockOrientationX?: boolean
    dockOrientationY?: boolean
    dockOrientationZ?: boolean
    operationID?: boolean
    officeSlots?: boolean
    reprocessingEfficiency?: boolean
    conquerable?: boolean
  }


  export type staStationTypesGetPayload<S extends boolean | null | undefined | staStationTypesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? staStationTypes :
    S extends undefined ? never :
    S extends { include: any } & (staStationTypesArgs | staStationTypesFindManyArgs)
    ? staStationTypes 
    : S extends { select: any } & (staStationTypesArgs | staStationTypesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staStationTypes ? staStationTypes[P] : never
  } 
      : staStationTypes


  type staStationTypesCountArgs = Merge<
    Omit<staStationTypesFindManyArgs, 'select' | 'include'> & {
      select?: StaStationTypesCountAggregateInputType | true
    }
  >

  export interface staStationTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StaStationTypes that matches the filter.
     * @param {staStationTypesFindUniqueArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staStationTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staStationTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staStationTypes'> extends True ? Prisma__staStationTypesClient<staStationTypesGetPayload<T>> : Prisma__staStationTypesClient<staStationTypesGetPayload<T> | null, null>

    /**
     * Find the first StaStationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindFirstArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staStationTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staStationTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staStationTypes'> extends True ? Prisma__staStationTypesClient<staStationTypesGetPayload<T>> : Prisma__staStationTypesClient<staStationTypesGetPayload<T> | null, null>

    /**
     * Find zero or more StaStationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findMany()
     * 
     * // Get first 10 StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findMany({ take: 10 })
     * 
     * // Only select the `stationTypeID`
     * const staStationTypesWithStationTypeIDOnly = await prisma.staStationTypes.findMany({ select: { stationTypeID: true } })
     * 
    **/
    findMany<T extends staStationTypesFindManyArgs>(
      args?: SelectSubset<T, staStationTypesFindManyArgs>
    ): PrismaPromise<Array<staStationTypesGetPayload<T>>>

    /**
     * Create a StaStationTypes.
     * @param {staStationTypesCreateArgs} args - Arguments to create a StaStationTypes.
     * @example
     * // Create one StaStationTypes
     * const StaStationTypes = await prisma.staStationTypes.create({
     *   data: {
     *     // ... data to create a StaStationTypes
     *   }
     * })
     * 
    **/
    create<T extends staStationTypesCreateArgs>(
      args: SelectSubset<T, staStationTypesCreateArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Create many StaStationTypes.
     *     @param {staStationTypesCreateManyArgs} args - Arguments to create many StaStationTypes.
     *     @example
     *     // Create many StaStationTypes
     *     const staStationTypes = await prisma.staStationTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staStationTypesCreateManyArgs>(
      args?: SelectSubset<T, staStationTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StaStationTypes.
     * @param {staStationTypesDeleteArgs} args - Arguments to delete one StaStationTypes.
     * @example
     * // Delete one StaStationTypes
     * const StaStationTypes = await prisma.staStationTypes.delete({
     *   where: {
     *     // ... filter to delete one StaStationTypes
     *   }
     * })
     * 
    **/
    delete<T extends staStationTypesDeleteArgs>(
      args: SelectSubset<T, staStationTypesDeleteArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Update one StaStationTypes.
     * @param {staStationTypesUpdateArgs} args - Arguments to update one StaStationTypes.
     * @example
     * // Update one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staStationTypesUpdateArgs>(
      args: SelectSubset<T, staStationTypesUpdateArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Delete zero or more StaStationTypes.
     * @param {staStationTypesDeleteManyArgs} args - Arguments to filter StaStationTypes to delete.
     * @example
     * // Delete a few StaStationTypes
     * const { count } = await prisma.staStationTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staStationTypesDeleteManyArgs>(
      args?: SelectSubset<T, staStationTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staStationTypesUpdateManyArgs>(
      args: SelectSubset<T, staStationTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StaStationTypes.
     * @param {staStationTypesUpsertArgs} args - Arguments to update or create a StaStationTypes.
     * @example
     * // Update or create a StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.upsert({
     *   create: {
     *     // ... data to create a StaStationTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaStationTypes we want to update
     *   }
     * })
    **/
    upsert<T extends staStationTypesUpsertArgs>(
      args: SelectSubset<T, staStationTypesUpsertArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Find one StaStationTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staStationTypesFindUniqueOrThrowArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staStationTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staStationTypesFindUniqueOrThrowArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Find the first StaStationTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindFirstOrThrowArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staStationTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staStationTypesFindFirstOrThrowArgs>
    ): Prisma__staStationTypesClient<staStationTypesGetPayload<T>>

    /**
     * Count the number of StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesCountArgs} args - Arguments to filter StaStationTypes to count.
     * @example
     * // Count the number of StaStationTypes
     * const count = await prisma.staStationTypes.count({
     *   where: {
     *     // ... the filter for the StaStationTypes we want to count
     *   }
     * })
    **/
    count<T extends staStationTypesCountArgs>(
      args?: Subset<T, staStationTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaStationTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaStationTypesAggregateArgs>(args: Subset<T, StaStationTypesAggregateArgs>): PrismaPromise<GetStaStationTypesAggregateType<T>>

    /**
     * Group by StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaStationTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaStationTypesGroupByArgs['orderBy'] }
        : { orderBy?: StaStationTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaStationTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaStationTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for staStationTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staStationTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * staStationTypes base type for findUnique actions
   */
  export type staStationTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * Filter, which staStationTypes to fetch.
     * 
    **/
    where: staStationTypesWhereUniqueInput
  }

  /**
   * staStationTypes: findUnique
   */
  export interface staStationTypesFindUniqueArgs extends staStationTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staStationTypes base type for findFirst actions
   */
  export type staStationTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * Filter, which staStationTypes to fetch.
     * 
    **/
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStationTypes.
     * 
    **/
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStationTypes.
     * 
    **/
    distinct?: Enumerable<StaStationTypesScalarFieldEnum>
  }

  /**
   * staStationTypes: findFirst
   */
  export interface staStationTypesFindFirstArgs extends staStationTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staStationTypes findMany
   */
  export type staStationTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * Filter, which staStationTypes to fetch.
     * 
    **/
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staStationTypes.
     * 
    **/
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaStationTypesScalarFieldEnum>
  }


  /**
   * staStationTypes create
   */
  export type staStationTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * The data needed to create a staStationTypes.
     * 
    **/
    data: XOR<staStationTypesCreateInput, staStationTypesUncheckedCreateInput>
  }


  /**
   * staStationTypes createMany
   */
  export type staStationTypesCreateManyArgs = {
    /**
     * The data used to create many staStationTypes.
     * 
    **/
    data: Enumerable<staStationTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staStationTypes update
   */
  export type staStationTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * The data needed to update a staStationTypes.
     * 
    **/
    data: XOR<staStationTypesUpdateInput, staStationTypesUncheckedUpdateInput>
    /**
     * Choose, which staStationTypes to update.
     * 
    **/
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes updateMany
   */
  export type staStationTypesUpdateManyArgs = {
    /**
     * The data used to update staStationTypes.
     * 
    **/
    data: XOR<staStationTypesUpdateManyMutationInput, staStationTypesUncheckedUpdateManyInput>
    /**
     * Filter which staStationTypes to update
     * 
    **/
    where?: staStationTypesWhereInput
  }


  /**
   * staStationTypes upsert
   */
  export type staStationTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * The filter to search for the staStationTypes to update in case it exists.
     * 
    **/
    where: staStationTypesWhereUniqueInput
    /**
     * In case the staStationTypes found by the `where` argument doesn't exist, create a new staStationTypes with this data.
     * 
    **/
    create: XOR<staStationTypesCreateInput, staStationTypesUncheckedCreateInput>
    /**
     * In case the staStationTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staStationTypesUpdateInput, staStationTypesUncheckedUpdateInput>
  }


  /**
   * staStationTypes delete
   */
  export type staStationTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
    /**
     * Filter which staStationTypes to delete.
     * 
    **/
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes deleteMany
   */
  export type staStationTypesDeleteManyArgs = {
    /**
     * Filter which staStationTypes to delete
     * 
    **/
    where?: staStationTypesWhereInput
  }


  /**
   * staStationTypes: findUniqueOrThrow
   */
  export type staStationTypesFindUniqueOrThrowArgs = staStationTypesFindUniqueArgsBase
      

  /**
   * staStationTypes: findFirstOrThrow
   */
  export type staStationTypesFindFirstOrThrowArgs = staStationTypesFindFirstArgsBase
      

  /**
   * staStationTypes without action
   */
  export type staStationTypesArgs = {
    /**
     * Select specific fields to fetch from the staStationTypes
     * 
    **/
    select?: staStationTypesSelect | null
  }



  /**
   * Model staStations
   */


  export type AggregateStaStations = {
    _count: StaStationsCountAggregateOutputType | null
    _avg: StaStationsAvgAggregateOutputType | null
    _sum: StaStationsSumAggregateOutputType | null
    _min: StaStationsMinAggregateOutputType | null
    _max: StaStationsMaxAggregateOutputType | null
  }

  export type StaStationsAvgAggregateOutputType = {
    stationID: number | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsSumAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsMinAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsMaxAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsCountAggregateOutputType = {
    stationID: number
    security: number
    dockingCostPerVolume: number
    maxShipVolumeDockable: number
    officeRentalCost: number
    operationID: number
    stationTypeID: number
    corporationID: number
    solarSystemID: number
    constellationID: number
    regionID: number
    stationName: number
    x: number
    y: number
    z: number
    reprocessingEfficiency: number
    reprocessingStationsTake: number
    reprocessingHangarFlag: number
    _all: number
  }


  export type StaStationsAvgAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsSumAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsMinAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsMaxAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsCountAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
    _all?: true
  }

  export type StaStationsAggregateArgs = {
    /**
     * Filter which staStations to aggregate.
     * 
    **/
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staStations
    **/
    _count?: true | StaStationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaStationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaStationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaStationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaStationsMaxAggregateInputType
  }

  export type GetStaStationsAggregateType<T extends StaStationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStaStations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaStations[P]>
      : GetScalarType<T[P], AggregateStaStations[P]>
  }




  export type StaStationsGroupByArgs = {
    where?: staStationsWhereInput
    orderBy?: Enumerable<staStationsOrderByWithAggregationInput>
    by: Array<StaStationsScalarFieldEnum>
    having?: staStationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaStationsCountAggregateInputType | true
    _avg?: StaStationsAvgAggregateInputType
    _sum?: StaStationsSumAggregateInputType
    _min?: StaStationsMinAggregateInputType
    _max?: StaStationsMaxAggregateInputType
  }


  export type StaStationsGroupByOutputType = {
    stationID: bigint
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
    _count: StaStationsCountAggregateOutputType | null
    _avg: StaStationsAvgAggregateOutputType | null
    _sum: StaStationsSumAggregateOutputType | null
    _min: StaStationsMinAggregateOutputType | null
    _max: StaStationsMaxAggregateOutputType | null
  }

  type GetStaStationsGroupByPayload<T extends StaStationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaStationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaStationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaStationsGroupByOutputType[P]>
            : GetScalarType<T[P], StaStationsGroupByOutputType[P]>
        }
      >
    >


  export type staStationsSelect = {
    stationID?: boolean
    security?: boolean
    dockingCostPerVolume?: boolean
    maxShipVolumeDockable?: boolean
    officeRentalCost?: boolean
    operationID?: boolean
    stationTypeID?: boolean
    corporationID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    stationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    reprocessingEfficiency?: boolean
    reprocessingStationsTake?: boolean
    reprocessingHangarFlag?: boolean
  }


  export type staStationsGetPayload<S extends boolean | null | undefined | staStationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? staStations :
    S extends undefined ? never :
    S extends { include: any } & (staStationsArgs | staStationsFindManyArgs)
    ? staStations 
    : S extends { select: any } & (staStationsArgs | staStationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staStations ? staStations[P] : never
  } 
      : staStations


  type staStationsCountArgs = Merge<
    Omit<staStationsFindManyArgs, 'select' | 'include'> & {
      select?: StaStationsCountAggregateInputType | true
    }
  >

  export interface staStationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StaStations that matches the filter.
     * @param {staStationsFindUniqueArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staStationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staStationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staStations'> extends True ? Prisma__staStationsClient<staStationsGetPayload<T>> : Prisma__staStationsClient<staStationsGetPayload<T> | null, null>

    /**
     * Find the first StaStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindFirstArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staStationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staStationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staStations'> extends True ? Prisma__staStationsClient<staStationsGetPayload<T>> : Prisma__staStationsClient<staStationsGetPayload<T> | null, null>

    /**
     * Find zero or more StaStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaStations
     * const staStations = await prisma.staStations.findMany()
     * 
     * // Get first 10 StaStations
     * const staStations = await prisma.staStations.findMany({ take: 10 })
     * 
     * // Only select the `stationID`
     * const staStationsWithStationIDOnly = await prisma.staStations.findMany({ select: { stationID: true } })
     * 
    **/
    findMany<T extends staStationsFindManyArgs>(
      args?: SelectSubset<T, staStationsFindManyArgs>
    ): PrismaPromise<Array<staStationsGetPayload<T>>>

    /**
     * Create a StaStations.
     * @param {staStationsCreateArgs} args - Arguments to create a StaStations.
     * @example
     * // Create one StaStations
     * const StaStations = await prisma.staStations.create({
     *   data: {
     *     // ... data to create a StaStations
     *   }
     * })
     * 
    **/
    create<T extends staStationsCreateArgs>(
      args: SelectSubset<T, staStationsCreateArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Create many StaStations.
     *     @param {staStationsCreateManyArgs} args - Arguments to create many StaStations.
     *     @example
     *     // Create many StaStations
     *     const staStations = await prisma.staStations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staStationsCreateManyArgs>(
      args?: SelectSubset<T, staStationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StaStations.
     * @param {staStationsDeleteArgs} args - Arguments to delete one StaStations.
     * @example
     * // Delete one StaStations
     * const StaStations = await prisma.staStations.delete({
     *   where: {
     *     // ... filter to delete one StaStations
     *   }
     * })
     * 
    **/
    delete<T extends staStationsDeleteArgs>(
      args: SelectSubset<T, staStationsDeleteArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Update one StaStations.
     * @param {staStationsUpdateArgs} args - Arguments to update one StaStations.
     * @example
     * // Update one StaStations
     * const staStations = await prisma.staStations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staStationsUpdateArgs>(
      args: SelectSubset<T, staStationsUpdateArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Delete zero or more StaStations.
     * @param {staStationsDeleteManyArgs} args - Arguments to filter StaStations to delete.
     * @example
     * // Delete a few StaStations
     * const { count } = await prisma.staStations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staStationsDeleteManyArgs>(
      args?: SelectSubset<T, staStationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaStations
     * const staStations = await prisma.staStations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staStationsUpdateManyArgs>(
      args: SelectSubset<T, staStationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StaStations.
     * @param {staStationsUpsertArgs} args - Arguments to update or create a StaStations.
     * @example
     * // Update or create a StaStations
     * const staStations = await prisma.staStations.upsert({
     *   create: {
     *     // ... data to create a StaStations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaStations we want to update
     *   }
     * })
    **/
    upsert<T extends staStationsUpsertArgs>(
      args: SelectSubset<T, staStationsUpsertArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Find one StaStations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staStationsFindUniqueOrThrowArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staStationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staStationsFindUniqueOrThrowArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Find the first StaStations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindFirstOrThrowArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staStationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staStationsFindFirstOrThrowArgs>
    ): Prisma__staStationsClient<staStationsGetPayload<T>>

    /**
     * Count the number of StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsCountArgs} args - Arguments to filter StaStations to count.
     * @example
     * // Count the number of StaStations
     * const count = await prisma.staStations.count({
     *   where: {
     *     // ... the filter for the StaStations we want to count
     *   }
     * })
    **/
    count<T extends staStationsCountArgs>(
      args?: Subset<T, staStationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaStationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaStationsAggregateArgs>(args: Subset<T, StaStationsAggregateArgs>): PrismaPromise<GetStaStationsAggregateType<T>>

    /**
     * Group by StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaStationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaStationsGroupByArgs['orderBy'] }
        : { orderBy?: StaStationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaStationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaStationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for staStations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staStationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * staStations base type for findUnique actions
   */
  export type staStationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * Filter, which staStations to fetch.
     * 
    **/
    where: staStationsWhereUniqueInput
  }

  /**
   * staStations: findUnique
   */
  export interface staStationsFindUniqueArgs extends staStationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staStations base type for findFirst actions
   */
  export type staStationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * Filter, which staStations to fetch.
     * 
    **/
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStations.
     * 
    **/
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStations.
     * 
    **/
    distinct?: Enumerable<StaStationsScalarFieldEnum>
  }

  /**
   * staStations: findFirst
   */
  export interface staStationsFindFirstArgs extends staStationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staStations findMany
   */
  export type staStationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * Filter, which staStations to fetch.
     * 
    **/
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     * 
    **/
    orderBy?: Enumerable<staStationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staStations.
     * 
    **/
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaStationsScalarFieldEnum>
  }


  /**
   * staStations create
   */
  export type staStationsCreateArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * The data needed to create a staStations.
     * 
    **/
    data: XOR<staStationsCreateInput, staStationsUncheckedCreateInput>
  }


  /**
   * staStations createMany
   */
  export type staStationsCreateManyArgs = {
    /**
     * The data used to create many staStations.
     * 
    **/
    data: Enumerable<staStationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staStations update
   */
  export type staStationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * The data needed to update a staStations.
     * 
    **/
    data: XOR<staStationsUpdateInput, staStationsUncheckedUpdateInput>
    /**
     * Choose, which staStations to update.
     * 
    **/
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations updateMany
   */
  export type staStationsUpdateManyArgs = {
    /**
     * The data used to update staStations.
     * 
    **/
    data: XOR<staStationsUpdateManyMutationInput, staStationsUncheckedUpdateManyInput>
    /**
     * Filter which staStations to update
     * 
    **/
    where?: staStationsWhereInput
  }


  /**
   * staStations upsert
   */
  export type staStationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * The filter to search for the staStations to update in case it exists.
     * 
    **/
    where: staStationsWhereUniqueInput
    /**
     * In case the staStations found by the `where` argument doesn't exist, create a new staStations with this data.
     * 
    **/
    create: XOR<staStationsCreateInput, staStationsUncheckedCreateInput>
    /**
     * In case the staStations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staStationsUpdateInput, staStationsUncheckedUpdateInput>
  }


  /**
   * staStations delete
   */
  export type staStationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
    /**
     * Filter which staStations to delete.
     * 
    **/
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations deleteMany
   */
  export type staStationsDeleteManyArgs = {
    /**
     * Filter which staStations to delete
     * 
    **/
    where?: staStationsWhereInput
  }


  /**
   * staStations: findUniqueOrThrow
   */
  export type staStationsFindUniqueOrThrowArgs = staStationsFindUniqueArgsBase
      

  /**
   * staStations: findFirstOrThrow
   */
  export type staStationsFindFirstOrThrowArgs = staStationsFindFirstArgsBase
      

  /**
   * staStations without action
   */
  export type staStationsArgs = {
    /**
     * Select specific fields to fetch from the staStations
     * 
    **/
    select?: staStationsSelect | null
  }



  /**
   * Model translationTables
   */


  export type AggregateTranslationTables = {
    _count: TranslationTablesCountAggregateOutputType | null
    _avg: TranslationTablesAvgAggregateOutputType | null
    _sum: TranslationTablesSumAggregateOutputType | null
    _min: TranslationTablesMinAggregateOutputType | null
    _max: TranslationTablesMaxAggregateOutputType | null
  }

  export type TranslationTablesAvgAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesSumAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesMinAggregateOutputType = {
    sourceTable: string | null
    destinationTable: string | null
    translatedKey: string | null
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesMaxAggregateOutputType = {
    sourceTable: string | null
    destinationTable: string | null
    translatedKey: string | null
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesCountAggregateOutputType = {
    sourceTable: number
    destinationTable: number
    translatedKey: number
    tcGroupID: number
    tcID: number
    _all: number
  }


  export type TranslationTablesAvgAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesSumAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesMinAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesMaxAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesCountAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
    _all?: true
  }

  export type TranslationTablesAggregateArgs = {
    /**
     * Filter which translationTables to aggregate.
     * 
    **/
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     * 
    **/
    orderBy?: Enumerable<translationTablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned translationTables
    **/
    _count?: true | TranslationTablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationTablesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationTablesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationTablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationTablesMaxAggregateInputType
  }

  export type GetTranslationTablesAggregateType<T extends TranslationTablesAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslationTables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslationTables[P]>
      : GetScalarType<T[P], AggregateTranslationTables[P]>
  }




  export type TranslationTablesGroupByArgs = {
    where?: translationTablesWhereInput
    orderBy?: Enumerable<translationTablesOrderByWithAggregationInput>
    by: Array<TranslationTablesScalarFieldEnum>
    having?: translationTablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationTablesCountAggregateInputType | true
    _avg?: TranslationTablesAvgAggregateInputType
    _sum?: TranslationTablesSumAggregateInputType
    _min?: TranslationTablesMinAggregateInputType
    _max?: TranslationTablesMaxAggregateInputType
  }


  export type TranslationTablesGroupByOutputType = {
    sourceTable: string
    destinationTable: string | null
    translatedKey: string
    tcGroupID: number | null
    tcID: number | null
    _count: TranslationTablesCountAggregateOutputType | null
    _avg: TranslationTablesAvgAggregateOutputType | null
    _sum: TranslationTablesSumAggregateOutputType | null
    _min: TranslationTablesMinAggregateOutputType | null
    _max: TranslationTablesMaxAggregateOutputType | null
  }

  type GetTranslationTablesGroupByPayload<T extends TranslationTablesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranslationTablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationTablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationTablesGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationTablesGroupByOutputType[P]>
        }
      >
    >


  export type translationTablesSelect = {
    sourceTable?: boolean
    destinationTable?: boolean
    translatedKey?: boolean
    tcGroupID?: boolean
    tcID?: boolean
  }


  export type translationTablesGetPayload<S extends boolean | null | undefined | translationTablesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? translationTables :
    S extends undefined ? never :
    S extends { include: any } & (translationTablesArgs | translationTablesFindManyArgs)
    ? translationTables 
    : S extends { select: any } & (translationTablesArgs | translationTablesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof translationTables ? translationTables[P] : never
  } 
      : translationTables


  type translationTablesCountArgs = Merge<
    Omit<translationTablesFindManyArgs, 'select' | 'include'> & {
      select?: TranslationTablesCountAggregateInputType | true
    }
  >

  export interface translationTablesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TranslationTables that matches the filter.
     * @param {translationTablesFindUniqueArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends translationTablesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, translationTablesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'translationTables'> extends True ? Prisma__translationTablesClient<translationTablesGetPayload<T>> : Prisma__translationTablesClient<translationTablesGetPayload<T> | null, null>

    /**
     * Find the first TranslationTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindFirstArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends translationTablesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, translationTablesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'translationTables'> extends True ? Prisma__translationTablesClient<translationTablesGetPayload<T>> : Prisma__translationTablesClient<translationTablesGetPayload<T> | null, null>

    /**
     * Find zero or more TranslationTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranslationTables
     * const translationTables = await prisma.translationTables.findMany()
     * 
     * // Get first 10 TranslationTables
     * const translationTables = await prisma.translationTables.findMany({ take: 10 })
     * 
     * // Only select the `sourceTable`
     * const translationTablesWithSourceTableOnly = await prisma.translationTables.findMany({ select: { sourceTable: true } })
     * 
    **/
    findMany<T extends translationTablesFindManyArgs>(
      args?: SelectSubset<T, translationTablesFindManyArgs>
    ): PrismaPromise<Array<translationTablesGetPayload<T>>>

    /**
     * Create a TranslationTables.
     * @param {translationTablesCreateArgs} args - Arguments to create a TranslationTables.
     * @example
     * // Create one TranslationTables
     * const TranslationTables = await prisma.translationTables.create({
     *   data: {
     *     // ... data to create a TranslationTables
     *   }
     * })
     * 
    **/
    create<T extends translationTablesCreateArgs>(
      args: SelectSubset<T, translationTablesCreateArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Create many TranslationTables.
     *     @param {translationTablesCreateManyArgs} args - Arguments to create many TranslationTables.
     *     @example
     *     // Create many TranslationTables
     *     const translationTables = await prisma.translationTables.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends translationTablesCreateManyArgs>(
      args?: SelectSubset<T, translationTablesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TranslationTables.
     * @param {translationTablesDeleteArgs} args - Arguments to delete one TranslationTables.
     * @example
     * // Delete one TranslationTables
     * const TranslationTables = await prisma.translationTables.delete({
     *   where: {
     *     // ... filter to delete one TranslationTables
     *   }
     * })
     * 
    **/
    delete<T extends translationTablesDeleteArgs>(
      args: SelectSubset<T, translationTablesDeleteArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Update one TranslationTables.
     * @param {translationTablesUpdateArgs} args - Arguments to update one TranslationTables.
     * @example
     * // Update one TranslationTables
     * const translationTables = await prisma.translationTables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends translationTablesUpdateArgs>(
      args: SelectSubset<T, translationTablesUpdateArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Delete zero or more TranslationTables.
     * @param {translationTablesDeleteManyArgs} args - Arguments to filter TranslationTables to delete.
     * @example
     * // Delete a few TranslationTables
     * const { count } = await prisma.translationTables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends translationTablesDeleteManyArgs>(
      args?: SelectSubset<T, translationTablesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranslationTables
     * const translationTables = await prisma.translationTables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends translationTablesUpdateManyArgs>(
      args: SelectSubset<T, translationTablesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TranslationTables.
     * @param {translationTablesUpsertArgs} args - Arguments to update or create a TranslationTables.
     * @example
     * // Update or create a TranslationTables
     * const translationTables = await prisma.translationTables.upsert({
     *   create: {
     *     // ... data to create a TranslationTables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranslationTables we want to update
     *   }
     * })
    **/
    upsert<T extends translationTablesUpsertArgs>(
      args: SelectSubset<T, translationTablesUpsertArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Find one TranslationTables that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {translationTablesFindUniqueOrThrowArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends translationTablesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, translationTablesFindUniqueOrThrowArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Find the first TranslationTables that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindFirstOrThrowArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends translationTablesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, translationTablesFindFirstOrThrowArgs>
    ): Prisma__translationTablesClient<translationTablesGetPayload<T>>

    /**
     * Count the number of TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesCountArgs} args - Arguments to filter TranslationTables to count.
     * @example
     * // Count the number of TranslationTables
     * const count = await prisma.translationTables.count({
     *   where: {
     *     // ... the filter for the TranslationTables we want to count
     *   }
     * })
    **/
    count<T extends translationTablesCountArgs>(
      args?: Subset<T, translationTablesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationTablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationTablesAggregateArgs>(args: Subset<T, TranslationTablesAggregateArgs>): PrismaPromise<GetTranslationTablesAggregateType<T>>

    /**
     * Group by TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationTablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationTablesGroupByArgs['orderBy'] }
        : { orderBy?: TranslationTablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationTablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationTablesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for translationTables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__translationTablesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * translationTables base type for findUnique actions
   */
  export type translationTablesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * Filter, which translationTables to fetch.
     * 
    **/
    where: translationTablesWhereUniqueInput
  }

  /**
   * translationTables: findUnique
   */
  export interface translationTablesFindUniqueArgs extends translationTablesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * translationTables base type for findFirst actions
   */
  export type translationTablesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * Filter, which translationTables to fetch.
     * 
    **/
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     * 
    **/
    orderBy?: Enumerable<translationTablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translationTables.
     * 
    **/
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translationTables.
     * 
    **/
    distinct?: Enumerable<TranslationTablesScalarFieldEnum>
  }

  /**
   * translationTables: findFirst
   */
  export interface translationTablesFindFirstArgs extends translationTablesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * translationTables findMany
   */
  export type translationTablesFindManyArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * Filter, which translationTables to fetch.
     * 
    **/
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     * 
    **/
    orderBy?: Enumerable<translationTablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing translationTables.
     * 
    **/
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TranslationTablesScalarFieldEnum>
  }


  /**
   * translationTables create
   */
  export type translationTablesCreateArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * The data needed to create a translationTables.
     * 
    **/
    data: XOR<translationTablesCreateInput, translationTablesUncheckedCreateInput>
  }


  /**
   * translationTables createMany
   */
  export type translationTablesCreateManyArgs = {
    /**
     * The data used to create many translationTables.
     * 
    **/
    data: Enumerable<translationTablesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * translationTables update
   */
  export type translationTablesUpdateArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * The data needed to update a translationTables.
     * 
    **/
    data: XOR<translationTablesUpdateInput, translationTablesUncheckedUpdateInput>
    /**
     * Choose, which translationTables to update.
     * 
    **/
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables updateMany
   */
  export type translationTablesUpdateManyArgs = {
    /**
     * The data used to update translationTables.
     * 
    **/
    data: XOR<translationTablesUpdateManyMutationInput, translationTablesUncheckedUpdateManyInput>
    /**
     * Filter which translationTables to update
     * 
    **/
    where?: translationTablesWhereInput
  }


  /**
   * translationTables upsert
   */
  export type translationTablesUpsertArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * The filter to search for the translationTables to update in case it exists.
     * 
    **/
    where: translationTablesWhereUniqueInput
    /**
     * In case the translationTables found by the `where` argument doesn't exist, create a new translationTables with this data.
     * 
    **/
    create: XOR<translationTablesCreateInput, translationTablesUncheckedCreateInput>
    /**
     * In case the translationTables was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<translationTablesUpdateInput, translationTablesUncheckedUpdateInput>
  }


  /**
   * translationTables delete
   */
  export type translationTablesDeleteArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
    /**
     * Filter which translationTables to delete.
     * 
    **/
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables deleteMany
   */
  export type translationTablesDeleteManyArgs = {
    /**
     * Filter which translationTables to delete
     * 
    **/
    where?: translationTablesWhereInput
  }


  /**
   * translationTables: findUniqueOrThrow
   */
  export type translationTablesFindUniqueOrThrowArgs = translationTablesFindUniqueArgsBase
      

  /**
   * translationTables: findFirstOrThrow
   */
  export type translationTablesFindFirstOrThrowArgs = translationTablesFindFirstArgsBase
      

  /**
   * translationTables without action
   */
  export type translationTablesArgs = {
    /**
     * Select specific fields to fetch from the translationTables
     * 
    **/
    select?: translationTablesSelect | null
  }



  /**
   * Model trnTranslationColumns
   */


  export type AggregateTrnTranslationColumns = {
    _count: TrnTranslationColumnsCountAggregateOutputType | null
    _avg: TrnTranslationColumnsAvgAggregateOutputType | null
    _sum: TrnTranslationColumnsSumAggregateOutputType | null
    _min: TrnTranslationColumnsMinAggregateOutputType | null
    _max: TrnTranslationColumnsMaxAggregateOutputType | null
  }

  export type TrnTranslationColumnsAvgAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TrnTranslationColumnsSumAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TrnTranslationColumnsMinAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
    tableName: string | null
    columnName: string | null
    masterID: string | null
  }

  export type TrnTranslationColumnsMaxAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
    tableName: string | null
    columnName: string | null
    masterID: string | null
  }

  export type TrnTranslationColumnsCountAggregateOutputType = {
    tcGroupID: number
    tcID: number
    tableName: number
    columnName: number
    masterID: number
    _all: number
  }


  export type TrnTranslationColumnsAvgAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TrnTranslationColumnsSumAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TrnTranslationColumnsMinAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
  }

  export type TrnTranslationColumnsMaxAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
  }

  export type TrnTranslationColumnsCountAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
    _all?: true
  }

  export type TrnTranslationColumnsAggregateArgs = {
    /**
     * Filter which trnTranslationColumns to aggregate.
     * 
    **/
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationColumnsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslationColumns
    **/
    _count?: true | TrnTranslationColumnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationColumnsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationColumnsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationColumnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationColumnsMaxAggregateInputType
  }

  export type GetTrnTranslationColumnsAggregateType<T extends TrnTranslationColumnsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslationColumns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslationColumns[P]>
      : GetScalarType<T[P], AggregateTrnTranslationColumns[P]>
  }




  export type TrnTranslationColumnsGroupByArgs = {
    where?: trnTranslationColumnsWhereInput
    orderBy?: Enumerable<trnTranslationColumnsOrderByWithAggregationInput>
    by: Array<TrnTranslationColumnsScalarFieldEnum>
    having?: trnTranslationColumnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationColumnsCountAggregateInputType | true
    _avg?: TrnTranslationColumnsAvgAggregateInputType
    _sum?: TrnTranslationColumnsSumAggregateInputType
    _min?: TrnTranslationColumnsMinAggregateInputType
    _max?: TrnTranslationColumnsMaxAggregateInputType
  }


  export type TrnTranslationColumnsGroupByOutputType = {
    tcGroupID: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID: string | null
    _count: TrnTranslationColumnsCountAggregateOutputType | null
    _avg: TrnTranslationColumnsAvgAggregateOutputType | null
    _sum: TrnTranslationColumnsSumAggregateOutputType | null
    _min: TrnTranslationColumnsMinAggregateOutputType | null
    _max: TrnTranslationColumnsMaxAggregateOutputType | null
  }

  type GetTrnTranslationColumnsGroupByPayload<T extends TrnTranslationColumnsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrnTranslationColumnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationColumnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationColumnsGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationColumnsGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationColumnsSelect = {
    tcGroupID?: boolean
    tcID?: boolean
    tableName?: boolean
    columnName?: boolean
    masterID?: boolean
  }


  export type trnTranslationColumnsGetPayload<S extends boolean | null | undefined | trnTranslationColumnsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? trnTranslationColumns :
    S extends undefined ? never :
    S extends { include: any } & (trnTranslationColumnsArgs | trnTranslationColumnsFindManyArgs)
    ? trnTranslationColumns 
    : S extends { select: any } & (trnTranslationColumnsArgs | trnTranslationColumnsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof trnTranslationColumns ? trnTranslationColumns[P] : never
  } 
      : trnTranslationColumns


  type trnTranslationColumnsCountArgs = Merge<
    Omit<trnTranslationColumnsFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationColumnsCountAggregateInputType | true
    }
  >

  export interface trnTranslationColumnsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TrnTranslationColumns that matches the filter.
     * @param {trnTranslationColumnsFindUniqueArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationColumnsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, trnTranslationColumnsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'trnTranslationColumns'> extends True ? Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>> : Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T> | null, null>

    /**
     * Find the first TrnTranslationColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindFirstArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationColumnsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, trnTranslationColumnsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'trnTranslationColumns'> extends True ? Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>> : Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T> | null, null>

    /**
     * Find zero or more TrnTranslationColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany()
     * 
     * // Get first 10 TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany({ take: 10 })
     * 
     * // Only select the `tcGroupID`
     * const trnTranslationColumnsWithTcGroupIDOnly = await prisma.trnTranslationColumns.findMany({ select: { tcGroupID: true } })
     * 
    **/
    findMany<T extends trnTranslationColumnsFindManyArgs>(
      args?: SelectSubset<T, trnTranslationColumnsFindManyArgs>
    ): PrismaPromise<Array<trnTranslationColumnsGetPayload<T>>>

    /**
     * Create a TrnTranslationColumns.
     * @param {trnTranslationColumnsCreateArgs} args - Arguments to create a TrnTranslationColumns.
     * @example
     * // Create one TrnTranslationColumns
     * const TrnTranslationColumns = await prisma.trnTranslationColumns.create({
     *   data: {
     *     // ... data to create a TrnTranslationColumns
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationColumnsCreateArgs>(
      args: SelectSubset<T, trnTranslationColumnsCreateArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Create many TrnTranslationColumns.
     *     @param {trnTranslationColumnsCreateManyArgs} args - Arguments to create many TrnTranslationColumns.
     *     @example
     *     // Create many TrnTranslationColumns
     *     const trnTranslationColumns = await prisma.trnTranslationColumns.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationColumnsCreateManyArgs>(
      args?: SelectSubset<T, trnTranslationColumnsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslationColumns.
     * @param {trnTranslationColumnsDeleteArgs} args - Arguments to delete one TrnTranslationColumns.
     * @example
     * // Delete one TrnTranslationColumns
     * const TrnTranslationColumns = await prisma.trnTranslationColumns.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslationColumns
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationColumnsDeleteArgs>(
      args: SelectSubset<T, trnTranslationColumnsDeleteArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Update one TrnTranslationColumns.
     * @param {trnTranslationColumnsUpdateArgs} args - Arguments to update one TrnTranslationColumns.
     * @example
     * // Update one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationColumnsUpdateArgs>(
      args: SelectSubset<T, trnTranslationColumnsUpdateArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Delete zero or more TrnTranslationColumns.
     * @param {trnTranslationColumnsDeleteManyArgs} args - Arguments to filter TrnTranslationColumns to delete.
     * @example
     * // Delete a few TrnTranslationColumns
     * const { count } = await prisma.trnTranslationColumns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationColumnsDeleteManyArgs>(
      args?: SelectSubset<T, trnTranslationColumnsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationColumnsUpdateManyArgs>(
      args: SelectSubset<T, trnTranslationColumnsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslationColumns.
     * @param {trnTranslationColumnsUpsertArgs} args - Arguments to update or create a TrnTranslationColumns.
     * @example
     * // Update or create a TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.upsert({
     *   create: {
     *     // ... data to create a TrnTranslationColumns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslationColumns we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationColumnsUpsertArgs>(
      args: SelectSubset<T, trnTranslationColumnsUpsertArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Find one TrnTranslationColumns that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {trnTranslationColumnsFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationColumnsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationColumnsFindUniqueOrThrowArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Find the first TrnTranslationColumns that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindFirstOrThrowArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationColumnsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationColumnsFindFirstOrThrowArgs>
    ): Prisma__trnTranslationColumnsClient<trnTranslationColumnsGetPayload<T>>

    /**
     * Count the number of TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsCountArgs} args - Arguments to filter TrnTranslationColumns to count.
     * @example
     * // Count the number of TrnTranslationColumns
     * const count = await prisma.trnTranslationColumns.count({
     *   where: {
     *     // ... the filter for the TrnTranslationColumns we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationColumnsCountArgs>(
      args?: Subset<T, trnTranslationColumnsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationColumnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationColumnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationColumnsAggregateArgs>(args: Subset<T, TrnTranslationColumnsAggregateArgs>): PrismaPromise<GetTrnTranslationColumnsAggregateType<T>>

    /**
     * Group by TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationColumnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrnTranslationColumnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrnTranslationColumnsGroupByArgs['orderBy'] }
        : { orderBy?: TrnTranslationColumnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrnTranslationColumnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationColumnsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslationColumns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__trnTranslationColumnsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * trnTranslationColumns base type for findUnique actions
   */
  export type trnTranslationColumnsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     * 
    **/
    where: trnTranslationColumnsWhereUniqueInput
  }

  /**
   * trnTranslationColumns: findUnique
   */
  export interface trnTranslationColumnsFindUniqueArgs extends trnTranslationColumnsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslationColumns base type for findFirst actions
   */
  export type trnTranslationColumnsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     * 
    **/
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationColumnsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationColumns.
     * 
    **/
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationColumns.
     * 
    **/
    distinct?: Enumerable<TrnTranslationColumnsScalarFieldEnum>
  }

  /**
   * trnTranslationColumns: findFirst
   */
  export interface trnTranslationColumnsFindFirstArgs extends trnTranslationColumnsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslationColumns findMany
   */
  export type trnTranslationColumnsFindManyArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     * 
    **/
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationColumnsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslationColumns.
     * 
    **/
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrnTranslationColumnsScalarFieldEnum>
  }


  /**
   * trnTranslationColumns create
   */
  export type trnTranslationColumnsCreateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * The data needed to create a trnTranslationColumns.
     * 
    **/
    data: XOR<trnTranslationColumnsCreateInput, trnTranslationColumnsUncheckedCreateInput>
  }


  /**
   * trnTranslationColumns createMany
   */
  export type trnTranslationColumnsCreateManyArgs = {
    /**
     * The data used to create many trnTranslationColumns.
     * 
    **/
    data: Enumerable<trnTranslationColumnsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * trnTranslationColumns update
   */
  export type trnTranslationColumnsUpdateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * The data needed to update a trnTranslationColumns.
     * 
    **/
    data: XOR<trnTranslationColumnsUpdateInput, trnTranslationColumnsUncheckedUpdateInput>
    /**
     * Choose, which trnTranslationColumns to update.
     * 
    **/
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns updateMany
   */
  export type trnTranslationColumnsUpdateManyArgs = {
    /**
     * The data used to update trnTranslationColumns.
     * 
    **/
    data: XOR<trnTranslationColumnsUpdateManyMutationInput, trnTranslationColumnsUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslationColumns to update
     * 
    **/
    where?: trnTranslationColumnsWhereInput
  }


  /**
   * trnTranslationColumns upsert
   */
  export type trnTranslationColumnsUpsertArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * The filter to search for the trnTranslationColumns to update in case it exists.
     * 
    **/
    where: trnTranslationColumnsWhereUniqueInput
    /**
     * In case the trnTranslationColumns found by the `where` argument doesn't exist, create a new trnTranslationColumns with this data.
     * 
    **/
    create: XOR<trnTranslationColumnsCreateInput, trnTranslationColumnsUncheckedCreateInput>
    /**
     * In case the trnTranslationColumns was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<trnTranslationColumnsUpdateInput, trnTranslationColumnsUncheckedUpdateInput>
  }


  /**
   * trnTranslationColumns delete
   */
  export type trnTranslationColumnsDeleteArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
    /**
     * Filter which trnTranslationColumns to delete.
     * 
    **/
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns deleteMany
   */
  export type trnTranslationColumnsDeleteManyArgs = {
    /**
     * Filter which trnTranslationColumns to delete
     * 
    **/
    where?: trnTranslationColumnsWhereInput
  }


  /**
   * trnTranslationColumns: findUniqueOrThrow
   */
  export type trnTranslationColumnsFindUniqueOrThrowArgs = trnTranslationColumnsFindUniqueArgsBase
      

  /**
   * trnTranslationColumns: findFirstOrThrow
   */
  export type trnTranslationColumnsFindFirstOrThrowArgs = trnTranslationColumnsFindFirstArgsBase
      

  /**
   * trnTranslationColumns without action
   */
  export type trnTranslationColumnsArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     * 
    **/
    select?: trnTranslationColumnsSelect | null
  }



  /**
   * Model trnTranslationLanguages
   */


  export type AggregateTrnTranslationLanguages = {
    _count: TrnTranslationLanguagesCountAggregateOutputType | null
    _avg: TrnTranslationLanguagesAvgAggregateOutputType | null
    _sum: TrnTranslationLanguagesSumAggregateOutputType | null
    _min: TrnTranslationLanguagesMinAggregateOutputType | null
    _max: TrnTranslationLanguagesMaxAggregateOutputType | null
  }

  export type TrnTranslationLanguagesAvgAggregateOutputType = {
    numericLanguageID: number | null
  }

  export type TrnTranslationLanguagesSumAggregateOutputType = {
    numericLanguageID: number | null
  }

  export type TrnTranslationLanguagesMinAggregateOutputType = {
    numericLanguageID: number | null
    languageID: string | null
    languageName: string | null
  }

  export type TrnTranslationLanguagesMaxAggregateOutputType = {
    numericLanguageID: number | null
    languageID: string | null
    languageName: string | null
  }

  export type TrnTranslationLanguagesCountAggregateOutputType = {
    numericLanguageID: number
    languageID: number
    languageName: number
    _all: number
  }


  export type TrnTranslationLanguagesAvgAggregateInputType = {
    numericLanguageID?: true
  }

  export type TrnTranslationLanguagesSumAggregateInputType = {
    numericLanguageID?: true
  }

  export type TrnTranslationLanguagesMinAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
  }

  export type TrnTranslationLanguagesMaxAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
  }

  export type TrnTranslationLanguagesCountAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
    _all?: true
  }

  export type TrnTranslationLanguagesAggregateArgs = {
    /**
     * Filter which trnTranslationLanguages to aggregate.
     * 
    **/
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationLanguagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslationLanguages
    **/
    _count?: true | TrnTranslationLanguagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationLanguagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationLanguagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationLanguagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationLanguagesMaxAggregateInputType
  }

  export type GetTrnTranslationLanguagesAggregateType<T extends TrnTranslationLanguagesAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslationLanguages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslationLanguages[P]>
      : GetScalarType<T[P], AggregateTrnTranslationLanguages[P]>
  }




  export type TrnTranslationLanguagesGroupByArgs = {
    where?: trnTranslationLanguagesWhereInput
    orderBy?: Enumerable<trnTranslationLanguagesOrderByWithAggregationInput>
    by: Array<TrnTranslationLanguagesScalarFieldEnum>
    having?: trnTranslationLanguagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationLanguagesCountAggregateInputType | true
    _avg?: TrnTranslationLanguagesAvgAggregateInputType
    _sum?: TrnTranslationLanguagesSumAggregateInputType
    _min?: TrnTranslationLanguagesMinAggregateInputType
    _max?: TrnTranslationLanguagesMaxAggregateInputType
  }


  export type TrnTranslationLanguagesGroupByOutputType = {
    numericLanguageID: number
    languageID: string | null
    languageName: string | null
    _count: TrnTranslationLanguagesCountAggregateOutputType | null
    _avg: TrnTranslationLanguagesAvgAggregateOutputType | null
    _sum: TrnTranslationLanguagesSumAggregateOutputType | null
    _min: TrnTranslationLanguagesMinAggregateOutputType | null
    _max: TrnTranslationLanguagesMaxAggregateOutputType | null
  }

  type GetTrnTranslationLanguagesGroupByPayload<T extends TrnTranslationLanguagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrnTranslationLanguagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationLanguagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationLanguagesGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationLanguagesGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationLanguagesSelect = {
    numericLanguageID?: boolean
    languageID?: boolean
    languageName?: boolean
  }


  export type trnTranslationLanguagesGetPayload<S extends boolean | null | undefined | trnTranslationLanguagesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? trnTranslationLanguages :
    S extends undefined ? never :
    S extends { include: any } & (trnTranslationLanguagesArgs | trnTranslationLanguagesFindManyArgs)
    ? trnTranslationLanguages 
    : S extends { select: any } & (trnTranslationLanguagesArgs | trnTranslationLanguagesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof trnTranslationLanguages ? trnTranslationLanguages[P] : never
  } 
      : trnTranslationLanguages


  type trnTranslationLanguagesCountArgs = Merge<
    Omit<trnTranslationLanguagesFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationLanguagesCountAggregateInputType | true
    }
  >

  export interface trnTranslationLanguagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TrnTranslationLanguages that matches the filter.
     * @param {trnTranslationLanguagesFindUniqueArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationLanguagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, trnTranslationLanguagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'trnTranslationLanguages'> extends True ? Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>> : Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T> | null, null>

    /**
     * Find the first TrnTranslationLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindFirstArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationLanguagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, trnTranslationLanguagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'trnTranslationLanguages'> extends True ? Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>> : Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T> | null, null>

    /**
     * Find zero or more TrnTranslationLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany()
     * 
     * // Get first 10 TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany({ take: 10 })
     * 
     * // Only select the `numericLanguageID`
     * const trnTranslationLanguagesWithNumericLanguageIDOnly = await prisma.trnTranslationLanguages.findMany({ select: { numericLanguageID: true } })
     * 
    **/
    findMany<T extends trnTranslationLanguagesFindManyArgs>(
      args?: SelectSubset<T, trnTranslationLanguagesFindManyArgs>
    ): PrismaPromise<Array<trnTranslationLanguagesGetPayload<T>>>

    /**
     * Create a TrnTranslationLanguages.
     * @param {trnTranslationLanguagesCreateArgs} args - Arguments to create a TrnTranslationLanguages.
     * @example
     * // Create one TrnTranslationLanguages
     * const TrnTranslationLanguages = await prisma.trnTranslationLanguages.create({
     *   data: {
     *     // ... data to create a TrnTranslationLanguages
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationLanguagesCreateArgs>(
      args: SelectSubset<T, trnTranslationLanguagesCreateArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Create many TrnTranslationLanguages.
     *     @param {trnTranslationLanguagesCreateManyArgs} args - Arguments to create many TrnTranslationLanguages.
     *     @example
     *     // Create many TrnTranslationLanguages
     *     const trnTranslationLanguages = await prisma.trnTranslationLanguages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationLanguagesCreateManyArgs>(
      args?: SelectSubset<T, trnTranslationLanguagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslationLanguages.
     * @param {trnTranslationLanguagesDeleteArgs} args - Arguments to delete one TrnTranslationLanguages.
     * @example
     * // Delete one TrnTranslationLanguages
     * const TrnTranslationLanguages = await prisma.trnTranslationLanguages.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslationLanguages
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationLanguagesDeleteArgs>(
      args: SelectSubset<T, trnTranslationLanguagesDeleteArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Update one TrnTranslationLanguages.
     * @param {trnTranslationLanguagesUpdateArgs} args - Arguments to update one TrnTranslationLanguages.
     * @example
     * // Update one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationLanguagesUpdateArgs>(
      args: SelectSubset<T, trnTranslationLanguagesUpdateArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Delete zero or more TrnTranslationLanguages.
     * @param {trnTranslationLanguagesDeleteManyArgs} args - Arguments to filter TrnTranslationLanguages to delete.
     * @example
     * // Delete a few TrnTranslationLanguages
     * const { count } = await prisma.trnTranslationLanguages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationLanguagesDeleteManyArgs>(
      args?: SelectSubset<T, trnTranslationLanguagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationLanguagesUpdateManyArgs>(
      args: SelectSubset<T, trnTranslationLanguagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslationLanguages.
     * @param {trnTranslationLanguagesUpsertArgs} args - Arguments to update or create a TrnTranslationLanguages.
     * @example
     * // Update or create a TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.upsert({
     *   create: {
     *     // ... data to create a TrnTranslationLanguages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslationLanguages we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationLanguagesUpsertArgs>(
      args: SelectSubset<T, trnTranslationLanguagesUpsertArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Find one TrnTranslationLanguages that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {trnTranslationLanguagesFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationLanguagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationLanguagesFindUniqueOrThrowArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Find the first TrnTranslationLanguages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindFirstOrThrowArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationLanguagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationLanguagesFindFirstOrThrowArgs>
    ): Prisma__trnTranslationLanguagesClient<trnTranslationLanguagesGetPayload<T>>

    /**
     * Count the number of TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesCountArgs} args - Arguments to filter TrnTranslationLanguages to count.
     * @example
     * // Count the number of TrnTranslationLanguages
     * const count = await prisma.trnTranslationLanguages.count({
     *   where: {
     *     // ... the filter for the TrnTranslationLanguages we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationLanguagesCountArgs>(
      args?: Subset<T, trnTranslationLanguagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationLanguagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationLanguagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationLanguagesAggregateArgs>(args: Subset<T, TrnTranslationLanguagesAggregateArgs>): PrismaPromise<GetTrnTranslationLanguagesAggregateType<T>>

    /**
     * Group by TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationLanguagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrnTranslationLanguagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrnTranslationLanguagesGroupByArgs['orderBy'] }
        : { orderBy?: TrnTranslationLanguagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrnTranslationLanguagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationLanguagesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslationLanguages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__trnTranslationLanguagesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * trnTranslationLanguages base type for findUnique actions
   */
  export type trnTranslationLanguagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     * 
    **/
    where: trnTranslationLanguagesWhereUniqueInput
  }

  /**
   * trnTranslationLanguages: findUnique
   */
  export interface trnTranslationLanguagesFindUniqueArgs extends trnTranslationLanguagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslationLanguages base type for findFirst actions
   */
  export type trnTranslationLanguagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     * 
    **/
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationLanguagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationLanguages.
     * 
    **/
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationLanguages.
     * 
    **/
    distinct?: Enumerable<TrnTranslationLanguagesScalarFieldEnum>
  }

  /**
   * trnTranslationLanguages: findFirst
   */
  export interface trnTranslationLanguagesFindFirstArgs extends trnTranslationLanguagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslationLanguages findMany
   */
  export type trnTranslationLanguagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     * 
    **/
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationLanguagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslationLanguages.
     * 
    **/
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrnTranslationLanguagesScalarFieldEnum>
  }


  /**
   * trnTranslationLanguages create
   */
  export type trnTranslationLanguagesCreateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * The data needed to create a trnTranslationLanguages.
     * 
    **/
    data: XOR<trnTranslationLanguagesCreateInput, trnTranslationLanguagesUncheckedCreateInput>
  }


  /**
   * trnTranslationLanguages createMany
   */
  export type trnTranslationLanguagesCreateManyArgs = {
    /**
     * The data used to create many trnTranslationLanguages.
     * 
    **/
    data: Enumerable<trnTranslationLanguagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * trnTranslationLanguages update
   */
  export type trnTranslationLanguagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * The data needed to update a trnTranslationLanguages.
     * 
    **/
    data: XOR<trnTranslationLanguagesUpdateInput, trnTranslationLanguagesUncheckedUpdateInput>
    /**
     * Choose, which trnTranslationLanguages to update.
     * 
    **/
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages updateMany
   */
  export type trnTranslationLanguagesUpdateManyArgs = {
    /**
     * The data used to update trnTranslationLanguages.
     * 
    **/
    data: XOR<trnTranslationLanguagesUpdateManyMutationInput, trnTranslationLanguagesUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslationLanguages to update
     * 
    **/
    where?: trnTranslationLanguagesWhereInput
  }


  /**
   * trnTranslationLanguages upsert
   */
  export type trnTranslationLanguagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * The filter to search for the trnTranslationLanguages to update in case it exists.
     * 
    **/
    where: trnTranslationLanguagesWhereUniqueInput
    /**
     * In case the trnTranslationLanguages found by the `where` argument doesn't exist, create a new trnTranslationLanguages with this data.
     * 
    **/
    create: XOR<trnTranslationLanguagesCreateInput, trnTranslationLanguagesUncheckedCreateInput>
    /**
     * In case the trnTranslationLanguages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<trnTranslationLanguagesUpdateInput, trnTranslationLanguagesUncheckedUpdateInput>
  }


  /**
   * trnTranslationLanguages delete
   */
  export type trnTranslationLanguagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
    /**
     * Filter which trnTranslationLanguages to delete.
     * 
    **/
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages deleteMany
   */
  export type trnTranslationLanguagesDeleteManyArgs = {
    /**
     * Filter which trnTranslationLanguages to delete
     * 
    **/
    where?: trnTranslationLanguagesWhereInput
  }


  /**
   * trnTranslationLanguages: findUniqueOrThrow
   */
  export type trnTranslationLanguagesFindUniqueOrThrowArgs = trnTranslationLanguagesFindUniqueArgsBase
      

  /**
   * trnTranslationLanguages: findFirstOrThrow
   */
  export type trnTranslationLanguagesFindFirstOrThrowArgs = trnTranslationLanguagesFindFirstArgsBase
      

  /**
   * trnTranslationLanguages without action
   */
  export type trnTranslationLanguagesArgs = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     * 
    **/
    select?: trnTranslationLanguagesSelect | null
  }



  /**
   * Model trnTranslations
   */


  export type AggregateTrnTranslations = {
    _count: TrnTranslationsCountAggregateOutputType | null
    _avg: TrnTranslationsAvgAggregateOutputType | null
    _sum: TrnTranslationsSumAggregateOutputType | null
    _min: TrnTranslationsMinAggregateOutputType | null
    _max: TrnTranslationsMaxAggregateOutputType | null
  }

  export type TrnTranslationsAvgAggregateOutputType = {
    tcID: number | null
    keyID: number | null
  }

  export type TrnTranslationsSumAggregateOutputType = {
    tcID: number | null
    keyID: number | null
  }

  export type TrnTranslationsMinAggregateOutputType = {
    tcID: number | null
    keyID: number | null
    languageID: string | null
    text: string | null
  }

  export type TrnTranslationsMaxAggregateOutputType = {
    tcID: number | null
    keyID: number | null
    languageID: string | null
    text: string | null
  }

  export type TrnTranslationsCountAggregateOutputType = {
    tcID: number
    keyID: number
    languageID: number
    text: number
    _all: number
  }


  export type TrnTranslationsAvgAggregateInputType = {
    tcID?: true
    keyID?: true
  }

  export type TrnTranslationsSumAggregateInputType = {
    tcID?: true
    keyID?: true
  }

  export type TrnTranslationsMinAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
  }

  export type TrnTranslationsMaxAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
  }

  export type TrnTranslationsCountAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
    _all?: true
  }

  export type TrnTranslationsAggregateArgs = {
    /**
     * Filter which trnTranslations to aggregate.
     * 
    **/
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslations
    **/
    _count?: true | TrnTranslationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationsMaxAggregateInputType
  }

  export type GetTrnTranslationsAggregateType<T extends TrnTranslationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslations[P]>
      : GetScalarType<T[P], AggregateTrnTranslations[P]>
  }




  export type TrnTranslationsGroupByArgs = {
    where?: trnTranslationsWhereInput
    orderBy?: Enumerable<trnTranslationsOrderByWithAggregationInput>
    by: Array<TrnTranslationsScalarFieldEnum>
    having?: trnTranslationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationsCountAggregateInputType | true
    _avg?: TrnTranslationsAvgAggregateInputType
    _sum?: TrnTranslationsSumAggregateInputType
    _min?: TrnTranslationsMinAggregateInputType
    _max?: TrnTranslationsMaxAggregateInputType
  }


  export type TrnTranslationsGroupByOutputType = {
    tcID: number
    keyID: number
    languageID: string
    text: string
    _count: TrnTranslationsCountAggregateOutputType | null
    _avg: TrnTranslationsAvgAggregateOutputType | null
    _sum: TrnTranslationsSumAggregateOutputType | null
    _min: TrnTranslationsMinAggregateOutputType | null
    _max: TrnTranslationsMaxAggregateOutputType | null
  }

  type GetTrnTranslationsGroupByPayload<T extends TrnTranslationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrnTranslationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationsGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationsGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationsSelect = {
    tcID?: boolean
    keyID?: boolean
    languageID?: boolean
    text?: boolean
  }


  export type trnTranslationsGetPayload<S extends boolean | null | undefined | trnTranslationsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? trnTranslations :
    S extends undefined ? never :
    S extends { include: any } & (trnTranslationsArgs | trnTranslationsFindManyArgs)
    ? trnTranslations 
    : S extends { select: any } & (trnTranslationsArgs | trnTranslationsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof trnTranslations ? trnTranslations[P] : never
  } 
      : trnTranslations


  type trnTranslationsCountArgs = Merge<
    Omit<trnTranslationsFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationsCountAggregateInputType | true
    }
  >

  export interface trnTranslationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TrnTranslations that matches the filter.
     * @param {trnTranslationsFindUniqueArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, trnTranslationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'trnTranslations'> extends True ? Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>> : Prisma__trnTranslationsClient<trnTranslationsGetPayload<T> | null, null>

    /**
     * Find the first TrnTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindFirstArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, trnTranslationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'trnTranslations'> extends True ? Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>> : Prisma__trnTranslationsClient<trnTranslationsGetPayload<T> | null, null>

    /**
     * Find zero or more TrnTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findMany()
     * 
     * // Get first 10 TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findMany({ take: 10 })
     * 
     * // Only select the `tcID`
     * const trnTranslationsWithTcIDOnly = await prisma.trnTranslations.findMany({ select: { tcID: true } })
     * 
    **/
    findMany<T extends trnTranslationsFindManyArgs>(
      args?: SelectSubset<T, trnTranslationsFindManyArgs>
    ): PrismaPromise<Array<trnTranslationsGetPayload<T>>>

    /**
     * Create a TrnTranslations.
     * @param {trnTranslationsCreateArgs} args - Arguments to create a TrnTranslations.
     * @example
     * // Create one TrnTranslations
     * const TrnTranslations = await prisma.trnTranslations.create({
     *   data: {
     *     // ... data to create a TrnTranslations
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationsCreateArgs>(
      args: SelectSubset<T, trnTranslationsCreateArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Create many TrnTranslations.
     *     @param {trnTranslationsCreateManyArgs} args - Arguments to create many TrnTranslations.
     *     @example
     *     // Create many TrnTranslations
     *     const trnTranslations = await prisma.trnTranslations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationsCreateManyArgs>(
      args?: SelectSubset<T, trnTranslationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslations.
     * @param {trnTranslationsDeleteArgs} args - Arguments to delete one TrnTranslations.
     * @example
     * // Delete one TrnTranslations
     * const TrnTranslations = await prisma.trnTranslations.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslations
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationsDeleteArgs>(
      args: SelectSubset<T, trnTranslationsDeleteArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Update one TrnTranslations.
     * @param {trnTranslationsUpdateArgs} args - Arguments to update one TrnTranslations.
     * @example
     * // Update one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationsUpdateArgs>(
      args: SelectSubset<T, trnTranslationsUpdateArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Delete zero or more TrnTranslations.
     * @param {trnTranslationsDeleteManyArgs} args - Arguments to filter TrnTranslations to delete.
     * @example
     * // Delete a few TrnTranslations
     * const { count } = await prisma.trnTranslations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationsDeleteManyArgs>(
      args?: SelectSubset<T, trnTranslationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationsUpdateManyArgs>(
      args: SelectSubset<T, trnTranslationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslations.
     * @param {trnTranslationsUpsertArgs} args - Arguments to update or create a TrnTranslations.
     * @example
     * // Update or create a TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.upsert({
     *   create: {
     *     // ... data to create a TrnTranslations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslations we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationsUpsertArgs>(
      args: SelectSubset<T, trnTranslationsUpsertArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Find one TrnTranslations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {trnTranslationsFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationsFindUniqueOrThrowArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Find the first TrnTranslations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindFirstOrThrowArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, trnTranslationsFindFirstOrThrowArgs>
    ): Prisma__trnTranslationsClient<trnTranslationsGetPayload<T>>

    /**
     * Count the number of TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsCountArgs} args - Arguments to filter TrnTranslations to count.
     * @example
     * // Count the number of TrnTranslations
     * const count = await prisma.trnTranslations.count({
     *   where: {
     *     // ... the filter for the TrnTranslations we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationsCountArgs>(
      args?: Subset<T, trnTranslationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationsAggregateArgs>(args: Subset<T, TrnTranslationsAggregateArgs>): PrismaPromise<GetTrnTranslationsAggregateType<T>>

    /**
     * Group by TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrnTranslationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrnTranslationsGroupByArgs['orderBy'] }
        : { orderBy?: TrnTranslationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrnTranslationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__trnTranslationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * trnTranslations base type for findUnique actions
   */
  export type trnTranslationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * Filter, which trnTranslations to fetch.
     * 
    **/
    where: trnTranslationsWhereUniqueInput
  }

  /**
   * trnTranslations: findUnique
   */
  export interface trnTranslationsFindUniqueArgs extends trnTranslationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslations base type for findFirst actions
   */
  export type trnTranslationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * Filter, which trnTranslations to fetch.
     * 
    **/
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslations.
     * 
    **/
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslations.
     * 
    **/
    distinct?: Enumerable<TrnTranslationsScalarFieldEnum>
  }

  /**
   * trnTranslations: findFirst
   */
  export interface trnTranslationsFindFirstArgs extends trnTranslationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trnTranslations findMany
   */
  export type trnTranslationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * Filter, which trnTranslations to fetch.
     * 
    **/
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     * 
    **/
    orderBy?: Enumerable<trnTranslationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslations.
     * 
    **/
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrnTranslationsScalarFieldEnum>
  }


  /**
   * trnTranslations create
   */
  export type trnTranslationsCreateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * The data needed to create a trnTranslations.
     * 
    **/
    data: XOR<trnTranslationsCreateInput, trnTranslationsUncheckedCreateInput>
  }


  /**
   * trnTranslations createMany
   */
  export type trnTranslationsCreateManyArgs = {
    /**
     * The data used to create many trnTranslations.
     * 
    **/
    data: Enumerable<trnTranslationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * trnTranslations update
   */
  export type trnTranslationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * The data needed to update a trnTranslations.
     * 
    **/
    data: XOR<trnTranslationsUpdateInput, trnTranslationsUncheckedUpdateInput>
    /**
     * Choose, which trnTranslations to update.
     * 
    **/
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations updateMany
   */
  export type trnTranslationsUpdateManyArgs = {
    /**
     * The data used to update trnTranslations.
     * 
    **/
    data: XOR<trnTranslationsUpdateManyMutationInput, trnTranslationsUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslations to update
     * 
    **/
    where?: trnTranslationsWhereInput
  }


  /**
   * trnTranslations upsert
   */
  export type trnTranslationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * The filter to search for the trnTranslations to update in case it exists.
     * 
    **/
    where: trnTranslationsWhereUniqueInput
    /**
     * In case the trnTranslations found by the `where` argument doesn't exist, create a new trnTranslations with this data.
     * 
    **/
    create: XOR<trnTranslationsCreateInput, trnTranslationsUncheckedCreateInput>
    /**
     * In case the trnTranslations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<trnTranslationsUpdateInput, trnTranslationsUncheckedUpdateInput>
  }


  /**
   * trnTranslations delete
   */
  export type trnTranslationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
    /**
     * Filter which trnTranslations to delete.
     * 
    **/
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations deleteMany
   */
  export type trnTranslationsDeleteManyArgs = {
    /**
     * Filter which trnTranslations to delete
     * 
    **/
    where?: trnTranslationsWhereInput
  }


  /**
   * trnTranslations: findUniqueOrThrow
   */
  export type trnTranslationsFindUniqueOrThrowArgs = trnTranslationsFindUniqueArgsBase
      

  /**
   * trnTranslations: findFirstOrThrow
   */
  export type trnTranslationsFindFirstOrThrowArgs = trnTranslationsFindFirstArgsBase
      

  /**
   * trnTranslations without action
   */
  export type trnTranslationsArgs = {
    /**
     * Select specific fields to fetch from the trnTranslations
     * 
    **/
    select?: trnTranslationsSelect | null
  }



  /**
   * Model warCombatZoneSystems
   */


  export type AggregateWarCombatZoneSystems = {
    _count: WarCombatZoneSystemsCountAggregateOutputType | null
    _avg: WarCombatZoneSystemsAvgAggregateOutputType | null
    _sum: WarCombatZoneSystemsSumAggregateOutputType | null
    _min: WarCombatZoneSystemsMinAggregateOutputType | null
    _max: WarCombatZoneSystemsMaxAggregateOutputType | null
  }

  export type WarCombatZoneSystemsAvgAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsSumAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsMinAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsMaxAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsCountAggregateOutputType = {
    solarSystemID: number
    combatZoneID: number
    _all: number
  }


  export type WarCombatZoneSystemsAvgAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsSumAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsMinAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsMaxAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsCountAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
    _all?: true
  }

  export type WarCombatZoneSystemsAggregateArgs = {
    /**
     * Filter which warCombatZoneSystems to aggregate.
     * 
    **/
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZoneSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warCombatZoneSystems
    **/
    _count?: true | WarCombatZoneSystemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarCombatZoneSystemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarCombatZoneSystemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarCombatZoneSystemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarCombatZoneSystemsMaxAggregateInputType
  }

  export type GetWarCombatZoneSystemsAggregateType<T extends WarCombatZoneSystemsAggregateArgs> = {
        [P in keyof T & keyof AggregateWarCombatZoneSystems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarCombatZoneSystems[P]>
      : GetScalarType<T[P], AggregateWarCombatZoneSystems[P]>
  }




  export type WarCombatZoneSystemsGroupByArgs = {
    where?: warCombatZoneSystemsWhereInput
    orderBy?: Enumerable<warCombatZoneSystemsOrderByWithAggregationInput>
    by: Array<WarCombatZoneSystemsScalarFieldEnum>
    having?: warCombatZoneSystemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarCombatZoneSystemsCountAggregateInputType | true
    _avg?: WarCombatZoneSystemsAvgAggregateInputType
    _sum?: WarCombatZoneSystemsSumAggregateInputType
    _min?: WarCombatZoneSystemsMinAggregateInputType
    _max?: WarCombatZoneSystemsMaxAggregateInputType
  }


  export type WarCombatZoneSystemsGroupByOutputType = {
    solarSystemID: number
    combatZoneID: number | null
    _count: WarCombatZoneSystemsCountAggregateOutputType | null
    _avg: WarCombatZoneSystemsAvgAggregateOutputType | null
    _sum: WarCombatZoneSystemsSumAggregateOutputType | null
    _min: WarCombatZoneSystemsMinAggregateOutputType | null
    _max: WarCombatZoneSystemsMaxAggregateOutputType | null
  }

  type GetWarCombatZoneSystemsGroupByPayload<T extends WarCombatZoneSystemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WarCombatZoneSystemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarCombatZoneSystemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarCombatZoneSystemsGroupByOutputType[P]>
            : GetScalarType<T[P], WarCombatZoneSystemsGroupByOutputType[P]>
        }
      >
    >


  export type warCombatZoneSystemsSelect = {
    solarSystemID?: boolean
    combatZoneID?: boolean
  }


  export type warCombatZoneSystemsGetPayload<S extends boolean | null | undefined | warCombatZoneSystemsArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? warCombatZoneSystems :
    S extends undefined ? never :
    S extends { include: any } & (warCombatZoneSystemsArgs | warCombatZoneSystemsFindManyArgs)
    ? warCombatZoneSystems 
    : S extends { select: any } & (warCombatZoneSystemsArgs | warCombatZoneSystemsFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof warCombatZoneSystems ? warCombatZoneSystems[P] : never
  } 
      : warCombatZoneSystems


  type warCombatZoneSystemsCountArgs = Merge<
    Omit<warCombatZoneSystemsFindManyArgs, 'select' | 'include'> & {
      select?: WarCombatZoneSystemsCountAggregateInputType | true
    }
  >

  export interface warCombatZoneSystemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one WarCombatZoneSystems that matches the filter.
     * @param {warCombatZoneSystemsFindUniqueArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends warCombatZoneSystemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, warCombatZoneSystemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'warCombatZoneSystems'> extends True ? Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>> : Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T> | null, null>

    /**
     * Find the first WarCombatZoneSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindFirstArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends warCombatZoneSystemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, warCombatZoneSystemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'warCombatZoneSystems'> extends True ? Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>> : Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T> | null, null>

    /**
     * Find zero or more WarCombatZoneSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany()
     * 
     * // Get first 10 WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany({ take: 10 })
     * 
     * // Only select the `solarSystemID`
     * const warCombatZoneSystemsWithSolarSystemIDOnly = await prisma.warCombatZoneSystems.findMany({ select: { solarSystemID: true } })
     * 
    **/
    findMany<T extends warCombatZoneSystemsFindManyArgs>(
      args?: SelectSubset<T, warCombatZoneSystemsFindManyArgs>
    ): PrismaPromise<Array<warCombatZoneSystemsGetPayload<T>>>

    /**
     * Create a WarCombatZoneSystems.
     * @param {warCombatZoneSystemsCreateArgs} args - Arguments to create a WarCombatZoneSystems.
     * @example
     * // Create one WarCombatZoneSystems
     * const WarCombatZoneSystems = await prisma.warCombatZoneSystems.create({
     *   data: {
     *     // ... data to create a WarCombatZoneSystems
     *   }
     * })
     * 
    **/
    create<T extends warCombatZoneSystemsCreateArgs>(
      args: SelectSubset<T, warCombatZoneSystemsCreateArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Create many WarCombatZoneSystems.
     *     @param {warCombatZoneSystemsCreateManyArgs} args - Arguments to create many WarCombatZoneSystems.
     *     @example
     *     // Create many WarCombatZoneSystems
     *     const warCombatZoneSystems = await prisma.warCombatZoneSystems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends warCombatZoneSystemsCreateManyArgs>(
      args?: SelectSubset<T, warCombatZoneSystemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WarCombatZoneSystems.
     * @param {warCombatZoneSystemsDeleteArgs} args - Arguments to delete one WarCombatZoneSystems.
     * @example
     * // Delete one WarCombatZoneSystems
     * const WarCombatZoneSystems = await prisma.warCombatZoneSystems.delete({
     *   where: {
     *     // ... filter to delete one WarCombatZoneSystems
     *   }
     * })
     * 
    **/
    delete<T extends warCombatZoneSystemsDeleteArgs>(
      args: SelectSubset<T, warCombatZoneSystemsDeleteArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Update one WarCombatZoneSystems.
     * @param {warCombatZoneSystemsUpdateArgs} args - Arguments to update one WarCombatZoneSystems.
     * @example
     * // Update one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends warCombatZoneSystemsUpdateArgs>(
      args: SelectSubset<T, warCombatZoneSystemsUpdateArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Delete zero or more WarCombatZoneSystems.
     * @param {warCombatZoneSystemsDeleteManyArgs} args - Arguments to filter WarCombatZoneSystems to delete.
     * @example
     * // Delete a few WarCombatZoneSystems
     * const { count } = await prisma.warCombatZoneSystems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends warCombatZoneSystemsDeleteManyArgs>(
      args?: SelectSubset<T, warCombatZoneSystemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends warCombatZoneSystemsUpdateManyArgs>(
      args: SelectSubset<T, warCombatZoneSystemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WarCombatZoneSystems.
     * @param {warCombatZoneSystemsUpsertArgs} args - Arguments to update or create a WarCombatZoneSystems.
     * @example
     * // Update or create a WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.upsert({
     *   create: {
     *     // ... data to create a WarCombatZoneSystems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarCombatZoneSystems we want to update
     *   }
     * })
    **/
    upsert<T extends warCombatZoneSystemsUpsertArgs>(
      args: SelectSubset<T, warCombatZoneSystemsUpsertArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Find one WarCombatZoneSystems that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {warCombatZoneSystemsFindUniqueOrThrowArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends warCombatZoneSystemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, warCombatZoneSystemsFindUniqueOrThrowArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Find the first WarCombatZoneSystems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindFirstOrThrowArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends warCombatZoneSystemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, warCombatZoneSystemsFindFirstOrThrowArgs>
    ): Prisma__warCombatZoneSystemsClient<warCombatZoneSystemsGetPayload<T>>

    /**
     * Count the number of WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsCountArgs} args - Arguments to filter WarCombatZoneSystems to count.
     * @example
     * // Count the number of WarCombatZoneSystems
     * const count = await prisma.warCombatZoneSystems.count({
     *   where: {
     *     // ... the filter for the WarCombatZoneSystems we want to count
     *   }
     * })
    **/
    count<T extends warCombatZoneSystemsCountArgs>(
      args?: Subset<T, warCombatZoneSystemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarCombatZoneSystemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZoneSystemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarCombatZoneSystemsAggregateArgs>(args: Subset<T, WarCombatZoneSystemsAggregateArgs>): PrismaPromise<GetWarCombatZoneSystemsAggregateType<T>>

    /**
     * Group by WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZoneSystemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarCombatZoneSystemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarCombatZoneSystemsGroupByArgs['orderBy'] }
        : { orderBy?: WarCombatZoneSystemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarCombatZoneSystemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarCombatZoneSystemsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for warCombatZoneSystems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__warCombatZoneSystemsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * warCombatZoneSystems base type for findUnique actions
   */
  export type warCombatZoneSystemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     * 
    **/
    where: warCombatZoneSystemsWhereUniqueInput
  }

  /**
   * warCombatZoneSystems: findUnique
   */
  export interface warCombatZoneSystemsFindUniqueArgs extends warCombatZoneSystemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * warCombatZoneSystems base type for findFirst actions
   */
  export type warCombatZoneSystemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     * 
    **/
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZoneSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZoneSystems.
     * 
    **/
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZoneSystems.
     * 
    **/
    distinct?: Enumerable<WarCombatZoneSystemsScalarFieldEnum>
  }

  /**
   * warCombatZoneSystems: findFirst
   */
  export interface warCombatZoneSystemsFindFirstArgs extends warCombatZoneSystemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * warCombatZoneSystems findMany
   */
  export type warCombatZoneSystemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     * 
    **/
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZoneSystemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warCombatZoneSystems.
     * 
    **/
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WarCombatZoneSystemsScalarFieldEnum>
  }


  /**
   * warCombatZoneSystems create
   */
  export type warCombatZoneSystemsCreateArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * The data needed to create a warCombatZoneSystems.
     * 
    **/
    data: XOR<warCombatZoneSystemsCreateInput, warCombatZoneSystemsUncheckedCreateInput>
  }


  /**
   * warCombatZoneSystems createMany
   */
  export type warCombatZoneSystemsCreateManyArgs = {
    /**
     * The data used to create many warCombatZoneSystems.
     * 
    **/
    data: Enumerable<warCombatZoneSystemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * warCombatZoneSystems update
   */
  export type warCombatZoneSystemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * The data needed to update a warCombatZoneSystems.
     * 
    **/
    data: XOR<warCombatZoneSystemsUpdateInput, warCombatZoneSystemsUncheckedUpdateInput>
    /**
     * Choose, which warCombatZoneSystems to update.
     * 
    **/
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems updateMany
   */
  export type warCombatZoneSystemsUpdateManyArgs = {
    /**
     * The data used to update warCombatZoneSystems.
     * 
    **/
    data: XOR<warCombatZoneSystemsUpdateManyMutationInput, warCombatZoneSystemsUncheckedUpdateManyInput>
    /**
     * Filter which warCombatZoneSystems to update
     * 
    **/
    where?: warCombatZoneSystemsWhereInput
  }


  /**
   * warCombatZoneSystems upsert
   */
  export type warCombatZoneSystemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * The filter to search for the warCombatZoneSystems to update in case it exists.
     * 
    **/
    where: warCombatZoneSystemsWhereUniqueInput
    /**
     * In case the warCombatZoneSystems found by the `where` argument doesn't exist, create a new warCombatZoneSystems with this data.
     * 
    **/
    create: XOR<warCombatZoneSystemsCreateInput, warCombatZoneSystemsUncheckedCreateInput>
    /**
     * In case the warCombatZoneSystems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<warCombatZoneSystemsUpdateInput, warCombatZoneSystemsUncheckedUpdateInput>
  }


  /**
   * warCombatZoneSystems delete
   */
  export type warCombatZoneSystemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
    /**
     * Filter which warCombatZoneSystems to delete.
     * 
    **/
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems deleteMany
   */
  export type warCombatZoneSystemsDeleteManyArgs = {
    /**
     * Filter which warCombatZoneSystems to delete
     * 
    **/
    where?: warCombatZoneSystemsWhereInput
  }


  /**
   * warCombatZoneSystems: findUniqueOrThrow
   */
  export type warCombatZoneSystemsFindUniqueOrThrowArgs = warCombatZoneSystemsFindUniqueArgsBase
      

  /**
   * warCombatZoneSystems: findFirstOrThrow
   */
  export type warCombatZoneSystemsFindFirstOrThrowArgs = warCombatZoneSystemsFindFirstArgsBase
      

  /**
   * warCombatZoneSystems without action
   */
  export type warCombatZoneSystemsArgs = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     * 
    **/
    select?: warCombatZoneSystemsSelect | null
  }



  /**
   * Model warCombatZones
   */


  export type AggregateWarCombatZones = {
    _count: WarCombatZonesCountAggregateOutputType | null
    _avg: WarCombatZonesAvgAggregateOutputType | null
    _sum: WarCombatZonesSumAggregateOutputType | null
    _min: WarCombatZonesMinAggregateOutputType | null
    _max: WarCombatZonesMaxAggregateOutputType | null
  }

  export type WarCombatZonesAvgAggregateOutputType = {
    combatZoneID: number | null
    factionID: number | null
    centerSystemID: number | null
  }

  export type WarCombatZonesSumAggregateOutputType = {
    combatZoneID: number | null
    factionID: number | null
    centerSystemID: number | null
  }

  export type WarCombatZonesMinAggregateOutputType = {
    combatZoneID: number | null
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
  }

  export type WarCombatZonesMaxAggregateOutputType = {
    combatZoneID: number | null
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
  }

  export type WarCombatZonesCountAggregateOutputType = {
    combatZoneID: number
    combatZoneName: number
    factionID: number
    centerSystemID: number
    description: number
    _all: number
  }


  export type WarCombatZonesAvgAggregateInputType = {
    combatZoneID?: true
    factionID?: true
    centerSystemID?: true
  }

  export type WarCombatZonesSumAggregateInputType = {
    combatZoneID?: true
    factionID?: true
    centerSystemID?: true
  }

  export type WarCombatZonesMinAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
  }

  export type WarCombatZonesMaxAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
  }

  export type WarCombatZonesCountAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
    _all?: true
  }

  export type WarCombatZonesAggregateArgs = {
    /**
     * Filter which warCombatZones to aggregate.
     * 
    **/
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZonesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warCombatZones
    **/
    _count?: true | WarCombatZonesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarCombatZonesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarCombatZonesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarCombatZonesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarCombatZonesMaxAggregateInputType
  }

  export type GetWarCombatZonesAggregateType<T extends WarCombatZonesAggregateArgs> = {
        [P in keyof T & keyof AggregateWarCombatZones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarCombatZones[P]>
      : GetScalarType<T[P], AggregateWarCombatZones[P]>
  }




  export type WarCombatZonesGroupByArgs = {
    where?: warCombatZonesWhereInput
    orderBy?: Enumerable<warCombatZonesOrderByWithAggregationInput>
    by: Array<WarCombatZonesScalarFieldEnum>
    having?: warCombatZonesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarCombatZonesCountAggregateInputType | true
    _avg?: WarCombatZonesAvgAggregateInputType
    _sum?: WarCombatZonesSumAggregateInputType
    _min?: WarCombatZonesMinAggregateInputType
    _max?: WarCombatZonesMaxAggregateInputType
  }


  export type WarCombatZonesGroupByOutputType = {
    combatZoneID: number
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
    _count: WarCombatZonesCountAggregateOutputType | null
    _avg: WarCombatZonesAvgAggregateOutputType | null
    _sum: WarCombatZonesSumAggregateOutputType | null
    _min: WarCombatZonesMinAggregateOutputType | null
    _max: WarCombatZonesMaxAggregateOutputType | null
  }

  type GetWarCombatZonesGroupByPayload<T extends WarCombatZonesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WarCombatZonesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarCombatZonesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarCombatZonesGroupByOutputType[P]>
            : GetScalarType<T[P], WarCombatZonesGroupByOutputType[P]>
        }
      >
    >


  export type warCombatZonesSelect = {
    combatZoneID?: boolean
    combatZoneName?: boolean
    factionID?: boolean
    centerSystemID?: boolean
    description?: boolean
  }


  export type warCombatZonesGetPayload<S extends boolean | null | undefined | warCombatZonesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? warCombatZones :
    S extends undefined ? never :
    S extends { include: any } & (warCombatZonesArgs | warCombatZonesFindManyArgs)
    ? warCombatZones 
    : S extends { select: any } & (warCombatZonesArgs | warCombatZonesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof warCombatZones ? warCombatZones[P] : never
  } 
      : warCombatZones


  type warCombatZonesCountArgs = Merge<
    Omit<warCombatZonesFindManyArgs, 'select' | 'include'> & {
      select?: WarCombatZonesCountAggregateInputType | true
    }
  >

  export interface warCombatZonesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one WarCombatZones that matches the filter.
     * @param {warCombatZonesFindUniqueArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends warCombatZonesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, warCombatZonesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'warCombatZones'> extends True ? Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>> : Prisma__warCombatZonesClient<warCombatZonesGetPayload<T> | null, null>

    /**
     * Find the first WarCombatZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindFirstArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends warCombatZonesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, warCombatZonesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'warCombatZones'> extends True ? Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>> : Prisma__warCombatZonesClient<warCombatZonesGetPayload<T> | null, null>

    /**
     * Find zero or more WarCombatZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findMany()
     * 
     * // Get first 10 WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findMany({ take: 10 })
     * 
     * // Only select the `combatZoneID`
     * const warCombatZonesWithCombatZoneIDOnly = await prisma.warCombatZones.findMany({ select: { combatZoneID: true } })
     * 
    **/
    findMany<T extends warCombatZonesFindManyArgs>(
      args?: SelectSubset<T, warCombatZonesFindManyArgs>
    ): PrismaPromise<Array<warCombatZonesGetPayload<T>>>

    /**
     * Create a WarCombatZones.
     * @param {warCombatZonesCreateArgs} args - Arguments to create a WarCombatZones.
     * @example
     * // Create one WarCombatZones
     * const WarCombatZones = await prisma.warCombatZones.create({
     *   data: {
     *     // ... data to create a WarCombatZones
     *   }
     * })
     * 
    **/
    create<T extends warCombatZonesCreateArgs>(
      args: SelectSubset<T, warCombatZonesCreateArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Create many WarCombatZones.
     *     @param {warCombatZonesCreateManyArgs} args - Arguments to create many WarCombatZones.
     *     @example
     *     // Create many WarCombatZones
     *     const warCombatZones = await prisma.warCombatZones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends warCombatZonesCreateManyArgs>(
      args?: SelectSubset<T, warCombatZonesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WarCombatZones.
     * @param {warCombatZonesDeleteArgs} args - Arguments to delete one WarCombatZones.
     * @example
     * // Delete one WarCombatZones
     * const WarCombatZones = await prisma.warCombatZones.delete({
     *   where: {
     *     // ... filter to delete one WarCombatZones
     *   }
     * })
     * 
    **/
    delete<T extends warCombatZonesDeleteArgs>(
      args: SelectSubset<T, warCombatZonesDeleteArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Update one WarCombatZones.
     * @param {warCombatZonesUpdateArgs} args - Arguments to update one WarCombatZones.
     * @example
     * // Update one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends warCombatZonesUpdateArgs>(
      args: SelectSubset<T, warCombatZonesUpdateArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Delete zero or more WarCombatZones.
     * @param {warCombatZonesDeleteManyArgs} args - Arguments to filter WarCombatZones to delete.
     * @example
     * // Delete a few WarCombatZones
     * const { count } = await prisma.warCombatZones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends warCombatZonesDeleteManyArgs>(
      args?: SelectSubset<T, warCombatZonesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends warCombatZonesUpdateManyArgs>(
      args: SelectSubset<T, warCombatZonesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WarCombatZones.
     * @param {warCombatZonesUpsertArgs} args - Arguments to update or create a WarCombatZones.
     * @example
     * // Update or create a WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.upsert({
     *   create: {
     *     // ... data to create a WarCombatZones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarCombatZones we want to update
     *   }
     * })
    **/
    upsert<T extends warCombatZonesUpsertArgs>(
      args: SelectSubset<T, warCombatZonesUpsertArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Find one WarCombatZones that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {warCombatZonesFindUniqueOrThrowArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends warCombatZonesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, warCombatZonesFindUniqueOrThrowArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Find the first WarCombatZones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindFirstOrThrowArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends warCombatZonesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, warCombatZonesFindFirstOrThrowArgs>
    ): Prisma__warCombatZonesClient<warCombatZonesGetPayload<T>>

    /**
     * Count the number of WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesCountArgs} args - Arguments to filter WarCombatZones to count.
     * @example
     * // Count the number of WarCombatZones
     * const count = await prisma.warCombatZones.count({
     *   where: {
     *     // ... the filter for the WarCombatZones we want to count
     *   }
     * })
    **/
    count<T extends warCombatZonesCountArgs>(
      args?: Subset<T, warCombatZonesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarCombatZonesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZonesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarCombatZonesAggregateArgs>(args: Subset<T, WarCombatZonesAggregateArgs>): PrismaPromise<GetWarCombatZonesAggregateType<T>>

    /**
     * Group by WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZonesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarCombatZonesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarCombatZonesGroupByArgs['orderBy'] }
        : { orderBy?: WarCombatZonesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarCombatZonesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarCombatZonesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for warCombatZones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__warCombatZonesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * warCombatZones base type for findUnique actions
   */
  export type warCombatZonesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * Filter, which warCombatZones to fetch.
     * 
    **/
    where: warCombatZonesWhereUniqueInput
  }

  /**
   * warCombatZones: findUnique
   */
  export interface warCombatZonesFindUniqueArgs extends warCombatZonesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * warCombatZones base type for findFirst actions
   */
  export type warCombatZonesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * Filter, which warCombatZones to fetch.
     * 
    **/
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZonesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZones.
     * 
    **/
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZones.
     * 
    **/
    distinct?: Enumerable<WarCombatZonesScalarFieldEnum>
  }

  /**
   * warCombatZones: findFirst
   */
  export interface warCombatZonesFindFirstArgs extends warCombatZonesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * warCombatZones findMany
   */
  export type warCombatZonesFindManyArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * Filter, which warCombatZones to fetch.
     * 
    **/
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     * 
    **/
    orderBy?: Enumerable<warCombatZonesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warCombatZones.
     * 
    **/
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WarCombatZonesScalarFieldEnum>
  }


  /**
   * warCombatZones create
   */
  export type warCombatZonesCreateArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * The data needed to create a warCombatZones.
     * 
    **/
    data: XOR<warCombatZonesCreateInput, warCombatZonesUncheckedCreateInput>
  }


  /**
   * warCombatZones createMany
   */
  export type warCombatZonesCreateManyArgs = {
    /**
     * The data used to create many warCombatZones.
     * 
    **/
    data: Enumerable<warCombatZonesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * warCombatZones update
   */
  export type warCombatZonesUpdateArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * The data needed to update a warCombatZones.
     * 
    **/
    data: XOR<warCombatZonesUpdateInput, warCombatZonesUncheckedUpdateInput>
    /**
     * Choose, which warCombatZones to update.
     * 
    **/
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones updateMany
   */
  export type warCombatZonesUpdateManyArgs = {
    /**
     * The data used to update warCombatZones.
     * 
    **/
    data: XOR<warCombatZonesUpdateManyMutationInput, warCombatZonesUncheckedUpdateManyInput>
    /**
     * Filter which warCombatZones to update
     * 
    **/
    where?: warCombatZonesWhereInput
  }


  /**
   * warCombatZones upsert
   */
  export type warCombatZonesUpsertArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * The filter to search for the warCombatZones to update in case it exists.
     * 
    **/
    where: warCombatZonesWhereUniqueInput
    /**
     * In case the warCombatZones found by the `where` argument doesn't exist, create a new warCombatZones with this data.
     * 
    **/
    create: XOR<warCombatZonesCreateInput, warCombatZonesUncheckedCreateInput>
    /**
     * In case the warCombatZones was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<warCombatZonesUpdateInput, warCombatZonesUncheckedUpdateInput>
  }


  /**
   * warCombatZones delete
   */
  export type warCombatZonesDeleteArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
    /**
     * Filter which warCombatZones to delete.
     * 
    **/
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones deleteMany
   */
  export type warCombatZonesDeleteManyArgs = {
    /**
     * Filter which warCombatZones to delete
     * 
    **/
    where?: warCombatZonesWhereInput
  }


  /**
   * warCombatZones: findUniqueOrThrow
   */
  export type warCombatZonesFindUniqueOrThrowArgs = warCombatZonesFindUniqueArgsBase
      

  /**
   * warCombatZones: findFirstOrThrow
   */
  export type warCombatZonesFindFirstOrThrowArgs = warCombatZonesFindFirstArgsBase
      

  /**
   * warCombatZones without action
   */
  export type warCombatZonesArgs = {
    /**
     * Select specific fields to fetch from the warCombatZones
     * 
    **/
    select?: warCombatZonesSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AgtAgentTypesScalarFieldEnum: {
    agentTypeID: 'agentTypeID',
    agentType: 'agentType'
  };

  export type AgtAgentTypesScalarFieldEnum = (typeof AgtAgentTypesScalarFieldEnum)[keyof typeof AgtAgentTypesScalarFieldEnum]


  export const AgtAgentsInSpaceScalarFieldEnum: {
    agentID: 'agentID',
    dungeonID: 'dungeonID',
    solarSystemID: 'solarSystemID',
    spawnPointID: 'spawnPointID',
    typeID: 'typeID'
  };

  export type AgtAgentsInSpaceScalarFieldEnum = (typeof AgtAgentsInSpaceScalarFieldEnum)[keyof typeof AgtAgentsInSpaceScalarFieldEnum]


  export const AgtAgentsScalarFieldEnum: {
    agentID: 'agentID',
    divisionID: 'divisionID',
    corporationID: 'corporationID',
    locationID: 'locationID',
    level: 'level',
    quality: 'quality',
    agentTypeID: 'agentTypeID',
    isLocator: 'isLocator'
  };

  export type AgtAgentsScalarFieldEnum = (typeof AgtAgentsScalarFieldEnum)[keyof typeof AgtAgentsScalarFieldEnum]


  export const AgtResearchAgentsScalarFieldEnum: {
    agentID: 'agentID',
    typeID: 'typeID'
  };

  export type AgtResearchAgentsScalarFieldEnum = (typeof AgtResearchAgentsScalarFieldEnum)[keyof typeof AgtResearchAgentsScalarFieldEnum]


  export const AllianceScalarFieldEnum: {
    id: 'id',
    creatorCorporationId: 'creatorCorporationId',
    creatorId: 'creatorId',
    name: 'name',
    dateFounded: 'dateFounded',
    executorCorporationId: 'executorCorporationId',
    factionId: 'factionId',
    ticker: 'ticker'
  };

  export type AllianceScalarFieldEnum = (typeof AllianceScalarFieldEnum)[keyof typeof AllianceScalarFieldEnum]


  export const CertCertsScalarFieldEnum: {
    certID: 'certID',
    description: 'description',
    groupID: 'groupID',
    name: 'name'
  };

  export type CertCertsScalarFieldEnum = (typeof CertCertsScalarFieldEnum)[keyof typeof CertCertsScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    esiId: 'esiId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiresAt: 'tokenExpiresAt',
    allianceId: 'allianceId',
    ancestryId: 'ancestryId',
    birthday: 'birthday',
    bloodlineId: 'bloodlineId',
    corporationId: 'corporationId',
    description: 'description',
    factionId: 'factionId',
    gender: 'gender',
    name: 'name',
    raceId: 'raceId',
    scopes: 'scopes',
    securityStatus: 'securityStatus',
    title: 'title',
    totalSp: 'totalSp',
    ownerId: 'ownerId'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const ChrAncestriesScalarFieldEnum: {
    ancestryID: 'ancestryID',
    ancestryName: 'ancestryName',
    bloodlineID: 'bloodlineID',
    description: 'description',
    perception: 'perception',
    willpower: 'willpower',
    charisma: 'charisma',
    memory: 'memory',
    intelligence: 'intelligence',
    iconID: 'iconID',
    shortDescription: 'shortDescription'
  };

  export type ChrAncestriesScalarFieldEnum = (typeof ChrAncestriesScalarFieldEnum)[keyof typeof ChrAncestriesScalarFieldEnum]


  export const ChrAttributesScalarFieldEnum: {
    attributeID: 'attributeID',
    attributeName: 'attributeName',
    description: 'description',
    iconID: 'iconID',
    shortDescription: 'shortDescription',
    notes: 'notes'
  };

  export type ChrAttributesScalarFieldEnum = (typeof ChrAttributesScalarFieldEnum)[keyof typeof ChrAttributesScalarFieldEnum]


  export const ChrBloodlinesScalarFieldEnum: {
    bloodlineID: 'bloodlineID',
    bloodlineName: 'bloodlineName',
    raceID: 'raceID',
    description: 'description',
    maleDescription: 'maleDescription',
    femaleDescription: 'femaleDescription',
    shipTypeID: 'shipTypeID',
    corporationID: 'corporationID',
    perception: 'perception',
    willpower: 'willpower',
    charisma: 'charisma',
    memory: 'memory',
    intelligence: 'intelligence',
    iconID: 'iconID',
    shortDescription: 'shortDescription',
    shortMaleDescription: 'shortMaleDescription',
    shortFemaleDescription: 'shortFemaleDescription'
  };

  export type ChrBloodlinesScalarFieldEnum = (typeof ChrBloodlinesScalarFieldEnum)[keyof typeof ChrBloodlinesScalarFieldEnum]


  export const ChrFactionsScalarFieldEnum: {
    factionID: 'factionID',
    factionName: 'factionName',
    description: 'description',
    raceIDs: 'raceIDs',
    solarSystemID: 'solarSystemID',
    corporationID: 'corporationID',
    sizeFactor: 'sizeFactor',
    stationCount: 'stationCount',
    stationSystemCount: 'stationSystemCount',
    militiaCorporationID: 'militiaCorporationID',
    iconID: 'iconID'
  };

  export type ChrFactionsScalarFieldEnum = (typeof ChrFactionsScalarFieldEnum)[keyof typeof ChrFactionsScalarFieldEnum]


  export const ChrRacesScalarFieldEnum: {
    raceID: 'raceID',
    raceName: 'raceName',
    description: 'description',
    iconID: 'iconID',
    shortDescription: 'shortDescription'
  };

  export type ChrRacesScalarFieldEnum = (typeof ChrRacesScalarFieldEnum)[keyof typeof ChrRacesScalarFieldEnum]


  export const CorporationScalarFieldEnum: {
    id: 'id',
    allianceId: 'allianceId',
    ceoId: 'ceoId',
    creatorId: 'creatorId',
    dateFounded: 'dateFounded',
    description: 'description',
    factionId: 'factionId',
    homeStationId: 'homeStationId',
    memberCount: 'memberCount',
    name: 'name',
    shares: 'shares',
    taxRate: 'taxRate',
    ticker: 'ticker',
    url: 'url',
    warEligible: 'warEligible'
  };

  export type CorporationScalarFieldEnum = (typeof CorporationScalarFieldEnum)[keyof typeof CorporationScalarFieldEnum]


  export const CrpActivitiesScalarFieldEnum: {
    activityID: 'activityID',
    activityName: 'activityName',
    description: 'description'
  };

  export type CrpActivitiesScalarFieldEnum = (typeof CrpActivitiesScalarFieldEnum)[keyof typeof CrpActivitiesScalarFieldEnum]


  export const CrpNPCCorporationDivisionsScalarFieldEnum: {
    corporationID: 'corporationID',
    divisionID: 'divisionID',
    size: 'size'
  };

  export type CrpNPCCorporationDivisionsScalarFieldEnum = (typeof CrpNPCCorporationDivisionsScalarFieldEnum)[keyof typeof CrpNPCCorporationDivisionsScalarFieldEnum]


  export const CrpNPCCorporationResearchFieldsScalarFieldEnum: {
    skillID: 'skillID',
    corporationID: 'corporationID'
  };

  export type CrpNPCCorporationResearchFieldsScalarFieldEnum = (typeof CrpNPCCorporationResearchFieldsScalarFieldEnum)[keyof typeof CrpNPCCorporationResearchFieldsScalarFieldEnum]


  export const CrpNPCCorporationTradesScalarFieldEnum: {
    corporationID: 'corporationID',
    typeID: 'typeID'
  };

  export type CrpNPCCorporationTradesScalarFieldEnum = (typeof CrpNPCCorporationTradesScalarFieldEnum)[keyof typeof CrpNPCCorporationTradesScalarFieldEnum]


  export const CrpNPCCorporationsScalarFieldEnum: {
    corporationID: 'corporationID',
    size: 'size',
    extent: 'extent',
    solarSystemID: 'solarSystemID',
    investorID1: 'investorID1',
    investorShares1: 'investorShares1',
    investorID2: 'investorID2',
    investorShares2: 'investorShares2',
    investorID3: 'investorID3',
    investorShares3: 'investorShares3',
    investorID4: 'investorID4',
    investorShares4: 'investorShares4',
    friendID: 'friendID',
    enemyID: 'enemyID',
    publicShares: 'publicShares',
    initialPrice: 'initialPrice',
    minSecurity: 'minSecurity',
    scattered: 'scattered',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    border: 'border',
    factionID: 'factionID',
    sizeFactor: 'sizeFactor',
    stationCount: 'stationCount',
    stationSystemCount: 'stationSystemCount',
    description: 'description',
    iconID: 'iconID'
  };

  export type CrpNPCCorporationsScalarFieldEnum = (typeof CrpNPCCorporationsScalarFieldEnum)[keyof typeof CrpNPCCorporationsScalarFieldEnum]


  export const CrpNPCDivisionsScalarFieldEnum: {
    divisionID: 'divisionID',
    divisionName: 'divisionName',
    description: 'description',
    leaderType: 'leaderType'
  };

  export type CrpNPCDivisionsScalarFieldEnum = (typeof CrpNPCDivisionsScalarFieldEnum)[keyof typeof CrpNPCDivisionsScalarFieldEnum]


  export const DgmAttributeCategoriesScalarFieldEnum: {
    categoryID: 'categoryID',
    categoryName: 'categoryName',
    categoryDescription: 'categoryDescription'
  };

  export type DgmAttributeCategoriesScalarFieldEnum = (typeof DgmAttributeCategoriesScalarFieldEnum)[keyof typeof DgmAttributeCategoriesScalarFieldEnum]


  export const DgmAttributeTypesScalarFieldEnum: {
    attributeID: 'attributeID',
    attributeName: 'attributeName',
    description: 'description',
    iconID: 'iconID',
    defaultValue: 'defaultValue',
    published: 'published',
    displayName: 'displayName',
    unitID: 'unitID',
    stackable: 'stackable',
    highIsGood: 'highIsGood',
    categoryID: 'categoryID'
  };

  export type DgmAttributeTypesScalarFieldEnum = (typeof DgmAttributeTypesScalarFieldEnum)[keyof typeof DgmAttributeTypesScalarFieldEnum]


  export const DgmEffectsScalarFieldEnum: {
    effectID: 'effectID',
    effectName: 'effectName',
    effectCategory: 'effectCategory',
    preExpression: 'preExpression',
    postExpression: 'postExpression',
    description: 'description',
    guid: 'guid',
    iconID: 'iconID',
    isOffensive: 'isOffensive',
    isAssistance: 'isAssistance',
    durationAttributeID: 'durationAttributeID',
    trackingSpeedAttributeID: 'trackingSpeedAttributeID',
    dischargeAttributeID: 'dischargeAttributeID',
    rangeAttributeID: 'rangeAttributeID',
    falloffAttributeID: 'falloffAttributeID',
    disallowAutoRepeat: 'disallowAutoRepeat',
    published: 'published',
    displayName: 'displayName',
    isWarpSafe: 'isWarpSafe',
    rangeChance: 'rangeChance',
    electronicChance: 'electronicChance',
    propulsionChance: 'propulsionChance',
    distribution: 'distribution',
    sfxName: 'sfxName',
    npcUsageChanceAttributeID: 'npcUsageChanceAttributeID',
    npcActivationChanceAttributeID: 'npcActivationChanceAttributeID',
    fittingUsageChanceAttributeID: 'fittingUsageChanceAttributeID',
    modifierInfo: 'modifierInfo'
  };

  export type DgmEffectsScalarFieldEnum = (typeof DgmEffectsScalarFieldEnum)[keyof typeof DgmEffectsScalarFieldEnum]


  export const DgmExpressionsScalarFieldEnum: {
    expressionID: 'expressionID',
    operandID: 'operandID',
    arg1: 'arg1',
    arg2: 'arg2',
    expressionValue: 'expressionValue',
    description: 'description',
    expressionName: 'expressionName',
    expressionTypeID: 'expressionTypeID',
    expressionGroupID: 'expressionGroupID',
    expressionAttributeID: 'expressionAttributeID'
  };

  export type DgmExpressionsScalarFieldEnum = (typeof DgmExpressionsScalarFieldEnum)[keyof typeof DgmExpressionsScalarFieldEnum]


  export const DgmTypeAttributesScalarFieldEnum: {
    typeID: 'typeID',
    attributeID: 'attributeID',
    valueInt: 'valueInt',
    valueFloat: 'valueFloat'
  };

  export type DgmTypeAttributesScalarFieldEnum = (typeof DgmTypeAttributesScalarFieldEnum)[keyof typeof DgmTypeAttributesScalarFieldEnum]


  export const DgmTypeEffectsScalarFieldEnum: {
    typeID: 'typeID',
    effectID: 'effectID',
    isDefault: 'isDefault'
  };

  export type DgmTypeEffectsScalarFieldEnum = (typeof DgmTypeEffectsScalarFieldEnum)[keyof typeof DgmTypeEffectsScalarFieldEnum]


  export const EveGraphicsScalarFieldEnum: {
    graphicID: 'graphicID',
    sofFactionName: 'sofFactionName',
    graphicFile: 'graphicFile',
    sofHullName: 'sofHullName',
    sofRaceName: 'sofRaceName',
    description: 'description'
  };

  export type EveGraphicsScalarFieldEnum = (typeof EveGraphicsScalarFieldEnum)[keyof typeof EveGraphicsScalarFieldEnum]


  export const EveIconsScalarFieldEnum: {
    iconID: 'iconID',
    iconFile: 'iconFile',
    description: 'description'
  };

  export type EveIconsScalarFieldEnum = (typeof EveIconsScalarFieldEnum)[keyof typeof EveIconsScalarFieldEnum]


  export const EveUnitsScalarFieldEnum: {
    unitID: 'unitID',
    unitName: 'unitName',
    displayName: 'displayName',
    description: 'description'
  };

  export type EveUnitsScalarFieldEnum = (typeof EveUnitsScalarFieldEnum)[keyof typeof EveUnitsScalarFieldEnum]


  export const IndustryActivityScalarFieldEnum: {
    typeID: 'typeID',
    activityID: 'activityID',
    time: 'time'
  };

  export type IndustryActivityScalarFieldEnum = (typeof IndustryActivityScalarFieldEnum)[keyof typeof IndustryActivityScalarFieldEnum]


  export const IndustryBlueprintsScalarFieldEnum: {
    typeID: 'typeID',
    maxProductionLimit: 'maxProductionLimit'
  };

  export type IndustryBlueprintsScalarFieldEnum = (typeof IndustryBlueprintsScalarFieldEnum)[keyof typeof IndustryBlueprintsScalarFieldEnum]


  export const InvCategoriesScalarFieldEnum: {
    categoryID: 'categoryID',
    categoryName: 'categoryName',
    iconID: 'iconID',
    published: 'published'
  };

  export type InvCategoriesScalarFieldEnum = (typeof InvCategoriesScalarFieldEnum)[keyof typeof InvCategoriesScalarFieldEnum]


  export const InvContrabandTypesScalarFieldEnum: {
    factionID: 'factionID',
    typeID: 'typeID',
    standingLoss: 'standingLoss',
    confiscateMinSec: 'confiscateMinSec',
    fineByValue: 'fineByValue',
    attackMinSec: 'attackMinSec'
  };

  export type InvContrabandTypesScalarFieldEnum = (typeof InvContrabandTypesScalarFieldEnum)[keyof typeof InvContrabandTypesScalarFieldEnum]


  export const InvControlTowerResourcePurposesScalarFieldEnum: {
    purpose: 'purpose',
    purposeText: 'purposeText'
  };

  export type InvControlTowerResourcePurposesScalarFieldEnum = (typeof InvControlTowerResourcePurposesScalarFieldEnum)[keyof typeof InvControlTowerResourcePurposesScalarFieldEnum]


  export const InvControlTowerResourcesScalarFieldEnum: {
    controlTowerTypeID: 'controlTowerTypeID',
    resourceTypeID: 'resourceTypeID',
    purpose: 'purpose',
    quantity: 'quantity',
    minSecurityLevel: 'minSecurityLevel',
    factionID: 'factionID'
  };

  export type InvControlTowerResourcesScalarFieldEnum = (typeof InvControlTowerResourcesScalarFieldEnum)[keyof typeof InvControlTowerResourcesScalarFieldEnum]


  export const InvFlagsScalarFieldEnum: {
    flagID: 'flagID',
    flagName: 'flagName',
    flagText: 'flagText',
    orderID: 'orderID'
  };

  export type InvFlagsScalarFieldEnum = (typeof InvFlagsScalarFieldEnum)[keyof typeof InvFlagsScalarFieldEnum]


  export const InvGroupsScalarFieldEnum: {
    groupID: 'groupID',
    categoryID: 'categoryID',
    groupName: 'groupName',
    iconID: 'iconID',
    useBasePrice: 'useBasePrice',
    anchored: 'anchored',
    anchorable: 'anchorable',
    fittableNonSingleton: 'fittableNonSingleton',
    published: 'published'
  };

  export type InvGroupsScalarFieldEnum = (typeof InvGroupsScalarFieldEnum)[keyof typeof InvGroupsScalarFieldEnum]


  export const InvItemsScalarFieldEnum: {
    itemID: 'itemID',
    typeID: 'typeID',
    ownerID: 'ownerID',
    locationID: 'locationID',
    flagID: 'flagID',
    quantity: 'quantity'
  };

  export type InvItemsScalarFieldEnum = (typeof InvItemsScalarFieldEnum)[keyof typeof InvItemsScalarFieldEnum]


  export const InvMarketGroupsScalarFieldEnum: {
    marketGroupID: 'marketGroupID',
    parentGroupID: 'parentGroupID',
    marketGroupName: 'marketGroupName',
    description: 'description',
    iconID: 'iconID',
    hasTypes: 'hasTypes'
  };

  export type InvMarketGroupsScalarFieldEnum = (typeof InvMarketGroupsScalarFieldEnum)[keyof typeof InvMarketGroupsScalarFieldEnum]


  export const InvMetaGroupsScalarFieldEnum: {
    metaGroupID: 'metaGroupID',
    metaGroupName: 'metaGroupName',
    description: 'description',
    iconID: 'iconID'
  };

  export type InvMetaGroupsScalarFieldEnum = (typeof InvMetaGroupsScalarFieldEnum)[keyof typeof InvMetaGroupsScalarFieldEnum]


  export const InvMetaTypesScalarFieldEnum: {
    typeID: 'typeID',
    parentTypeID: 'parentTypeID',
    metaGroupID: 'metaGroupID'
  };

  export type InvMetaTypesScalarFieldEnum = (typeof InvMetaTypesScalarFieldEnum)[keyof typeof InvMetaTypesScalarFieldEnum]


  export const InvNamesScalarFieldEnum: {
    itemID: 'itemID',
    itemName: 'itemName'
  };

  export type InvNamesScalarFieldEnum = (typeof InvNamesScalarFieldEnum)[keyof typeof InvNamesScalarFieldEnum]


  export const InvPositionsScalarFieldEnum: {
    itemID: 'itemID',
    x: 'x',
    y: 'y',
    z: 'z',
    yaw: 'yaw',
    pitch: 'pitch',
    roll: 'roll'
  };

  export type InvPositionsScalarFieldEnum = (typeof InvPositionsScalarFieldEnum)[keyof typeof InvPositionsScalarFieldEnum]


  export const InvTraitsScalarFieldEnum: {
    traitID: 'traitID',
    typeID: 'typeID',
    skillID: 'skillID',
    bonus: 'bonus',
    bonusText: 'bonusText',
    unitID: 'unitID'
  };

  export type InvTraitsScalarFieldEnum = (typeof InvTraitsScalarFieldEnum)[keyof typeof InvTraitsScalarFieldEnum]


  export const InvTypeMaterialsScalarFieldEnum: {
    typeID: 'typeID',
    materialTypeID: 'materialTypeID',
    quantity: 'quantity'
  };

  export type InvTypeMaterialsScalarFieldEnum = (typeof InvTypeMaterialsScalarFieldEnum)[keyof typeof InvTypeMaterialsScalarFieldEnum]


  export const InvTypeReactionsScalarFieldEnum: {
    reactionTypeID: 'reactionTypeID',
    input: 'input',
    typeID: 'typeID',
    quantity: 'quantity'
  };

  export type InvTypeReactionsScalarFieldEnum = (typeof InvTypeReactionsScalarFieldEnum)[keyof typeof InvTypeReactionsScalarFieldEnum]


  export const InvTypesScalarFieldEnum: {
    typeID: 'typeID',
    groupID: 'groupID',
    typeName: 'typeName',
    description: 'description',
    mass: 'mass',
    volume: 'volume',
    capacity: 'capacity',
    portionSize: 'portionSize',
    raceID: 'raceID',
    basePrice: 'basePrice',
    published: 'published',
    marketGroupID: 'marketGroupID',
    iconID: 'iconID',
    soundID: 'soundID',
    graphicID: 'graphicID'
  };

  export type InvTypesScalarFieldEnum = (typeof InvTypesScalarFieldEnum)[keyof typeof InvTypesScalarFieldEnum]


  export const InvUniqueNamesScalarFieldEnum: {
    itemID: 'itemID',
    itemName: 'itemName',
    groupID: 'groupID'
  };

  export type InvUniqueNamesScalarFieldEnum = (typeof InvUniqueNamesScalarFieldEnum)[keyof typeof InvUniqueNamesScalarFieldEnum]


  export const InvVolumesScalarFieldEnum: {
    typeID: 'typeID',
    volume: 'volume'
  };

  export type InvVolumesScalarFieldEnum = (typeof InvVolumesScalarFieldEnum)[keyof typeof InvVolumesScalarFieldEnum]


  export const MapCelestialGraphicsScalarFieldEnum: {
    celestialID: 'celestialID',
    heightMap1: 'heightMap1',
    heightMap2: 'heightMap2',
    shaderPreset: 'shaderPreset',
    population: 'population'
  };

  export type MapCelestialGraphicsScalarFieldEnum = (typeof MapCelestialGraphicsScalarFieldEnum)[keyof typeof MapCelestialGraphicsScalarFieldEnum]


  export const MapCelestialStatisticsScalarFieldEnum: {
    celestialID: 'celestialID',
    temperature: 'temperature',
    spectralClass: 'spectralClass',
    luminosity: 'luminosity',
    age: 'age',
    life: 'life',
    orbitRadius: 'orbitRadius',
    eccentricity: 'eccentricity',
    massDust: 'massDust',
    massGas: 'massGas',
    fragmented: 'fragmented',
    density: 'density',
    surfaceGravity: 'surfaceGravity',
    escapeVelocity: 'escapeVelocity',
    orbitPeriod: 'orbitPeriod',
    rotationRate: 'rotationRate',
    locked: 'locked',
    pressure: 'pressure',
    radius: 'radius',
    mass: 'mass'
  };

  export type MapCelestialStatisticsScalarFieldEnum = (typeof MapCelestialStatisticsScalarFieldEnum)[keyof typeof MapCelestialStatisticsScalarFieldEnum]


  export const MapConstellationJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    fromConstellationID: 'fromConstellationID',
    toConstellationID: 'toConstellationID',
    toRegionID: 'toRegionID'
  };

  export type MapConstellationJumpsScalarFieldEnum = (typeof MapConstellationJumpsScalarFieldEnum)[keyof typeof MapConstellationJumpsScalarFieldEnum]


  export const MapConstellationsScalarFieldEnum: {
    regionID: 'regionID',
    constellationID: 'constellationID',
    constellationName: 'constellationName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    factionID: 'factionID',
    radius: 'radius'
  };

  export type MapConstellationsScalarFieldEnum = (typeof MapConstellationsScalarFieldEnum)[keyof typeof MapConstellationsScalarFieldEnum]


  export const MapDenormalizeScalarFieldEnum: {
    itemID: 'itemID',
    typeID: 'typeID',
    groupID: 'groupID',
    solarSystemID: 'solarSystemID',
    constellationID: 'constellationID',
    regionID: 'regionID',
    orbitID: 'orbitID',
    x: 'x',
    y: 'y',
    z: 'z',
    radius: 'radius',
    itemName: 'itemName',
    security: 'security',
    celestialIndex: 'celestialIndex',
    orbitIndex: 'orbitIndex'
  };

  export type MapDenormalizeScalarFieldEnum = (typeof MapDenormalizeScalarFieldEnum)[keyof typeof MapDenormalizeScalarFieldEnum]


  export const MapJumpsScalarFieldEnum: {
    stargateID: 'stargateID',
    destinationID: 'destinationID'
  };

  export type MapJumpsScalarFieldEnum = (typeof MapJumpsScalarFieldEnum)[keyof typeof MapJumpsScalarFieldEnum]


  export const MapLandmarksScalarFieldEnum: {
    landmarkID: 'landmarkID',
    landmarkName: 'landmarkName',
    description: 'description',
    locationID: 'locationID',
    x: 'x',
    y: 'y',
    z: 'z',
    iconID: 'iconID'
  };

  export type MapLandmarksScalarFieldEnum = (typeof MapLandmarksScalarFieldEnum)[keyof typeof MapLandmarksScalarFieldEnum]


  export const MapLocationScenesScalarFieldEnum: {
    locationID: 'locationID',
    graphicID: 'graphicID'
  };

  export type MapLocationScenesScalarFieldEnum = (typeof MapLocationScenesScalarFieldEnum)[keyof typeof MapLocationScenesScalarFieldEnum]


  export const MapLocationWormholeClassesScalarFieldEnum: {
    locationID: 'locationID',
    wormholeClassID: 'wormholeClassID'
  };

  export type MapLocationWormholeClassesScalarFieldEnum = (typeof MapLocationWormholeClassesScalarFieldEnum)[keyof typeof MapLocationWormholeClassesScalarFieldEnum]


  export const MapRegionJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    toRegionID: 'toRegionID'
  };

  export type MapRegionJumpsScalarFieldEnum = (typeof MapRegionJumpsScalarFieldEnum)[keyof typeof MapRegionJumpsScalarFieldEnum]


  export const MapRegionsScalarFieldEnum: {
    regionID: 'regionID',
    regionName: 'regionName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    factionID: 'factionID',
    nebula: 'nebula',
    radius: 'radius'
  };

  export type MapRegionsScalarFieldEnum = (typeof MapRegionsScalarFieldEnum)[keyof typeof MapRegionsScalarFieldEnum]


  export const MapSolarSystemJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    fromConstellationID: 'fromConstellationID',
    fromSolarSystemID: 'fromSolarSystemID',
    toSolarSystemID: 'toSolarSystemID',
    toConstellationID: 'toConstellationID',
    toRegionID: 'toRegionID'
  };

  export type MapSolarSystemJumpsScalarFieldEnum = (typeof MapSolarSystemJumpsScalarFieldEnum)[keyof typeof MapSolarSystemJumpsScalarFieldEnum]


  export const MapSolarSystemsScalarFieldEnum: {
    regionID: 'regionID',
    constellationID: 'constellationID',
    solarSystemID: 'solarSystemID',
    solarSystemName: 'solarSystemName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    luminosity: 'luminosity',
    border: 'border',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    international: 'international',
    regional: 'regional',
    constellation: 'constellation',
    security: 'security',
    factionID: 'factionID',
    radius: 'radius',
    sunTypeID: 'sunTypeID',
    securityClass: 'securityClass'
  };

  export type MapSolarSystemsScalarFieldEnum = (typeof MapSolarSystemsScalarFieldEnum)[keyof typeof MapSolarSystemsScalarFieldEnum]


  export const MapUniverseScalarFieldEnum: {
    universeID: 'universeID',
    universeName: 'universeName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    radius: 'radius'
  };

  export type MapUniverseScalarFieldEnum = (typeof MapUniverseScalarFieldEnum)[keyof typeof MapUniverseScalarFieldEnum]


  export const PlanetSchematicsPinMapScalarFieldEnum: {
    schematicID: 'schematicID',
    pinTypeID: 'pinTypeID'
  };

  export type PlanetSchematicsPinMapScalarFieldEnum = (typeof PlanetSchematicsPinMapScalarFieldEnum)[keyof typeof PlanetSchematicsPinMapScalarFieldEnum]


  export const PlanetSchematicsScalarFieldEnum: {
    schematicID: 'schematicID',
    schematicName: 'schematicName',
    cycleTime: 'cycleTime'
  };

  export type PlanetSchematicsScalarFieldEnum = (typeof PlanetSchematicsScalarFieldEnum)[keyof typeof PlanetSchematicsScalarFieldEnum]


  export const PlanetSchematicsTypeMapScalarFieldEnum: {
    schematicID: 'schematicID',
    typeID: 'typeID',
    quantity: 'quantity',
    isInput: 'isInput'
  };

  export type PlanetSchematicsTypeMapScalarFieldEnum = (typeof PlanetSchematicsTypeMapScalarFieldEnum)[keyof typeof PlanetSchematicsTypeMapScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RamActivitiesScalarFieldEnum: {
    activityID: 'activityID',
    activityName: 'activityName',
    iconNo: 'iconNo',
    description: 'description',
    published: 'published'
  };

  export type RamActivitiesScalarFieldEnum = (typeof RamActivitiesScalarFieldEnum)[keyof typeof RamActivitiesScalarFieldEnum]


  export const RamAssemblyLineStationsScalarFieldEnum: {
    stationID: 'stationID',
    assemblyLineTypeID: 'assemblyLineTypeID',
    quantity: 'quantity',
    stationTypeID: 'stationTypeID',
    ownerID: 'ownerID',
    solarSystemID: 'solarSystemID',
    regionID: 'regionID'
  };

  export type RamAssemblyLineStationsScalarFieldEnum = (typeof RamAssemblyLineStationsScalarFieldEnum)[keyof typeof RamAssemblyLineStationsScalarFieldEnum]


  export const RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    categoryID: 'categoryID',
    timeMultiplier: 'timeMultiplier',
    materialMultiplier: 'materialMultiplier',
    costMultiplier: 'costMultiplier'
  };

  export type RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum = (typeof RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum)[keyof typeof RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum]


  export const RamAssemblyLineTypeDetailPerGroupScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    groupID: 'groupID',
    timeMultiplier: 'timeMultiplier',
    materialMultiplier: 'materialMultiplier',
    costMultiplier: 'costMultiplier'
  };

  export type RamAssemblyLineTypeDetailPerGroupScalarFieldEnum = (typeof RamAssemblyLineTypeDetailPerGroupScalarFieldEnum)[keyof typeof RamAssemblyLineTypeDetailPerGroupScalarFieldEnum]


  export const RamAssemblyLineTypesScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    assemblyLineTypeName: 'assemblyLineTypeName',
    description: 'description',
    baseTimeMultiplier: 'baseTimeMultiplier',
    baseMaterialMultiplier: 'baseMaterialMultiplier',
    baseCostMultiplier: 'baseCostMultiplier',
    volume: 'volume',
    activityID: 'activityID',
    minCostPerHour: 'minCostPerHour'
  };

  export type RamAssemblyLineTypesScalarFieldEnum = (typeof RamAssemblyLineTypesScalarFieldEnum)[keyof typeof RamAssemblyLineTypesScalarFieldEnum]


  export const RamInstallationTypeContentsScalarFieldEnum: {
    installationTypeID: 'installationTypeID',
    assemblyLineTypeID: 'assemblyLineTypeID',
    quantity: 'quantity'
  };

  export type RamInstallationTypeContentsScalarFieldEnum = (typeof RamInstallationTypeContentsScalarFieldEnum)[keyof typeof RamInstallationTypeContentsScalarFieldEnum]


  export const SkinLicenseScalarFieldEnum: {
    licenseTypeID: 'licenseTypeID',
    duration: 'duration',
    skinID: 'skinID'
  };

  export type SkinLicenseScalarFieldEnum = (typeof SkinLicenseScalarFieldEnum)[keyof typeof SkinLicenseScalarFieldEnum]


  export const SkinMaterialsScalarFieldEnum: {
    skinMaterialID: 'skinMaterialID',
    displayNameID: 'displayNameID',
    materialSetID: 'materialSetID'
  };

  export type SkinMaterialsScalarFieldEnum = (typeof SkinMaterialsScalarFieldEnum)[keyof typeof SkinMaterialsScalarFieldEnum]


  export const SkinsScalarFieldEnum: {
    skinID: 'skinID',
    internalName: 'internalName',
    skinMaterialID: 'skinMaterialID'
  };

  export type SkinsScalarFieldEnum = (typeof SkinsScalarFieldEnum)[keyof typeof SkinsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StaOperationServicesScalarFieldEnum: {
    operationID: 'operationID',
    serviceID: 'serviceID'
  };

  export type StaOperationServicesScalarFieldEnum = (typeof StaOperationServicesScalarFieldEnum)[keyof typeof StaOperationServicesScalarFieldEnum]


  export const StaOperationsScalarFieldEnum: {
    activityID: 'activityID',
    operationID: 'operationID',
    operationName: 'operationName',
    description: 'description',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    border: 'border',
    ratio: 'ratio',
    caldariStationTypeID: 'caldariStationTypeID',
    minmatarStationTypeID: 'minmatarStationTypeID',
    amarrStationTypeID: 'amarrStationTypeID',
    gallenteStationTypeID: 'gallenteStationTypeID',
    joveStationTypeID: 'joveStationTypeID'
  };

  export type StaOperationsScalarFieldEnum = (typeof StaOperationsScalarFieldEnum)[keyof typeof StaOperationsScalarFieldEnum]


  export const StaServicesScalarFieldEnum: {
    serviceID: 'serviceID',
    serviceName: 'serviceName',
    description: 'description'
  };

  export type StaServicesScalarFieldEnum = (typeof StaServicesScalarFieldEnum)[keyof typeof StaServicesScalarFieldEnum]


  export const StaStationTypesScalarFieldEnum: {
    stationTypeID: 'stationTypeID',
    dockEntryX: 'dockEntryX',
    dockEntryY: 'dockEntryY',
    dockEntryZ: 'dockEntryZ',
    dockOrientationX: 'dockOrientationX',
    dockOrientationY: 'dockOrientationY',
    dockOrientationZ: 'dockOrientationZ',
    operationID: 'operationID',
    officeSlots: 'officeSlots',
    reprocessingEfficiency: 'reprocessingEfficiency',
    conquerable: 'conquerable'
  };

  export type StaStationTypesScalarFieldEnum = (typeof StaStationTypesScalarFieldEnum)[keyof typeof StaStationTypesScalarFieldEnum]


  export const StaStationsScalarFieldEnum: {
    stationID: 'stationID',
    security: 'security',
    dockingCostPerVolume: 'dockingCostPerVolume',
    maxShipVolumeDockable: 'maxShipVolumeDockable',
    officeRentalCost: 'officeRentalCost',
    operationID: 'operationID',
    stationTypeID: 'stationTypeID',
    corporationID: 'corporationID',
    solarSystemID: 'solarSystemID',
    constellationID: 'constellationID',
    regionID: 'regionID',
    stationName: 'stationName',
    x: 'x',
    y: 'y',
    z: 'z',
    reprocessingEfficiency: 'reprocessingEfficiency',
    reprocessingStationsTake: 'reprocessingStationsTake',
    reprocessingHangarFlag: 'reprocessingHangarFlag'
  };

  export type StaStationsScalarFieldEnum = (typeof StaStationsScalarFieldEnum)[keyof typeof StaStationsScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TranslationTablesScalarFieldEnum: {
    sourceTable: 'sourceTable',
    destinationTable: 'destinationTable',
    translatedKey: 'translatedKey',
    tcGroupID: 'tcGroupID',
    tcID: 'tcID'
  };

  export type TranslationTablesScalarFieldEnum = (typeof TranslationTablesScalarFieldEnum)[keyof typeof TranslationTablesScalarFieldEnum]


  export const TrnTranslationColumnsScalarFieldEnum: {
    tcGroupID: 'tcGroupID',
    tcID: 'tcID',
    tableName: 'tableName',
    columnName: 'columnName',
    masterID: 'masterID'
  };

  export type TrnTranslationColumnsScalarFieldEnum = (typeof TrnTranslationColumnsScalarFieldEnum)[keyof typeof TrnTranslationColumnsScalarFieldEnum]


  export const TrnTranslationLanguagesScalarFieldEnum: {
    numericLanguageID: 'numericLanguageID',
    languageID: 'languageID',
    languageName: 'languageName'
  };

  export type TrnTranslationLanguagesScalarFieldEnum = (typeof TrnTranslationLanguagesScalarFieldEnum)[keyof typeof TrnTranslationLanguagesScalarFieldEnum]


  export const TrnTranslationsScalarFieldEnum: {
    tcID: 'tcID',
    keyID: 'keyID',
    languageID: 'languageID',
    text: 'text'
  };

  export type TrnTranslationsScalarFieldEnum = (typeof TrnTranslationsScalarFieldEnum)[keyof typeof TrnTranslationsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WarCombatZoneSystemsScalarFieldEnum: {
    solarSystemID: 'solarSystemID',
    combatZoneID: 'combatZoneID'
  };

  export type WarCombatZoneSystemsScalarFieldEnum = (typeof WarCombatZoneSystemsScalarFieldEnum)[keyof typeof WarCombatZoneSystemsScalarFieldEnum]


  export const WarCombatZonesScalarFieldEnum: {
    combatZoneID: 'combatZoneID',
    combatZoneName: 'combatZoneName',
    factionID: 'factionID',
    centerSystemID: 'centerSystemID',
    description: 'description'
  };

  export type WarCombatZonesScalarFieldEnum = (typeof WarCombatZonesScalarFieldEnum)[keyof typeof WarCombatZonesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    status?: EnumUserStatusFilter | UserStatus
    characters?: CharacterListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    status?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    username?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    status?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    status?: EnumUserStatusWithAggregatesFilter | UserStatus
  }

  export type CharacterWhereInput = {
    AND?: Enumerable<CharacterWhereInput>
    OR?: Enumerable<CharacterWhereInput>
    NOT?: Enumerable<CharacterWhereInput>
    id?: IntFilter | number
    esiId?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    accessToken?: StringFilter | string
    refreshToken?: StringFilter | string
    tokenExpiresAt?: IntFilter | number
    allianceId?: IntNullableFilter | number | null
    ancestryId?: IntNullableFilter | number | null
    birthday?: DateTimeFilter | Date | string
    bloodlineId?: IntFilter | number
    corporationId?: IntFilter | number
    description?: StringNullableFilter | string | null
    factionId?: IntNullableFilter | number | null
    gender?: StringFilter | string
    name?: StringFilter | string
    raceId?: IntFilter | number
    scopes?: StringFilter | string
    securityStatus?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableFilter | string | null
    totalSp?: BigIntNullableFilter | bigint | number | null
    ownerId?: IntFilter | number
    owner?: XOR<UserRelationFilter, UserWhereInput>
    corporation?: XOR<CorporationRelationFilter, CorporationWhereInput>
    alliance?: XOR<AllianceRelationFilter, AllianceWhereInput> | null
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    esiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    birthday?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    gender?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    scopes?: SortOrder
    securityStatus?: SortOrder
    title?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
    owner?: UserOrderByWithRelationInput
    corporation?: CorporationOrderByWithRelationInput
    alliance?: AllianceOrderByWithRelationInput
  }

  export type CharacterWhereUniqueInput = {
    id?: number
  }

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    esiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    birthday?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    gender?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    scopes?: SortOrder
    securityStatus?: SortOrder
    title?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CharacterScalarWhereWithAggregatesInput>
    OR?: Enumerable<CharacterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CharacterScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    esiId?: BigIntWithAggregatesFilter | bigint | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    accessToken?: StringWithAggregatesFilter | string
    refreshToken?: StringWithAggregatesFilter | string
    tokenExpiresAt?: IntWithAggregatesFilter | number
    allianceId?: IntNullableWithAggregatesFilter | number | null
    ancestryId?: IntNullableWithAggregatesFilter | number | null
    birthday?: DateTimeWithAggregatesFilter | Date | string
    bloodlineId?: IntWithAggregatesFilter | number
    corporationId?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    factionId?: IntNullableWithAggregatesFilter | number | null
    gender?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    raceId?: IntWithAggregatesFilter | number
    scopes?: StringWithAggregatesFilter | string
    securityStatus?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    totalSp?: BigIntNullableWithAggregatesFilter | bigint | number | null
    ownerId?: IntWithAggregatesFilter | number
  }

  export type AllianceWhereInput = {
    AND?: Enumerable<AllianceWhereInput>
    OR?: Enumerable<AllianceWhereInput>
    NOT?: Enumerable<AllianceWhereInput>
    id?: IntFilter | number
    creatorCorporationId?: IntFilter | number
    creatorId?: IntFilter | number
    name?: StringFilter | string
    dateFounded?: DateTimeFilter | Date | string
    executorCorporationId?: IntNullableFilter | number | null
    factionId?: IntNullableFilter | number | null
    ticker?: StringFilter | string
    Corporation?: CorporationListRelationFilter
    Character?: CharacterListRelationFilter
  }

  export type AllianceOrderByWithRelationInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    dateFounded?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
    ticker?: SortOrder
    Corporation?: CorporationOrderByRelationAggregateInput
    Character?: CharacterOrderByRelationAggregateInput
  }

  export type AllianceWhereUniqueInput = {
    id?: number
  }

  export type AllianceOrderByWithAggregationInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    dateFounded?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
    ticker?: SortOrder
    _count?: AllianceCountOrderByAggregateInput
    _avg?: AllianceAvgOrderByAggregateInput
    _max?: AllianceMaxOrderByAggregateInput
    _min?: AllianceMinOrderByAggregateInput
    _sum?: AllianceSumOrderByAggregateInput
  }

  export type AllianceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AllianceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AllianceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AllianceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    creatorCorporationId?: IntWithAggregatesFilter | number
    creatorId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    dateFounded?: DateTimeWithAggregatesFilter | Date | string
    executorCorporationId?: IntNullableWithAggregatesFilter | number | null
    factionId?: IntNullableWithAggregatesFilter | number | null
    ticker?: StringWithAggregatesFilter | string
  }

  export type CorporationWhereInput = {
    AND?: Enumerable<CorporationWhereInput>
    OR?: Enumerable<CorporationWhereInput>
    NOT?: Enumerable<CorporationWhereInput>
    id?: IntFilter | number
    allianceId?: IntNullableFilter | number | null
    alliance?: XOR<AllianceRelationFilter, AllianceWhereInput> | null
    ceoId?: IntFilter | number
    creatorId?: IntFilter | number
    dateFounded?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    factionId?: IntNullableFilter | number | null
    homeStationId?: IntNullableFilter | number | null
    memberCount?: IntFilter | number
    name?: StringFilter | string
    shares?: IntNullableFilter | number | null
    taxRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    ticker?: StringFilter | string
    url?: StringNullableFilter | string | null
    warEligible?: BoolFilter | boolean
    Character?: CharacterListRelationFilter
  }

  export type CorporationOrderByWithRelationInput = {
    id?: SortOrder
    allianceId?: SortOrder
    alliance?: AllianceOrderByWithRelationInput
    ceoId?: SortOrder
    creatorId?: SortOrder
    dateFounded?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    name?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
    ticker?: SortOrder
    url?: SortOrder
    warEligible?: SortOrder
    Character?: CharacterOrderByRelationAggregateInput
  }

  export type CorporationWhereUniqueInput = {
    id?: number
  }

  export type CorporationOrderByWithAggregationInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    dateFounded?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    name?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
    ticker?: SortOrder
    url?: SortOrder
    warEligible?: SortOrder
    _count?: CorporationCountOrderByAggregateInput
    _avg?: CorporationAvgOrderByAggregateInput
    _max?: CorporationMaxOrderByAggregateInput
    _min?: CorporationMinOrderByAggregateInput
    _sum?: CorporationSumOrderByAggregateInput
  }

  export type CorporationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CorporationScalarWhereWithAggregatesInput>
    OR?: Enumerable<CorporationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CorporationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    allianceId?: IntNullableWithAggregatesFilter | number | null
    ceoId?: IntWithAggregatesFilter | number
    creatorId?: IntWithAggregatesFilter | number
    dateFounded?: DateTimeNullableWithAggregatesFilter | Date | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    factionId?: IntNullableWithAggregatesFilter | number | null
    homeStationId?: IntNullableWithAggregatesFilter | number | null
    memberCount?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    shares?: IntNullableWithAggregatesFilter | number | null
    taxRate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    ticker?: StringWithAggregatesFilter | string
    url?: StringNullableWithAggregatesFilter | string | null
    warEligible?: BoolWithAggregatesFilter | boolean
  }

  export type agtAgentTypesWhereInput = {
    AND?: Enumerable<agtAgentTypesWhereInput>
    OR?: Enumerable<agtAgentTypesWhereInput>
    NOT?: Enumerable<agtAgentTypesWhereInput>
    agentTypeID?: IntFilter | number
    agentType?: StringNullableFilter | string | null
  }

  export type agtAgentTypesOrderByWithRelationInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesWhereUniqueInput = {
    agentTypeID?: number
  }

  export type agtAgentTypesOrderByWithAggregationInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
    _count?: agtAgentTypesCountOrderByAggregateInput
    _avg?: agtAgentTypesAvgOrderByAggregateInput
    _max?: agtAgentTypesMaxOrderByAggregateInput
    _min?: agtAgentTypesMinOrderByAggregateInput
    _sum?: agtAgentTypesSumOrderByAggregateInput
  }

  export type agtAgentTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<agtAgentTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<agtAgentTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<agtAgentTypesScalarWhereWithAggregatesInput>
    agentTypeID?: IntWithAggregatesFilter | number
    agentType?: StringNullableWithAggregatesFilter | string | null
  }

  export type agtAgentsWhereInput = {
    AND?: Enumerable<agtAgentsWhereInput>
    OR?: Enumerable<agtAgentsWhereInput>
    NOT?: Enumerable<agtAgentsWhereInput>
    agentID?: IntFilter | number
    divisionID?: IntNullableFilter | number | null
    corporationID?: IntNullableFilter | number | null
    locationID?: IntNullableFilter | number | null
    level?: IntNullableFilter | number | null
    quality?: IntNullableFilter | number | null
    agentTypeID?: IntNullableFilter | number | null
    isLocator?: BoolNullableFilter | boolean | null
  }

  export type agtAgentsOrderByWithRelationInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsWhereUniqueInput = {
    agentID?: number
  }

  export type agtAgentsOrderByWithAggregationInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
    _count?: agtAgentsCountOrderByAggregateInput
    _avg?: agtAgentsAvgOrderByAggregateInput
    _max?: agtAgentsMaxOrderByAggregateInput
    _min?: agtAgentsMinOrderByAggregateInput
    _sum?: agtAgentsSumOrderByAggregateInput
  }

  export type agtAgentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<agtAgentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<agtAgentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<agtAgentsScalarWhereWithAggregatesInput>
    agentID?: IntWithAggregatesFilter | number
    divisionID?: IntNullableWithAggregatesFilter | number | null
    corporationID?: IntNullableWithAggregatesFilter | number | null
    locationID?: IntNullableWithAggregatesFilter | number | null
    level?: IntNullableWithAggregatesFilter | number | null
    quality?: IntNullableWithAggregatesFilter | number | null
    agentTypeID?: IntNullableWithAggregatesFilter | number | null
    isLocator?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type agtAgentsInSpaceWhereInput = {
    AND?: Enumerable<agtAgentsInSpaceWhereInput>
    OR?: Enumerable<agtAgentsInSpaceWhereInput>
    NOT?: Enumerable<agtAgentsInSpaceWhereInput>
    agentID?: IntFilter | number
    dungeonID?: IntNullableFilter | number | null
    solarSystemID?: IntNullableFilter | number | null
    spawnPointID?: IntNullableFilter | number | null
    typeID?: IntNullableFilter | number | null
  }

  export type agtAgentsInSpaceOrderByWithRelationInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceWhereUniqueInput = {
    agentID?: number
  }

  export type agtAgentsInSpaceOrderByWithAggregationInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
    _count?: agtAgentsInSpaceCountOrderByAggregateInput
    _avg?: agtAgentsInSpaceAvgOrderByAggregateInput
    _max?: agtAgentsInSpaceMaxOrderByAggregateInput
    _min?: agtAgentsInSpaceMinOrderByAggregateInput
    _sum?: agtAgentsInSpaceSumOrderByAggregateInput
  }

  export type agtAgentsInSpaceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<agtAgentsInSpaceScalarWhereWithAggregatesInput>
    OR?: Enumerable<agtAgentsInSpaceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<agtAgentsInSpaceScalarWhereWithAggregatesInput>
    agentID?: IntWithAggregatesFilter | number
    dungeonID?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    spawnPointID?: IntNullableWithAggregatesFilter | number | null
    typeID?: IntNullableWithAggregatesFilter | number | null
  }

  export type agtResearchAgentsWhereInput = {
    AND?: Enumerable<agtResearchAgentsWhereInput>
    OR?: Enumerable<agtResearchAgentsWhereInput>
    NOT?: Enumerable<agtResearchAgentsWhereInput>
    agentID?: IntFilter | number
    typeID?: IntFilter | number
  }

  export type agtResearchAgentsOrderByWithRelationInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsWhereUniqueInput = {
    agentID_typeID?: agtResearchAgentsAgentIDTypeIDCompoundUniqueInput
  }

  export type agtResearchAgentsOrderByWithAggregationInput = {
    agentID?: SortOrder
    typeID?: SortOrder
    _count?: agtResearchAgentsCountOrderByAggregateInput
    _avg?: agtResearchAgentsAvgOrderByAggregateInput
    _max?: agtResearchAgentsMaxOrderByAggregateInput
    _min?: agtResearchAgentsMinOrderByAggregateInput
    _sum?: agtResearchAgentsSumOrderByAggregateInput
  }

  export type agtResearchAgentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<agtResearchAgentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<agtResearchAgentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<agtResearchAgentsScalarWhereWithAggregatesInput>
    agentID?: IntWithAggregatesFilter | number
    typeID?: IntWithAggregatesFilter | number
  }

  export type certCertsWhereInput = {
    AND?: Enumerable<certCertsWhereInput>
    OR?: Enumerable<certCertsWhereInput>
    NOT?: Enumerable<certCertsWhereInput>
    certID?: IntFilter | number
    description?: StringNullableFilter | string | null
    groupID?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
  }

  export type certCertsOrderByWithRelationInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsWhereUniqueInput = {
    certID?: number
  }

  export type certCertsOrderByWithAggregationInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
    _count?: certCertsCountOrderByAggregateInput
    _avg?: certCertsAvgOrderByAggregateInput
    _max?: certCertsMaxOrderByAggregateInput
    _min?: certCertsMinOrderByAggregateInput
    _sum?: certCertsSumOrderByAggregateInput
  }

  export type certCertsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<certCertsScalarWhereWithAggregatesInput>
    OR?: Enumerable<certCertsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<certCertsScalarWhereWithAggregatesInput>
    certID?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    groupID?: IntNullableWithAggregatesFilter | number | null
    name?: StringNullableWithAggregatesFilter | string | null
  }

  export type chrAncestriesWhereInput = {
    AND?: Enumerable<chrAncestriesWhereInput>
    OR?: Enumerable<chrAncestriesWhereInput>
    NOT?: Enumerable<chrAncestriesWhereInput>
    ancestryID?: IntFilter | number
    ancestryName?: StringNullableFilter | string | null
    bloodlineID?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    perception?: IntNullableFilter | number | null
    willpower?: IntNullableFilter | number | null
    charisma?: IntNullableFilter | number | null
    memory?: IntNullableFilter | number | null
    intelligence?: IntNullableFilter | number | null
    iconID?: IntNullableFilter | number | null
    shortDescription?: StringNullableFilter | string | null
  }

  export type chrAncestriesOrderByWithRelationInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesWhereUniqueInput = {
    ancestryID?: number
  }

  export type chrAncestriesOrderByWithAggregationInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    _count?: chrAncestriesCountOrderByAggregateInput
    _avg?: chrAncestriesAvgOrderByAggregateInput
    _max?: chrAncestriesMaxOrderByAggregateInput
    _min?: chrAncestriesMinOrderByAggregateInput
    _sum?: chrAncestriesSumOrderByAggregateInput
  }

  export type chrAncestriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<chrAncestriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<chrAncestriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<chrAncestriesScalarWhereWithAggregatesInput>
    ancestryID?: IntWithAggregatesFilter | number
    ancestryName?: StringNullableWithAggregatesFilter | string | null
    bloodlineID?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    perception?: IntNullableWithAggregatesFilter | number | null
    willpower?: IntNullableWithAggregatesFilter | number | null
    charisma?: IntNullableWithAggregatesFilter | number | null
    memory?: IntNullableWithAggregatesFilter | number | null
    intelligence?: IntNullableWithAggregatesFilter | number | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    shortDescription?: StringNullableWithAggregatesFilter | string | null
  }

  export type chrAttributesWhereInput = {
    AND?: Enumerable<chrAttributesWhereInput>
    OR?: Enumerable<chrAttributesWhereInput>
    NOT?: Enumerable<chrAttributesWhereInput>
    attributeID?: IntFilter | number
    attributeName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    shortDescription?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
  }

  export type chrAttributesOrderByWithRelationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesWhereUniqueInput = {
    attributeID?: number
  }

  export type chrAttributesOrderByWithAggregationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
    _count?: chrAttributesCountOrderByAggregateInput
    _avg?: chrAttributesAvgOrderByAggregateInput
    _max?: chrAttributesMaxOrderByAggregateInput
    _min?: chrAttributesMinOrderByAggregateInput
    _sum?: chrAttributesSumOrderByAggregateInput
  }

  export type chrAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<chrAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<chrAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<chrAttributesScalarWhereWithAggregatesInput>
    attributeID?: IntWithAggregatesFilter | number
    attributeName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    shortDescription?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type chrBloodlinesWhereInput = {
    AND?: Enumerable<chrBloodlinesWhereInput>
    OR?: Enumerable<chrBloodlinesWhereInput>
    NOT?: Enumerable<chrBloodlinesWhereInput>
    bloodlineID?: IntFilter | number
    bloodlineName?: StringNullableFilter | string | null
    raceID?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    maleDescription?: StringNullableFilter | string | null
    femaleDescription?: StringNullableFilter | string | null
    shipTypeID?: IntNullableFilter | number | null
    corporationID?: IntNullableFilter | number | null
    perception?: IntNullableFilter | number | null
    willpower?: IntNullableFilter | number | null
    charisma?: IntNullableFilter | number | null
    memory?: IntNullableFilter | number | null
    intelligence?: IntNullableFilter | number | null
    iconID?: IntNullableFilter | number | null
    shortDescription?: StringNullableFilter | string | null
    shortMaleDescription?: StringNullableFilter | string | null
    shortFemaleDescription?: StringNullableFilter | string | null
  }

  export type chrBloodlinesOrderByWithRelationInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesWhereUniqueInput = {
    bloodlineID?: number
  }

  export type chrBloodlinesOrderByWithAggregationInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
    _count?: chrBloodlinesCountOrderByAggregateInput
    _avg?: chrBloodlinesAvgOrderByAggregateInput
    _max?: chrBloodlinesMaxOrderByAggregateInput
    _min?: chrBloodlinesMinOrderByAggregateInput
    _sum?: chrBloodlinesSumOrderByAggregateInput
  }

  export type chrBloodlinesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<chrBloodlinesScalarWhereWithAggregatesInput>
    OR?: Enumerable<chrBloodlinesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<chrBloodlinesScalarWhereWithAggregatesInput>
    bloodlineID?: IntWithAggregatesFilter | number
    bloodlineName?: StringNullableWithAggregatesFilter | string | null
    raceID?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    maleDescription?: StringNullableWithAggregatesFilter | string | null
    femaleDescription?: StringNullableWithAggregatesFilter | string | null
    shipTypeID?: IntNullableWithAggregatesFilter | number | null
    corporationID?: IntNullableWithAggregatesFilter | number | null
    perception?: IntNullableWithAggregatesFilter | number | null
    willpower?: IntNullableWithAggregatesFilter | number | null
    charisma?: IntNullableWithAggregatesFilter | number | null
    memory?: IntNullableWithAggregatesFilter | number | null
    intelligence?: IntNullableWithAggregatesFilter | number | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    shortDescription?: StringNullableWithAggregatesFilter | string | null
    shortMaleDescription?: StringNullableWithAggregatesFilter | string | null
    shortFemaleDescription?: StringNullableWithAggregatesFilter | string | null
  }

  export type chrFactionsWhereInput = {
    AND?: Enumerable<chrFactionsWhereInput>
    OR?: Enumerable<chrFactionsWhereInput>
    NOT?: Enumerable<chrFactionsWhereInput>
    factionID?: IntFilter | number
    factionName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    raceIDs?: IntNullableFilter | number | null
    solarSystemID?: IntNullableFilter | number | null
    corporationID?: IntNullableFilter | number | null
    sizeFactor?: FloatNullableFilter | number | null
    stationCount?: IntNullableFilter | number | null
    stationSystemCount?: IntNullableFilter | number | null
    militiaCorporationID?: IntNullableFilter | number | null
    iconID?: IntNullableFilter | number | null
  }

  export type chrFactionsOrderByWithRelationInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsWhereUniqueInput = {
    factionID?: number
  }

  export type chrFactionsOrderByWithAggregationInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
    _count?: chrFactionsCountOrderByAggregateInput
    _avg?: chrFactionsAvgOrderByAggregateInput
    _max?: chrFactionsMaxOrderByAggregateInput
    _min?: chrFactionsMinOrderByAggregateInput
    _sum?: chrFactionsSumOrderByAggregateInput
  }

  export type chrFactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<chrFactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<chrFactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<chrFactionsScalarWhereWithAggregatesInput>
    factionID?: IntWithAggregatesFilter | number
    factionName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    raceIDs?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    corporationID?: IntNullableWithAggregatesFilter | number | null
    sizeFactor?: FloatNullableWithAggregatesFilter | number | null
    stationCount?: IntNullableWithAggregatesFilter | number | null
    stationSystemCount?: IntNullableWithAggregatesFilter | number | null
    militiaCorporationID?: IntNullableWithAggregatesFilter | number | null
    iconID?: IntNullableWithAggregatesFilter | number | null
  }

  export type chrRacesWhereInput = {
    AND?: Enumerable<chrRacesWhereInput>
    OR?: Enumerable<chrRacesWhereInput>
    NOT?: Enumerable<chrRacesWhereInput>
    raceID?: IntFilter | number
    raceName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    shortDescription?: StringNullableFilter | string | null
  }

  export type chrRacesOrderByWithRelationInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesWhereUniqueInput = {
    raceID?: number
  }

  export type chrRacesOrderByWithAggregationInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    _count?: chrRacesCountOrderByAggregateInput
    _avg?: chrRacesAvgOrderByAggregateInput
    _max?: chrRacesMaxOrderByAggregateInput
    _min?: chrRacesMinOrderByAggregateInput
    _sum?: chrRacesSumOrderByAggregateInput
  }

  export type chrRacesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<chrRacesScalarWhereWithAggregatesInput>
    OR?: Enumerable<chrRacesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<chrRacesScalarWhereWithAggregatesInput>
    raceID?: IntWithAggregatesFilter | number
    raceName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    shortDescription?: StringNullableWithAggregatesFilter | string | null
  }

  export type crpActivitiesWhereInput = {
    AND?: Enumerable<crpActivitiesWhereInput>
    OR?: Enumerable<crpActivitiesWhereInput>
    NOT?: Enumerable<crpActivitiesWhereInput>
    activityID?: IntFilter | number
    activityName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type crpActivitiesOrderByWithRelationInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesWhereUniqueInput = {
    activityID?: number
  }

  export type crpActivitiesOrderByWithAggregationInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
    _count?: crpActivitiesCountOrderByAggregateInput
    _avg?: crpActivitiesAvgOrderByAggregateInput
    _max?: crpActivitiesMaxOrderByAggregateInput
    _min?: crpActivitiesMinOrderByAggregateInput
    _sum?: crpActivitiesSumOrderByAggregateInput
  }

  export type crpActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpActivitiesScalarWhereWithAggregatesInput>
    activityID?: IntWithAggregatesFilter | number
    activityName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type crpNPCCorporationDivisionsWhereInput = {
    AND?: Enumerable<crpNPCCorporationDivisionsWhereInput>
    OR?: Enumerable<crpNPCCorporationDivisionsWhereInput>
    NOT?: Enumerable<crpNPCCorporationDivisionsWhereInput>
    corporationID?: IntFilter | number
    divisionID?: IntFilter | number
    size?: IntNullableFilter | number | null
  }

  export type crpNPCCorporationDivisionsOrderByWithRelationInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsWhereUniqueInput = {
    corporationID_divisionID?: crpNPCCorporationDivisionsCorporationIDDivisionIDCompoundUniqueInput
  }

  export type crpNPCCorporationDivisionsOrderByWithAggregationInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
    _count?: crpNPCCorporationDivisionsCountOrderByAggregateInput
    _avg?: crpNPCCorporationDivisionsAvgOrderByAggregateInput
    _max?: crpNPCCorporationDivisionsMaxOrderByAggregateInput
    _min?: crpNPCCorporationDivisionsMinOrderByAggregateInput
    _sum?: crpNPCCorporationDivisionsSumOrderByAggregateInput
  }

  export type crpNPCCorporationDivisionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpNPCCorporationDivisionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpNPCCorporationDivisionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpNPCCorporationDivisionsScalarWhereWithAggregatesInput>
    corporationID?: IntWithAggregatesFilter | number
    divisionID?: IntWithAggregatesFilter | number
    size?: IntNullableWithAggregatesFilter | number | null
  }

  export type crpNPCCorporationResearchFieldsWhereInput = {
    AND?: Enumerable<crpNPCCorporationResearchFieldsWhereInput>
    OR?: Enumerable<crpNPCCorporationResearchFieldsWhereInput>
    NOT?: Enumerable<crpNPCCorporationResearchFieldsWhereInput>
    skillID?: IntFilter | number
    corporationID?: IntFilter | number
  }

  export type crpNPCCorporationResearchFieldsOrderByWithRelationInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsWhereUniqueInput = {
    skillID_corporationID?: crpNPCCorporationResearchFieldsSkillIDCorporationIDCompoundUniqueInput
  }

  export type crpNPCCorporationResearchFieldsOrderByWithAggregationInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
    _count?: crpNPCCorporationResearchFieldsCountOrderByAggregateInput
    _avg?: crpNPCCorporationResearchFieldsAvgOrderByAggregateInput
    _max?: crpNPCCorporationResearchFieldsMaxOrderByAggregateInput
    _min?: crpNPCCorporationResearchFieldsMinOrderByAggregateInput
    _sum?: crpNPCCorporationResearchFieldsSumOrderByAggregateInput
  }

  export type crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput>
    skillID?: IntWithAggregatesFilter | number
    corporationID?: IntWithAggregatesFilter | number
  }

  export type crpNPCCorporationTradesWhereInput = {
    AND?: Enumerable<crpNPCCorporationTradesWhereInput>
    OR?: Enumerable<crpNPCCorporationTradesWhereInput>
    NOT?: Enumerable<crpNPCCorporationTradesWhereInput>
    corporationID?: IntFilter | number
    typeID?: IntFilter | number
  }

  export type crpNPCCorporationTradesOrderByWithRelationInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesWhereUniqueInput = {
    corporationID_typeID?: crpNPCCorporationTradesCorporationIDTypeIDCompoundUniqueInput
  }

  export type crpNPCCorporationTradesOrderByWithAggregationInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
    _count?: crpNPCCorporationTradesCountOrderByAggregateInput
    _avg?: crpNPCCorporationTradesAvgOrderByAggregateInput
    _max?: crpNPCCorporationTradesMaxOrderByAggregateInput
    _min?: crpNPCCorporationTradesMinOrderByAggregateInput
    _sum?: crpNPCCorporationTradesSumOrderByAggregateInput
  }

  export type crpNPCCorporationTradesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpNPCCorporationTradesScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpNPCCorporationTradesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpNPCCorporationTradesScalarWhereWithAggregatesInput>
    corporationID?: IntWithAggregatesFilter | number
    typeID?: IntWithAggregatesFilter | number
  }

  export type crpNPCCorporationsWhereInput = {
    AND?: Enumerable<crpNPCCorporationsWhereInput>
    OR?: Enumerable<crpNPCCorporationsWhereInput>
    NOT?: Enumerable<crpNPCCorporationsWhereInput>
    corporationID?: IntFilter | number
    size?: StringNullableFilter | string | null
    extent?: StringNullableFilter | string | null
    solarSystemID?: IntNullableFilter | number | null
    investorID1?: IntNullableFilter | number | null
    investorShares1?: IntNullableFilter | number | null
    investorID2?: IntNullableFilter | number | null
    investorShares2?: IntNullableFilter | number | null
    investorID3?: IntNullableFilter | number | null
    investorShares3?: IntNullableFilter | number | null
    investorID4?: IntNullableFilter | number | null
    investorShares4?: IntNullableFilter | number | null
    friendID?: IntNullableFilter | number | null
    enemyID?: IntNullableFilter | number | null
    publicShares?: IntNullableFilter | number | null
    initialPrice?: IntNullableFilter | number | null
    minSecurity?: FloatNullableFilter | number | null
    scattered?: BoolNullableFilter | boolean | null
    fringe?: IntNullableFilter | number | null
    corridor?: IntNullableFilter | number | null
    hub?: IntNullableFilter | number | null
    border?: IntNullableFilter | number | null
    factionID?: IntNullableFilter | number | null
    sizeFactor?: FloatNullableFilter | number | null
    stationCount?: IntNullableFilter | number | null
    stationSystemCount?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
  }

  export type crpNPCCorporationsOrderByWithRelationInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsWhereUniqueInput = {
    corporationID?: number
  }

  export type crpNPCCorporationsOrderByWithAggregationInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    _count?: crpNPCCorporationsCountOrderByAggregateInput
    _avg?: crpNPCCorporationsAvgOrderByAggregateInput
    _max?: crpNPCCorporationsMaxOrderByAggregateInput
    _min?: crpNPCCorporationsMinOrderByAggregateInput
    _sum?: crpNPCCorporationsSumOrderByAggregateInput
  }

  export type crpNPCCorporationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpNPCCorporationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpNPCCorporationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpNPCCorporationsScalarWhereWithAggregatesInput>
    corporationID?: IntWithAggregatesFilter | number
    size?: StringNullableWithAggregatesFilter | string | null
    extent?: StringNullableWithAggregatesFilter | string | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    investorID1?: IntNullableWithAggregatesFilter | number | null
    investorShares1?: IntNullableWithAggregatesFilter | number | null
    investorID2?: IntNullableWithAggregatesFilter | number | null
    investorShares2?: IntNullableWithAggregatesFilter | number | null
    investorID3?: IntNullableWithAggregatesFilter | number | null
    investorShares3?: IntNullableWithAggregatesFilter | number | null
    investorID4?: IntNullableWithAggregatesFilter | number | null
    investorShares4?: IntNullableWithAggregatesFilter | number | null
    friendID?: IntNullableWithAggregatesFilter | number | null
    enemyID?: IntNullableWithAggregatesFilter | number | null
    publicShares?: IntNullableWithAggregatesFilter | number | null
    initialPrice?: IntNullableWithAggregatesFilter | number | null
    minSecurity?: FloatNullableWithAggregatesFilter | number | null
    scattered?: BoolNullableWithAggregatesFilter | boolean | null
    fringe?: IntNullableWithAggregatesFilter | number | null
    corridor?: IntNullableWithAggregatesFilter | number | null
    hub?: IntNullableWithAggregatesFilter | number | null
    border?: IntNullableWithAggregatesFilter | number | null
    factionID?: IntNullableWithAggregatesFilter | number | null
    sizeFactor?: FloatNullableWithAggregatesFilter | number | null
    stationCount?: IntNullableWithAggregatesFilter | number | null
    stationSystemCount?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
  }

  export type crpNPCDivisionsWhereInput = {
    AND?: Enumerable<crpNPCDivisionsWhereInput>
    OR?: Enumerable<crpNPCDivisionsWhereInput>
    NOT?: Enumerable<crpNPCDivisionsWhereInput>
    divisionID?: IntFilter | number
    divisionName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    leaderType?: StringNullableFilter | string | null
  }

  export type crpNPCDivisionsOrderByWithRelationInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsWhereUniqueInput = {
    divisionID?: number
  }

  export type crpNPCDivisionsOrderByWithAggregationInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
    _count?: crpNPCDivisionsCountOrderByAggregateInput
    _avg?: crpNPCDivisionsAvgOrderByAggregateInput
    _max?: crpNPCDivisionsMaxOrderByAggregateInput
    _min?: crpNPCDivisionsMinOrderByAggregateInput
    _sum?: crpNPCDivisionsSumOrderByAggregateInput
  }

  export type crpNPCDivisionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<crpNPCDivisionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<crpNPCDivisionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<crpNPCDivisionsScalarWhereWithAggregatesInput>
    divisionID?: IntWithAggregatesFilter | number
    divisionName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    leaderType?: StringNullableWithAggregatesFilter | string | null
  }

  export type dgmAttributeCategoriesWhereInput = {
    AND?: Enumerable<dgmAttributeCategoriesWhereInput>
    OR?: Enumerable<dgmAttributeCategoriesWhereInput>
    NOT?: Enumerable<dgmAttributeCategoriesWhereInput>
    categoryID?: IntFilter | number
    categoryName?: StringNullableFilter | string | null
    categoryDescription?: StringNullableFilter | string | null
  }

  export type dgmAttributeCategoriesOrderByWithRelationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesWhereUniqueInput = {
    categoryID?: number
  }

  export type dgmAttributeCategoriesOrderByWithAggregationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
    _count?: dgmAttributeCategoriesCountOrderByAggregateInput
    _avg?: dgmAttributeCategoriesAvgOrderByAggregateInput
    _max?: dgmAttributeCategoriesMaxOrderByAggregateInput
    _min?: dgmAttributeCategoriesMinOrderByAggregateInput
    _sum?: dgmAttributeCategoriesSumOrderByAggregateInput
  }

  export type dgmAttributeCategoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmAttributeCategoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmAttributeCategoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmAttributeCategoriesScalarWhereWithAggregatesInput>
    categoryID?: IntWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    categoryDescription?: StringNullableWithAggregatesFilter | string | null
  }

  export type dgmAttributeTypesWhereInput = {
    AND?: Enumerable<dgmAttributeTypesWhereInput>
    OR?: Enumerable<dgmAttributeTypesWhereInput>
    NOT?: Enumerable<dgmAttributeTypesWhereInput>
    attributeID?: IntFilter | number
    attributeName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    defaultValue?: FloatNullableFilter | number | null
    published?: BoolNullableFilter | boolean | null
    displayName?: StringNullableFilter | string | null
    unitID?: IntNullableFilter | number | null
    stackable?: BoolNullableFilter | boolean | null
    highIsGood?: BoolNullableFilter | boolean | null
    categoryID?: IntNullableFilter | number | null
  }

  export type dgmAttributeTypesOrderByWithRelationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesWhereUniqueInput = {
    attributeID?: number
  }

  export type dgmAttributeTypesOrderByWithAggregationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
    _count?: dgmAttributeTypesCountOrderByAggregateInput
    _avg?: dgmAttributeTypesAvgOrderByAggregateInput
    _max?: dgmAttributeTypesMaxOrderByAggregateInput
    _min?: dgmAttributeTypesMinOrderByAggregateInput
    _sum?: dgmAttributeTypesSumOrderByAggregateInput
  }

  export type dgmAttributeTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmAttributeTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmAttributeTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmAttributeTypesScalarWhereWithAggregatesInput>
    attributeID?: IntWithAggregatesFilter | number
    attributeName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    defaultValue?: FloatNullableWithAggregatesFilter | number | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
    displayName?: StringNullableWithAggregatesFilter | string | null
    unitID?: IntNullableWithAggregatesFilter | number | null
    stackable?: BoolNullableWithAggregatesFilter | boolean | null
    highIsGood?: BoolNullableWithAggregatesFilter | boolean | null
    categoryID?: IntNullableWithAggregatesFilter | number | null
  }

  export type dgmEffectsWhereInput = {
    AND?: Enumerable<dgmEffectsWhereInput>
    OR?: Enumerable<dgmEffectsWhereInput>
    NOT?: Enumerable<dgmEffectsWhereInput>
    effectID?: IntFilter | number
    effectName?: StringNullableFilter | string | null
    effectCategory?: IntNullableFilter | number | null
    preExpression?: IntNullableFilter | number | null
    postExpression?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    guid?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    isOffensive?: BoolNullableFilter | boolean | null
    isAssistance?: BoolNullableFilter | boolean | null
    durationAttributeID?: IntNullableFilter | number | null
    trackingSpeedAttributeID?: IntNullableFilter | number | null
    dischargeAttributeID?: IntNullableFilter | number | null
    rangeAttributeID?: IntNullableFilter | number | null
    falloffAttributeID?: IntNullableFilter | number | null
    disallowAutoRepeat?: BoolNullableFilter | boolean | null
    published?: BoolNullableFilter | boolean | null
    displayName?: StringNullableFilter | string | null
    isWarpSafe?: BoolNullableFilter | boolean | null
    rangeChance?: BoolNullableFilter | boolean | null
    electronicChance?: BoolNullableFilter | boolean | null
    propulsionChance?: BoolNullableFilter | boolean | null
    distribution?: IntNullableFilter | number | null
    sfxName?: StringNullableFilter | string | null
    npcUsageChanceAttributeID?: IntNullableFilter | number | null
    npcActivationChanceAttributeID?: IntNullableFilter | number | null
    fittingUsageChanceAttributeID?: IntNullableFilter | number | null
    modifierInfo?: StringNullableFilter | string | null
  }

  export type dgmEffectsOrderByWithRelationInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsWhereUniqueInput = {
    effectID?: number
  }

  export type dgmEffectsOrderByWithAggregationInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
    _count?: dgmEffectsCountOrderByAggregateInput
    _avg?: dgmEffectsAvgOrderByAggregateInput
    _max?: dgmEffectsMaxOrderByAggregateInput
    _min?: dgmEffectsMinOrderByAggregateInput
    _sum?: dgmEffectsSumOrderByAggregateInput
  }

  export type dgmEffectsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmEffectsScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmEffectsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmEffectsScalarWhereWithAggregatesInput>
    effectID?: IntWithAggregatesFilter | number
    effectName?: StringNullableWithAggregatesFilter | string | null
    effectCategory?: IntNullableWithAggregatesFilter | number | null
    preExpression?: IntNullableWithAggregatesFilter | number | null
    postExpression?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    guid?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    isOffensive?: BoolNullableWithAggregatesFilter | boolean | null
    isAssistance?: BoolNullableWithAggregatesFilter | boolean | null
    durationAttributeID?: IntNullableWithAggregatesFilter | number | null
    trackingSpeedAttributeID?: IntNullableWithAggregatesFilter | number | null
    dischargeAttributeID?: IntNullableWithAggregatesFilter | number | null
    rangeAttributeID?: IntNullableWithAggregatesFilter | number | null
    falloffAttributeID?: IntNullableWithAggregatesFilter | number | null
    disallowAutoRepeat?: BoolNullableWithAggregatesFilter | boolean | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
    displayName?: StringNullableWithAggregatesFilter | string | null
    isWarpSafe?: BoolNullableWithAggregatesFilter | boolean | null
    rangeChance?: BoolNullableWithAggregatesFilter | boolean | null
    electronicChance?: BoolNullableWithAggregatesFilter | boolean | null
    propulsionChance?: BoolNullableWithAggregatesFilter | boolean | null
    distribution?: IntNullableWithAggregatesFilter | number | null
    sfxName?: StringNullableWithAggregatesFilter | string | null
    npcUsageChanceAttributeID?: IntNullableWithAggregatesFilter | number | null
    npcActivationChanceAttributeID?: IntNullableWithAggregatesFilter | number | null
    fittingUsageChanceAttributeID?: IntNullableWithAggregatesFilter | number | null
    modifierInfo?: StringNullableWithAggregatesFilter | string | null
  }

  export type dgmExpressionsWhereInput = {
    AND?: Enumerable<dgmExpressionsWhereInput>
    OR?: Enumerable<dgmExpressionsWhereInput>
    NOT?: Enumerable<dgmExpressionsWhereInput>
    expressionID?: IntFilter | number
    operandID?: IntNullableFilter | number | null
    arg1?: IntNullableFilter | number | null
    arg2?: IntNullableFilter | number | null
    expressionValue?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    expressionName?: StringNullableFilter | string | null
    expressionTypeID?: IntNullableFilter | number | null
    expressionGroupID?: IntNullableFilter | number | null
    expressionAttributeID?: IntNullableFilter | number | null
  }

  export type dgmExpressionsOrderByWithRelationInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsWhereUniqueInput = {
    expressionID?: number
  }

  export type dgmExpressionsOrderByWithAggregationInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
    _count?: dgmExpressionsCountOrderByAggregateInput
    _avg?: dgmExpressionsAvgOrderByAggregateInput
    _max?: dgmExpressionsMaxOrderByAggregateInput
    _min?: dgmExpressionsMinOrderByAggregateInput
    _sum?: dgmExpressionsSumOrderByAggregateInput
  }

  export type dgmExpressionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmExpressionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmExpressionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmExpressionsScalarWhereWithAggregatesInput>
    expressionID?: IntWithAggregatesFilter | number
    operandID?: IntNullableWithAggregatesFilter | number | null
    arg1?: IntNullableWithAggregatesFilter | number | null
    arg2?: IntNullableWithAggregatesFilter | number | null
    expressionValue?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    expressionName?: StringNullableWithAggregatesFilter | string | null
    expressionTypeID?: IntNullableWithAggregatesFilter | number | null
    expressionGroupID?: IntNullableWithAggregatesFilter | number | null
    expressionAttributeID?: IntNullableWithAggregatesFilter | number | null
  }

  export type dgmTypeAttributesWhereInput = {
    AND?: Enumerable<dgmTypeAttributesWhereInput>
    OR?: Enumerable<dgmTypeAttributesWhereInput>
    NOT?: Enumerable<dgmTypeAttributesWhereInput>
    typeID?: IntFilter | number
    attributeID?: IntFilter | number
    valueInt?: IntNullableFilter | number | null
    valueFloat?: FloatNullableFilter | number | null
  }

  export type dgmTypeAttributesOrderByWithRelationInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesWhereUniqueInput = {
    typeID_attributeID?: dgmTypeAttributesTypeIDAttributeIDCompoundUniqueInput
  }

  export type dgmTypeAttributesOrderByWithAggregationInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
    _count?: dgmTypeAttributesCountOrderByAggregateInput
    _avg?: dgmTypeAttributesAvgOrderByAggregateInput
    _max?: dgmTypeAttributesMaxOrderByAggregateInput
    _min?: dgmTypeAttributesMinOrderByAggregateInput
    _sum?: dgmTypeAttributesSumOrderByAggregateInput
  }

  export type dgmTypeAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmTypeAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmTypeAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmTypeAttributesScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    attributeID?: IntWithAggregatesFilter | number
    valueInt?: IntNullableWithAggregatesFilter | number | null
    valueFloat?: FloatNullableWithAggregatesFilter | number | null
  }

  export type dgmTypeEffectsWhereInput = {
    AND?: Enumerable<dgmTypeEffectsWhereInput>
    OR?: Enumerable<dgmTypeEffectsWhereInput>
    NOT?: Enumerable<dgmTypeEffectsWhereInput>
    typeID?: IntFilter | number
    effectID?: IntFilter | number
    isDefault?: BoolNullableFilter | boolean | null
  }

  export type dgmTypeEffectsOrderByWithRelationInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsWhereUniqueInput = {
    typeID_effectID?: dgmTypeEffectsTypeIDEffectIDCompoundUniqueInput
  }

  export type dgmTypeEffectsOrderByWithAggregationInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
    _count?: dgmTypeEffectsCountOrderByAggregateInput
    _avg?: dgmTypeEffectsAvgOrderByAggregateInput
    _max?: dgmTypeEffectsMaxOrderByAggregateInput
    _min?: dgmTypeEffectsMinOrderByAggregateInput
    _sum?: dgmTypeEffectsSumOrderByAggregateInput
  }

  export type dgmTypeEffectsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dgmTypeEffectsScalarWhereWithAggregatesInput>
    OR?: Enumerable<dgmTypeEffectsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dgmTypeEffectsScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    effectID?: IntWithAggregatesFilter | number
    isDefault?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type eveGraphicsWhereInput = {
    AND?: Enumerable<eveGraphicsWhereInput>
    OR?: Enumerable<eveGraphicsWhereInput>
    NOT?: Enumerable<eveGraphicsWhereInput>
    graphicID?: IntFilter | number
    sofFactionName?: StringNullableFilter | string | null
    graphicFile?: StringNullableFilter | string | null
    sofHullName?: StringNullableFilter | string | null
    sofRaceName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type eveGraphicsOrderByWithRelationInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsWhereUniqueInput = {
    graphicID?: number
  }

  export type eveGraphicsOrderByWithAggregationInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
    _count?: eveGraphicsCountOrderByAggregateInput
    _avg?: eveGraphicsAvgOrderByAggregateInput
    _max?: eveGraphicsMaxOrderByAggregateInput
    _min?: eveGraphicsMinOrderByAggregateInput
    _sum?: eveGraphicsSumOrderByAggregateInput
  }

  export type eveGraphicsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eveGraphicsScalarWhereWithAggregatesInput>
    OR?: Enumerable<eveGraphicsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eveGraphicsScalarWhereWithAggregatesInput>
    graphicID?: IntWithAggregatesFilter | number
    sofFactionName?: StringNullableWithAggregatesFilter | string | null
    graphicFile?: StringNullableWithAggregatesFilter | string | null
    sofHullName?: StringNullableWithAggregatesFilter | string | null
    sofRaceName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type eveIconsWhereInput = {
    AND?: Enumerable<eveIconsWhereInput>
    OR?: Enumerable<eveIconsWhereInput>
    NOT?: Enumerable<eveIconsWhereInput>
    iconID?: IntFilter | number
    iconFile?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type eveIconsOrderByWithRelationInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsWhereUniqueInput = {
    iconID?: number
  }

  export type eveIconsOrderByWithAggregationInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
    _count?: eveIconsCountOrderByAggregateInput
    _avg?: eveIconsAvgOrderByAggregateInput
    _max?: eveIconsMaxOrderByAggregateInput
    _min?: eveIconsMinOrderByAggregateInput
    _sum?: eveIconsSumOrderByAggregateInput
  }

  export type eveIconsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eveIconsScalarWhereWithAggregatesInput>
    OR?: Enumerable<eveIconsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eveIconsScalarWhereWithAggregatesInput>
    iconID?: IntWithAggregatesFilter | number
    iconFile?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type eveUnitsWhereInput = {
    AND?: Enumerable<eveUnitsWhereInput>
    OR?: Enumerable<eveUnitsWhereInput>
    NOT?: Enumerable<eveUnitsWhereInput>
    unitID?: IntFilter | number
    unitName?: StringNullableFilter | string | null
    displayName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type eveUnitsOrderByWithRelationInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsWhereUniqueInput = {
    unitID?: number
  }

  export type eveUnitsOrderByWithAggregationInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    _count?: eveUnitsCountOrderByAggregateInput
    _avg?: eveUnitsAvgOrderByAggregateInput
    _max?: eveUnitsMaxOrderByAggregateInput
    _min?: eveUnitsMinOrderByAggregateInput
    _sum?: eveUnitsSumOrderByAggregateInput
  }

  export type eveUnitsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eveUnitsScalarWhereWithAggregatesInput>
    OR?: Enumerable<eveUnitsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eveUnitsScalarWhereWithAggregatesInput>
    unitID?: IntWithAggregatesFilter | number
    unitName?: StringNullableWithAggregatesFilter | string | null
    displayName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type industryActivityWhereInput = {
    AND?: Enumerable<industryActivityWhereInput>
    OR?: Enumerable<industryActivityWhereInput>
    NOT?: Enumerable<industryActivityWhereInput>
    typeID?: IntFilter | number
    activityID?: IntFilter | number
    time?: IntNullableFilter | number | null
  }

  export type industryActivityOrderByWithRelationInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityWhereUniqueInput = {
    typeID_activityID?: industryActivityTypeIDActivityIDCompoundUniqueInput
  }

  export type industryActivityOrderByWithAggregationInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
    _count?: industryActivityCountOrderByAggregateInput
    _avg?: industryActivityAvgOrderByAggregateInput
    _max?: industryActivityMaxOrderByAggregateInput
    _min?: industryActivityMinOrderByAggregateInput
    _sum?: industryActivitySumOrderByAggregateInput
  }

  export type industryActivityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<industryActivityScalarWhereWithAggregatesInput>
    OR?: Enumerable<industryActivityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<industryActivityScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    activityID?: IntWithAggregatesFilter | number
    time?: IntNullableWithAggregatesFilter | number | null
  }

  export type industryBlueprintsWhereInput = {
    AND?: Enumerable<industryBlueprintsWhereInput>
    OR?: Enumerable<industryBlueprintsWhereInput>
    NOT?: Enumerable<industryBlueprintsWhereInput>
    typeID?: IntFilter | number
    maxProductionLimit?: IntNullableFilter | number | null
  }

  export type industryBlueprintsOrderByWithRelationInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsWhereUniqueInput = {
    typeID?: number
  }

  export type industryBlueprintsOrderByWithAggregationInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
    _count?: industryBlueprintsCountOrderByAggregateInput
    _avg?: industryBlueprintsAvgOrderByAggregateInput
    _max?: industryBlueprintsMaxOrderByAggregateInput
    _min?: industryBlueprintsMinOrderByAggregateInput
    _sum?: industryBlueprintsSumOrderByAggregateInput
  }

  export type industryBlueprintsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<industryBlueprintsScalarWhereWithAggregatesInput>
    OR?: Enumerable<industryBlueprintsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<industryBlueprintsScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    maxProductionLimit?: IntNullableWithAggregatesFilter | number | null
  }

  export type invCategoriesWhereInput = {
    AND?: Enumerable<invCategoriesWhereInput>
    OR?: Enumerable<invCategoriesWhereInput>
    NOT?: Enumerable<invCategoriesWhereInput>
    categoryID?: IntFilter | number
    categoryName?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    published?: BoolNullableFilter | boolean | null
  }

  export type invCategoriesOrderByWithRelationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesWhereUniqueInput = {
    categoryID?: number
  }

  export type invCategoriesOrderByWithAggregationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
    _count?: invCategoriesCountOrderByAggregateInput
    _avg?: invCategoriesAvgOrderByAggregateInput
    _max?: invCategoriesMaxOrderByAggregateInput
    _min?: invCategoriesMinOrderByAggregateInput
    _sum?: invCategoriesSumOrderByAggregateInput
  }

  export type invCategoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invCategoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invCategoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invCategoriesScalarWhereWithAggregatesInput>
    categoryID?: IntWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type invContrabandTypesWhereInput = {
    AND?: Enumerable<invContrabandTypesWhereInput>
    OR?: Enumerable<invContrabandTypesWhereInput>
    NOT?: Enumerable<invContrabandTypesWhereInput>
    factionID?: IntFilter | number
    typeID?: IntFilter | number
    standingLoss?: FloatNullableFilter | number | null
    confiscateMinSec?: FloatNullableFilter | number | null
    fineByValue?: FloatNullableFilter | number | null
    attackMinSec?: FloatNullableFilter | number | null
  }

  export type invContrabandTypesOrderByWithRelationInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesWhereUniqueInput = {
    factionID_typeID?: invContrabandTypesFactionIDTypeIDCompoundUniqueInput
  }

  export type invContrabandTypesOrderByWithAggregationInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
    _count?: invContrabandTypesCountOrderByAggregateInput
    _avg?: invContrabandTypesAvgOrderByAggregateInput
    _max?: invContrabandTypesMaxOrderByAggregateInput
    _min?: invContrabandTypesMinOrderByAggregateInput
    _sum?: invContrabandTypesSumOrderByAggregateInput
  }

  export type invContrabandTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invContrabandTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invContrabandTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invContrabandTypesScalarWhereWithAggregatesInput>
    factionID?: IntWithAggregatesFilter | number
    typeID?: IntWithAggregatesFilter | number
    standingLoss?: FloatNullableWithAggregatesFilter | number | null
    confiscateMinSec?: FloatNullableWithAggregatesFilter | number | null
    fineByValue?: FloatNullableWithAggregatesFilter | number | null
    attackMinSec?: FloatNullableWithAggregatesFilter | number | null
  }

  export type invControlTowerResourcePurposesWhereInput = {
    AND?: Enumerable<invControlTowerResourcePurposesWhereInput>
    OR?: Enumerable<invControlTowerResourcePurposesWhereInput>
    NOT?: Enumerable<invControlTowerResourcePurposesWhereInput>
    purpose?: IntFilter | number
    purposeText?: StringNullableFilter | string | null
  }

  export type invControlTowerResourcePurposesOrderByWithRelationInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesWhereUniqueInput = {
    purpose?: number
  }

  export type invControlTowerResourcePurposesOrderByWithAggregationInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
    _count?: invControlTowerResourcePurposesCountOrderByAggregateInput
    _avg?: invControlTowerResourcePurposesAvgOrderByAggregateInput
    _max?: invControlTowerResourcePurposesMaxOrderByAggregateInput
    _min?: invControlTowerResourcePurposesMinOrderByAggregateInput
    _sum?: invControlTowerResourcePurposesSumOrderByAggregateInput
  }

  export type invControlTowerResourcePurposesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invControlTowerResourcePurposesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invControlTowerResourcePurposesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invControlTowerResourcePurposesScalarWhereWithAggregatesInput>
    purpose?: IntWithAggregatesFilter | number
    purposeText?: StringNullableWithAggregatesFilter | string | null
  }

  export type invControlTowerResourcesWhereInput = {
    AND?: Enumerable<invControlTowerResourcesWhereInput>
    OR?: Enumerable<invControlTowerResourcesWhereInput>
    NOT?: Enumerable<invControlTowerResourcesWhereInput>
    controlTowerTypeID?: IntFilter | number
    resourceTypeID?: IntFilter | number
    purpose?: IntNullableFilter | number | null
    quantity?: IntNullableFilter | number | null
    minSecurityLevel?: FloatNullableFilter | number | null
    factionID?: IntNullableFilter | number | null
  }

  export type invControlTowerResourcesOrderByWithRelationInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesWhereUniqueInput = {
    controlTowerTypeID_resourceTypeID?: invControlTowerResourcesControlTowerTypeIDResourceTypeIDCompoundUniqueInput
  }

  export type invControlTowerResourcesOrderByWithAggregationInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
    _count?: invControlTowerResourcesCountOrderByAggregateInput
    _avg?: invControlTowerResourcesAvgOrderByAggregateInput
    _max?: invControlTowerResourcesMaxOrderByAggregateInput
    _min?: invControlTowerResourcesMinOrderByAggregateInput
    _sum?: invControlTowerResourcesSumOrderByAggregateInput
  }

  export type invControlTowerResourcesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invControlTowerResourcesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invControlTowerResourcesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invControlTowerResourcesScalarWhereWithAggregatesInput>
    controlTowerTypeID?: IntWithAggregatesFilter | number
    resourceTypeID?: IntWithAggregatesFilter | number
    purpose?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntNullableWithAggregatesFilter | number | null
    minSecurityLevel?: FloatNullableWithAggregatesFilter | number | null
    factionID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invFlagsWhereInput = {
    AND?: Enumerable<invFlagsWhereInput>
    OR?: Enumerable<invFlagsWhereInput>
    NOT?: Enumerable<invFlagsWhereInput>
    flagID?: IntFilter | number
    flagName?: StringNullableFilter | string | null
    flagText?: StringNullableFilter | string | null
    orderID?: IntNullableFilter | number | null
  }

  export type invFlagsOrderByWithRelationInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsWhereUniqueInput = {
    flagID?: number
  }

  export type invFlagsOrderByWithAggregationInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
    _count?: invFlagsCountOrderByAggregateInput
    _avg?: invFlagsAvgOrderByAggregateInput
    _max?: invFlagsMaxOrderByAggregateInput
    _min?: invFlagsMinOrderByAggregateInput
    _sum?: invFlagsSumOrderByAggregateInput
  }

  export type invFlagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invFlagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invFlagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invFlagsScalarWhereWithAggregatesInput>
    flagID?: IntWithAggregatesFilter | number
    flagName?: StringNullableWithAggregatesFilter | string | null
    flagText?: StringNullableWithAggregatesFilter | string | null
    orderID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invGroupsWhereInput = {
    AND?: Enumerable<invGroupsWhereInput>
    OR?: Enumerable<invGroupsWhereInput>
    NOT?: Enumerable<invGroupsWhereInput>
    groupID?: IntFilter | number
    categoryID?: IntNullableFilter | number | null
    groupName?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    useBasePrice?: BoolNullableFilter | boolean | null
    anchored?: BoolNullableFilter | boolean | null
    anchorable?: BoolNullableFilter | boolean | null
    fittableNonSingleton?: BoolNullableFilter | boolean | null
    published?: BoolNullableFilter | boolean | null
  }

  export type invGroupsOrderByWithRelationInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsWhereUniqueInput = {
    groupID?: number
  }

  export type invGroupsOrderByWithAggregationInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
    _count?: invGroupsCountOrderByAggregateInput
    _avg?: invGroupsAvgOrderByAggregateInput
    _max?: invGroupsMaxOrderByAggregateInput
    _min?: invGroupsMinOrderByAggregateInput
    _sum?: invGroupsSumOrderByAggregateInput
  }

  export type invGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invGroupsScalarWhereWithAggregatesInput>
    groupID?: IntWithAggregatesFilter | number
    categoryID?: IntNullableWithAggregatesFilter | number | null
    groupName?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    useBasePrice?: BoolNullableWithAggregatesFilter | boolean | null
    anchored?: BoolNullableWithAggregatesFilter | boolean | null
    anchorable?: BoolNullableWithAggregatesFilter | boolean | null
    fittableNonSingleton?: BoolNullableWithAggregatesFilter | boolean | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type invItemsWhereInput = {
    AND?: Enumerable<invItemsWhereInput>
    OR?: Enumerable<invItemsWhereInput>
    NOT?: Enumerable<invItemsWhereInput>
    itemID?: IntFilter | number
    typeID?: IntFilter | number
    ownerID?: IntFilter | number
    locationID?: IntFilter | number
    flagID?: IntFilter | number
    quantity?: IntFilter | number
  }

  export type invItemsOrderByWithRelationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsWhereUniqueInput = {
    itemID?: number
  }

  export type invItemsOrderByWithAggregationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
    _count?: invItemsCountOrderByAggregateInput
    _avg?: invItemsAvgOrderByAggregateInput
    _max?: invItemsMaxOrderByAggregateInput
    _min?: invItemsMinOrderByAggregateInput
    _sum?: invItemsSumOrderByAggregateInput
  }

  export type invItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invItemsScalarWhereWithAggregatesInput>
    itemID?: IntWithAggregatesFilter | number
    typeID?: IntWithAggregatesFilter | number
    ownerID?: IntWithAggregatesFilter | number
    locationID?: IntWithAggregatesFilter | number
    flagID?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
  }

  export type invMarketGroupsWhereInput = {
    AND?: Enumerable<invMarketGroupsWhereInput>
    OR?: Enumerable<invMarketGroupsWhereInput>
    NOT?: Enumerable<invMarketGroupsWhereInput>
    marketGroupID?: IntFilter | number
    parentGroupID?: IntNullableFilter | number | null
    marketGroupName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
    hasTypes?: BoolNullableFilter | boolean | null
  }

  export type invMarketGroupsOrderByWithRelationInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsWhereUniqueInput = {
    marketGroupID?: number
  }

  export type invMarketGroupsOrderByWithAggregationInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
    _count?: invMarketGroupsCountOrderByAggregateInput
    _avg?: invMarketGroupsAvgOrderByAggregateInput
    _max?: invMarketGroupsMaxOrderByAggregateInput
    _min?: invMarketGroupsMinOrderByAggregateInput
    _sum?: invMarketGroupsSumOrderByAggregateInput
  }

  export type invMarketGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invMarketGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invMarketGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invMarketGroupsScalarWhereWithAggregatesInput>
    marketGroupID?: IntWithAggregatesFilter | number
    parentGroupID?: IntNullableWithAggregatesFilter | number | null
    marketGroupName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    hasTypes?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type invMetaGroupsWhereInput = {
    AND?: Enumerable<invMetaGroupsWhereInput>
    OR?: Enumerable<invMetaGroupsWhereInput>
    NOT?: Enumerable<invMetaGroupsWhereInput>
    metaGroupID?: IntFilter | number
    metaGroupName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    iconID?: IntNullableFilter | number | null
  }

  export type invMetaGroupsOrderByWithRelationInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsWhereUniqueInput = {
    metaGroupID?: number
  }

  export type invMetaGroupsOrderByWithAggregationInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    _count?: invMetaGroupsCountOrderByAggregateInput
    _avg?: invMetaGroupsAvgOrderByAggregateInput
    _max?: invMetaGroupsMaxOrderByAggregateInput
    _min?: invMetaGroupsMinOrderByAggregateInput
    _sum?: invMetaGroupsSumOrderByAggregateInput
  }

  export type invMetaGroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invMetaGroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invMetaGroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invMetaGroupsScalarWhereWithAggregatesInput>
    metaGroupID?: IntWithAggregatesFilter | number
    metaGroupName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    iconID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invMetaTypesWhereInput = {
    AND?: Enumerable<invMetaTypesWhereInput>
    OR?: Enumerable<invMetaTypesWhereInput>
    NOT?: Enumerable<invMetaTypesWhereInput>
    typeID?: IntFilter | number
    parentTypeID?: IntNullableFilter | number | null
    metaGroupID?: IntNullableFilter | number | null
  }

  export type invMetaTypesOrderByWithRelationInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesWhereUniqueInput = {
    typeID?: number
  }

  export type invMetaTypesOrderByWithAggregationInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
    _count?: invMetaTypesCountOrderByAggregateInput
    _avg?: invMetaTypesAvgOrderByAggregateInput
    _max?: invMetaTypesMaxOrderByAggregateInput
    _min?: invMetaTypesMinOrderByAggregateInput
    _sum?: invMetaTypesSumOrderByAggregateInput
  }

  export type invMetaTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invMetaTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invMetaTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invMetaTypesScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    parentTypeID?: IntNullableWithAggregatesFilter | number | null
    metaGroupID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invNamesWhereInput = {
    AND?: Enumerable<invNamesWhereInput>
    OR?: Enumerable<invNamesWhereInput>
    NOT?: Enumerable<invNamesWhereInput>
    itemID?: IntFilter | number
    itemName?: StringFilter | string
  }

  export type invNamesOrderByWithRelationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesWhereUniqueInput = {
    itemID?: number
  }

  export type invNamesOrderByWithAggregationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    _count?: invNamesCountOrderByAggregateInput
    _avg?: invNamesAvgOrderByAggregateInput
    _max?: invNamesMaxOrderByAggregateInput
    _min?: invNamesMinOrderByAggregateInput
    _sum?: invNamesSumOrderByAggregateInput
  }

  export type invNamesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invNamesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invNamesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invNamesScalarWhereWithAggregatesInput>
    itemID?: IntWithAggregatesFilter | number
    itemName?: StringWithAggregatesFilter | string
  }

  export type invPositionsWhereInput = {
    AND?: Enumerable<invPositionsWhereInput>
    OR?: Enumerable<invPositionsWhereInput>
    NOT?: Enumerable<invPositionsWhereInput>
    itemID?: IntFilter | number
    x?: FloatFilter | number
    y?: FloatFilter | number
    z?: FloatFilter | number
    yaw?: FloatNullableFilter | number | null
    pitch?: FloatNullableFilter | number | null
    roll?: FloatNullableFilter | number | null
  }

  export type invPositionsOrderByWithRelationInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsWhereUniqueInput = {
    itemID?: number
  }

  export type invPositionsOrderByWithAggregationInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
    _count?: invPositionsCountOrderByAggregateInput
    _avg?: invPositionsAvgOrderByAggregateInput
    _max?: invPositionsMaxOrderByAggregateInput
    _min?: invPositionsMinOrderByAggregateInput
    _sum?: invPositionsSumOrderByAggregateInput
  }

  export type invPositionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invPositionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invPositionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invPositionsScalarWhereWithAggregatesInput>
    itemID?: IntWithAggregatesFilter | number
    x?: FloatWithAggregatesFilter | number
    y?: FloatWithAggregatesFilter | number
    z?: FloatWithAggregatesFilter | number
    yaw?: FloatNullableWithAggregatesFilter | number | null
    pitch?: FloatNullableWithAggregatesFilter | number | null
    roll?: FloatNullableWithAggregatesFilter | number | null
  }

  export type invTraitsWhereInput = {
    AND?: Enumerable<invTraitsWhereInput>
    OR?: Enumerable<invTraitsWhereInput>
    NOT?: Enumerable<invTraitsWhereInput>
    traitID?: IntFilter | number
    typeID?: IntNullableFilter | number | null
    skillID?: IntNullableFilter | number | null
    bonus?: FloatNullableFilter | number | null
    bonusText?: StringNullableFilter | string | null
    unitID?: IntNullableFilter | number | null
  }

  export type invTraitsOrderByWithRelationInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsWhereUniqueInput = {
    traitID?: number
  }

  export type invTraitsOrderByWithAggregationInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
    _count?: invTraitsCountOrderByAggregateInput
    _avg?: invTraitsAvgOrderByAggregateInput
    _max?: invTraitsMaxOrderByAggregateInput
    _min?: invTraitsMinOrderByAggregateInput
    _sum?: invTraitsSumOrderByAggregateInput
  }

  export type invTraitsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invTraitsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invTraitsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invTraitsScalarWhereWithAggregatesInput>
    traitID?: IntWithAggregatesFilter | number
    typeID?: IntNullableWithAggregatesFilter | number | null
    skillID?: IntNullableWithAggregatesFilter | number | null
    bonus?: FloatNullableWithAggregatesFilter | number | null
    bonusText?: StringNullableWithAggregatesFilter | string | null
    unitID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invTypeMaterialsWhereInput = {
    AND?: Enumerable<invTypeMaterialsWhereInput>
    OR?: Enumerable<invTypeMaterialsWhereInput>
    NOT?: Enumerable<invTypeMaterialsWhereInput>
    typeID?: IntFilter | number
    materialTypeID?: IntFilter | number
    quantity?: IntFilter | number
  }

  export type invTypeMaterialsOrderByWithRelationInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsWhereUniqueInput = {
    typeID_materialTypeID?: invTypeMaterialsTypeIDMaterialTypeIDCompoundUniqueInput
  }

  export type invTypeMaterialsOrderByWithAggregationInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
    _count?: invTypeMaterialsCountOrderByAggregateInput
    _avg?: invTypeMaterialsAvgOrderByAggregateInput
    _max?: invTypeMaterialsMaxOrderByAggregateInput
    _min?: invTypeMaterialsMinOrderByAggregateInput
    _sum?: invTypeMaterialsSumOrderByAggregateInput
  }

  export type invTypeMaterialsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invTypeMaterialsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invTypeMaterialsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invTypeMaterialsScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    materialTypeID?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
  }

  export type invTypeReactionsWhereInput = {
    AND?: Enumerable<invTypeReactionsWhereInput>
    OR?: Enumerable<invTypeReactionsWhereInput>
    NOT?: Enumerable<invTypeReactionsWhereInput>
    reactionTypeID?: IntFilter | number
    input?: BoolFilter | boolean
    typeID?: IntFilter | number
    quantity?: IntNullableFilter | number | null
  }

  export type invTypeReactionsOrderByWithRelationInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsWhereUniqueInput = {
    reactionTypeID_input_typeID?: invTypeReactionsReactionTypeIDInputTypeIDCompoundUniqueInput
  }

  export type invTypeReactionsOrderByWithAggregationInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    _count?: invTypeReactionsCountOrderByAggregateInput
    _avg?: invTypeReactionsAvgOrderByAggregateInput
    _max?: invTypeReactionsMaxOrderByAggregateInput
    _min?: invTypeReactionsMinOrderByAggregateInput
    _sum?: invTypeReactionsSumOrderByAggregateInput
  }

  export type invTypeReactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invTypeReactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<invTypeReactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invTypeReactionsScalarWhereWithAggregatesInput>
    reactionTypeID?: IntWithAggregatesFilter | number
    input?: BoolWithAggregatesFilter | boolean
    typeID?: IntWithAggregatesFilter | number
    quantity?: IntNullableWithAggregatesFilter | number | null
  }

  export type invTypesWhereInput = {
    AND?: Enumerable<invTypesWhereInput>
    OR?: Enumerable<invTypesWhereInput>
    NOT?: Enumerable<invTypesWhereInput>
    typeID?: IntFilter | number
    groupID?: IntNullableFilter | number | null
    typeName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    mass?: FloatNullableFilter | number | null
    volume?: FloatNullableFilter | number | null
    capacity?: FloatNullableFilter | number | null
    portionSize?: IntNullableFilter | number | null
    raceID?: IntNullableFilter | number | null
    basePrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    published?: BoolNullableFilter | boolean | null
    marketGroupID?: IntNullableFilter | number | null
    iconID?: IntNullableFilter | number | null
    soundID?: IntNullableFilter | number | null
    graphicID?: IntNullableFilter | number | null
  }

  export type invTypesOrderByWithRelationInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesWhereUniqueInput = {
    typeID?: number
  }

  export type invTypesOrderByWithAggregationInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
    _count?: invTypesCountOrderByAggregateInput
    _avg?: invTypesAvgOrderByAggregateInput
    _max?: invTypesMaxOrderByAggregateInput
    _min?: invTypesMinOrderByAggregateInput
    _sum?: invTypesSumOrderByAggregateInput
  }

  export type invTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invTypesScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    groupID?: IntNullableWithAggregatesFilter | number | null
    typeName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    mass?: FloatNullableWithAggregatesFilter | number | null
    volume?: FloatNullableWithAggregatesFilter | number | null
    capacity?: FloatNullableWithAggregatesFilter | number | null
    portionSize?: IntNullableWithAggregatesFilter | number | null
    raceID?: IntNullableWithAggregatesFilter | number | null
    basePrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
    marketGroupID?: IntNullableWithAggregatesFilter | number | null
    iconID?: IntNullableWithAggregatesFilter | number | null
    soundID?: IntNullableWithAggregatesFilter | number | null
    graphicID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invUniqueNamesWhereInput = {
    AND?: Enumerable<invUniqueNamesWhereInput>
    OR?: Enumerable<invUniqueNamesWhereInput>
    NOT?: Enumerable<invUniqueNamesWhereInput>
    itemID?: IntFilter | number
    itemName?: StringFilter | string
    groupID?: IntNullableFilter | number | null
  }

  export type invUniqueNamesOrderByWithRelationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesWhereUniqueInput = {
    itemID?: number
    itemName?: string
  }

  export type invUniqueNamesOrderByWithAggregationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
    _count?: invUniqueNamesCountOrderByAggregateInput
    _avg?: invUniqueNamesAvgOrderByAggregateInput
    _max?: invUniqueNamesMaxOrderByAggregateInput
    _min?: invUniqueNamesMinOrderByAggregateInput
    _sum?: invUniqueNamesSumOrderByAggregateInput
  }

  export type invUniqueNamesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invUniqueNamesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invUniqueNamesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invUniqueNamesScalarWhereWithAggregatesInput>
    itemID?: IntWithAggregatesFilter | number
    itemName?: StringWithAggregatesFilter | string
    groupID?: IntNullableWithAggregatesFilter | number | null
  }

  export type invVolumesWhereInput = {
    AND?: Enumerable<invVolumesWhereInput>
    OR?: Enumerable<invVolumesWhereInput>
    NOT?: Enumerable<invVolumesWhereInput>
    typeID?: IntFilter | number
    volume?: IntNullableFilter | number | null
  }

  export type invVolumesOrderByWithRelationInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesWhereUniqueInput = {
    typeID?: number
  }

  export type invVolumesOrderByWithAggregationInput = {
    typeID?: SortOrder
    volume?: SortOrder
    _count?: invVolumesCountOrderByAggregateInput
    _avg?: invVolumesAvgOrderByAggregateInput
    _max?: invVolumesMaxOrderByAggregateInput
    _min?: invVolumesMinOrderByAggregateInput
    _sum?: invVolumesSumOrderByAggregateInput
  }

  export type invVolumesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<invVolumesScalarWhereWithAggregatesInput>
    OR?: Enumerable<invVolumesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<invVolumesScalarWhereWithAggregatesInput>
    typeID?: IntWithAggregatesFilter | number
    volume?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapCelestialGraphicsWhereInput = {
    AND?: Enumerable<mapCelestialGraphicsWhereInput>
    OR?: Enumerable<mapCelestialGraphicsWhereInput>
    NOT?: Enumerable<mapCelestialGraphicsWhereInput>
    celestialID?: IntFilter | number
    heightMap1?: IntNullableFilter | number | null
    heightMap2?: IntNullableFilter | number | null
    shaderPreset?: IntNullableFilter | number | null
    population?: BoolNullableFilter | boolean | null
  }

  export type mapCelestialGraphicsOrderByWithRelationInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsWhereUniqueInput = {
    celestialID?: number
  }

  export type mapCelestialGraphicsOrderByWithAggregationInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
    _count?: mapCelestialGraphicsCountOrderByAggregateInput
    _avg?: mapCelestialGraphicsAvgOrderByAggregateInput
    _max?: mapCelestialGraphicsMaxOrderByAggregateInput
    _min?: mapCelestialGraphicsMinOrderByAggregateInput
    _sum?: mapCelestialGraphicsSumOrderByAggregateInput
  }

  export type mapCelestialGraphicsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapCelestialGraphicsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapCelestialGraphicsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapCelestialGraphicsScalarWhereWithAggregatesInput>
    celestialID?: IntWithAggregatesFilter | number
    heightMap1?: IntNullableWithAggregatesFilter | number | null
    heightMap2?: IntNullableWithAggregatesFilter | number | null
    shaderPreset?: IntNullableWithAggregatesFilter | number | null
    population?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type mapCelestialStatisticsWhereInput = {
    AND?: Enumerable<mapCelestialStatisticsWhereInput>
    OR?: Enumerable<mapCelestialStatisticsWhereInput>
    NOT?: Enumerable<mapCelestialStatisticsWhereInput>
    celestialID?: IntFilter | number
    temperature?: FloatNullableFilter | number | null
    spectralClass?: StringNullableFilter | string | null
    luminosity?: FloatNullableFilter | number | null
    age?: FloatNullableFilter | number | null
    life?: FloatNullableFilter | number | null
    orbitRadius?: FloatNullableFilter | number | null
    eccentricity?: FloatNullableFilter | number | null
    massDust?: FloatNullableFilter | number | null
    massGas?: FloatNullableFilter | number | null
    fragmented?: BoolNullableFilter | boolean | null
    density?: FloatNullableFilter | number | null
    surfaceGravity?: FloatNullableFilter | number | null
    escapeVelocity?: FloatNullableFilter | number | null
    orbitPeriod?: FloatNullableFilter | number | null
    rotationRate?: FloatNullableFilter | number | null
    locked?: BoolNullableFilter | boolean | null
    pressure?: FloatNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
    mass?: IntNullableFilter | number | null
  }

  export type mapCelestialStatisticsOrderByWithRelationInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsWhereUniqueInput = {
    celestialID?: number
  }

  export type mapCelestialStatisticsOrderByWithAggregationInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
    _count?: mapCelestialStatisticsCountOrderByAggregateInput
    _avg?: mapCelestialStatisticsAvgOrderByAggregateInput
    _max?: mapCelestialStatisticsMaxOrderByAggregateInput
    _min?: mapCelestialStatisticsMinOrderByAggregateInput
    _sum?: mapCelestialStatisticsSumOrderByAggregateInput
  }

  export type mapCelestialStatisticsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapCelestialStatisticsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapCelestialStatisticsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapCelestialStatisticsScalarWhereWithAggregatesInput>
    celestialID?: IntWithAggregatesFilter | number
    temperature?: FloatNullableWithAggregatesFilter | number | null
    spectralClass?: StringNullableWithAggregatesFilter | string | null
    luminosity?: FloatNullableWithAggregatesFilter | number | null
    age?: FloatNullableWithAggregatesFilter | number | null
    life?: FloatNullableWithAggregatesFilter | number | null
    orbitRadius?: FloatNullableWithAggregatesFilter | number | null
    eccentricity?: FloatNullableWithAggregatesFilter | number | null
    massDust?: FloatNullableWithAggregatesFilter | number | null
    massGas?: FloatNullableWithAggregatesFilter | number | null
    fragmented?: BoolNullableWithAggregatesFilter | boolean | null
    density?: FloatNullableWithAggregatesFilter | number | null
    surfaceGravity?: FloatNullableWithAggregatesFilter | number | null
    escapeVelocity?: FloatNullableWithAggregatesFilter | number | null
    orbitPeriod?: FloatNullableWithAggregatesFilter | number | null
    rotationRate?: FloatNullableWithAggregatesFilter | number | null
    locked?: BoolNullableWithAggregatesFilter | boolean | null
    pressure?: FloatNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
    mass?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapConstellationJumpsWhereInput = {
    AND?: Enumerable<mapConstellationJumpsWhereInput>
    OR?: Enumerable<mapConstellationJumpsWhereInput>
    NOT?: Enumerable<mapConstellationJumpsWhereInput>
    fromRegionID?: IntNullableFilter | number | null
    fromConstellationID?: IntFilter | number
    toConstellationID?: IntFilter | number
    toRegionID?: IntNullableFilter | number | null
  }

  export type mapConstellationJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsWhereUniqueInput = {
    fromConstellationID_toConstellationID?: mapConstellationJumpsFromConstellationIDToConstellationIDCompoundUniqueInput
  }

  export type mapConstellationJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
    _count?: mapConstellationJumpsCountOrderByAggregateInput
    _avg?: mapConstellationJumpsAvgOrderByAggregateInput
    _max?: mapConstellationJumpsMaxOrderByAggregateInput
    _min?: mapConstellationJumpsMinOrderByAggregateInput
    _sum?: mapConstellationJumpsSumOrderByAggregateInput
  }

  export type mapConstellationJumpsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapConstellationJumpsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapConstellationJumpsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapConstellationJumpsScalarWhereWithAggregatesInput>
    fromRegionID?: IntNullableWithAggregatesFilter | number | null
    fromConstellationID?: IntWithAggregatesFilter | number
    toConstellationID?: IntWithAggregatesFilter | number
    toRegionID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapConstellationsWhereInput = {
    AND?: Enumerable<mapConstellationsWhereInput>
    OR?: Enumerable<mapConstellationsWhereInput>
    NOT?: Enumerable<mapConstellationsWhereInput>
    regionID?: IntNullableFilter | number | null
    constellationID?: IntFilter | number
    constellationName?: StringNullableFilter | string | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    xMin?: FloatNullableFilter | number | null
    xMax?: FloatNullableFilter | number | null
    yMin?: FloatNullableFilter | number | null
    yMax?: FloatNullableFilter | number | null
    zMin?: FloatNullableFilter | number | null
    zMax?: FloatNullableFilter | number | null
    factionID?: IntNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
  }

  export type mapConstellationsOrderByWithRelationInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsWhereUniqueInput = {
    constellationID?: number
  }

  export type mapConstellationsOrderByWithAggregationInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    _count?: mapConstellationsCountOrderByAggregateInput
    _avg?: mapConstellationsAvgOrderByAggregateInput
    _max?: mapConstellationsMaxOrderByAggregateInput
    _min?: mapConstellationsMinOrderByAggregateInput
    _sum?: mapConstellationsSumOrderByAggregateInput
  }

  export type mapConstellationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapConstellationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapConstellationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapConstellationsScalarWhereWithAggregatesInput>
    regionID?: IntNullableWithAggregatesFilter | number | null
    constellationID?: IntWithAggregatesFilter | number
    constellationName?: StringNullableWithAggregatesFilter | string | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    xMin?: FloatNullableWithAggregatesFilter | number | null
    xMax?: FloatNullableWithAggregatesFilter | number | null
    yMin?: FloatNullableWithAggregatesFilter | number | null
    yMax?: FloatNullableWithAggregatesFilter | number | null
    zMin?: FloatNullableWithAggregatesFilter | number | null
    zMax?: FloatNullableWithAggregatesFilter | number | null
    factionID?: IntNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
  }

  export type mapDenormalizeWhereInput = {
    AND?: Enumerable<mapDenormalizeWhereInput>
    OR?: Enumerable<mapDenormalizeWhereInput>
    NOT?: Enumerable<mapDenormalizeWhereInput>
    itemID?: IntFilter | number
    typeID?: IntNullableFilter | number | null
    groupID?: IntNullableFilter | number | null
    solarSystemID?: IntNullableFilter | number | null
    constellationID?: IntNullableFilter | number | null
    regionID?: IntNullableFilter | number | null
    orbitID?: IntNullableFilter | number | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
    itemName?: StringNullableFilter | string | null
    security?: FloatNullableFilter | number | null
    celestialIndex?: IntNullableFilter | number | null
    orbitIndex?: IntNullableFilter | number | null
  }

  export type mapDenormalizeOrderByWithRelationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeWhereUniqueInput = {
    itemID?: number
  }

  export type mapDenormalizeOrderByWithAggregationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
    _count?: mapDenormalizeCountOrderByAggregateInput
    _avg?: mapDenormalizeAvgOrderByAggregateInput
    _max?: mapDenormalizeMaxOrderByAggregateInput
    _min?: mapDenormalizeMinOrderByAggregateInput
    _sum?: mapDenormalizeSumOrderByAggregateInput
  }

  export type mapDenormalizeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapDenormalizeScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapDenormalizeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapDenormalizeScalarWhereWithAggregatesInput>
    itemID?: IntWithAggregatesFilter | number
    typeID?: IntNullableWithAggregatesFilter | number | null
    groupID?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    constellationID?: IntNullableWithAggregatesFilter | number | null
    regionID?: IntNullableWithAggregatesFilter | number | null
    orbitID?: IntNullableWithAggregatesFilter | number | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
    itemName?: StringNullableWithAggregatesFilter | string | null
    security?: FloatNullableWithAggregatesFilter | number | null
    celestialIndex?: IntNullableWithAggregatesFilter | number | null
    orbitIndex?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapJumpsWhereInput = {
    AND?: Enumerable<mapJumpsWhereInput>
    OR?: Enumerable<mapJumpsWhereInput>
    NOT?: Enumerable<mapJumpsWhereInput>
    stargateID?: IntFilter | number
    destinationID?: IntNullableFilter | number | null
  }

  export type mapJumpsOrderByWithRelationInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsWhereUniqueInput = {
    stargateID?: number
  }

  export type mapJumpsOrderByWithAggregationInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
    _count?: mapJumpsCountOrderByAggregateInput
    _avg?: mapJumpsAvgOrderByAggregateInput
    _max?: mapJumpsMaxOrderByAggregateInput
    _min?: mapJumpsMinOrderByAggregateInput
    _sum?: mapJumpsSumOrderByAggregateInput
  }

  export type mapJumpsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapJumpsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapJumpsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapJumpsScalarWhereWithAggregatesInput>
    stargateID?: IntWithAggregatesFilter | number
    destinationID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapLandmarksWhereInput = {
    AND?: Enumerable<mapLandmarksWhereInput>
    OR?: Enumerable<mapLandmarksWhereInput>
    NOT?: Enumerable<mapLandmarksWhereInput>
    landmarkID?: IntFilter | number
    landmarkName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    locationID?: IntNullableFilter | number | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    iconID?: IntNullableFilter | number | null
  }

  export type mapLandmarksOrderByWithRelationInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksWhereUniqueInput = {
    landmarkID?: number
  }

  export type mapLandmarksOrderByWithAggregationInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
    _count?: mapLandmarksCountOrderByAggregateInput
    _avg?: mapLandmarksAvgOrderByAggregateInput
    _max?: mapLandmarksMaxOrderByAggregateInput
    _min?: mapLandmarksMinOrderByAggregateInput
    _sum?: mapLandmarksSumOrderByAggregateInput
  }

  export type mapLandmarksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapLandmarksScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapLandmarksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapLandmarksScalarWhereWithAggregatesInput>
    landmarkID?: IntWithAggregatesFilter | number
    landmarkName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    locationID?: IntNullableWithAggregatesFilter | number | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    iconID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapLocationScenesWhereInput = {
    AND?: Enumerable<mapLocationScenesWhereInput>
    OR?: Enumerable<mapLocationScenesWhereInput>
    NOT?: Enumerable<mapLocationScenesWhereInput>
    locationID?: IntFilter | number
    graphicID?: IntNullableFilter | number | null
  }

  export type mapLocationScenesOrderByWithRelationInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesWhereUniqueInput = {
    locationID?: number
  }

  export type mapLocationScenesOrderByWithAggregationInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
    _count?: mapLocationScenesCountOrderByAggregateInput
    _avg?: mapLocationScenesAvgOrderByAggregateInput
    _max?: mapLocationScenesMaxOrderByAggregateInput
    _min?: mapLocationScenesMinOrderByAggregateInput
    _sum?: mapLocationScenesSumOrderByAggregateInput
  }

  export type mapLocationScenesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapLocationScenesScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapLocationScenesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapLocationScenesScalarWhereWithAggregatesInput>
    locationID?: IntWithAggregatesFilter | number
    graphicID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapLocationWormholeClassesWhereInput = {
    AND?: Enumerable<mapLocationWormholeClassesWhereInput>
    OR?: Enumerable<mapLocationWormholeClassesWhereInput>
    NOT?: Enumerable<mapLocationWormholeClassesWhereInput>
    locationID?: IntFilter | number
    wormholeClassID?: IntNullableFilter | number | null
  }

  export type mapLocationWormholeClassesOrderByWithRelationInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesWhereUniqueInput = {
    locationID?: number
  }

  export type mapLocationWormholeClassesOrderByWithAggregationInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
    _count?: mapLocationWormholeClassesCountOrderByAggregateInput
    _avg?: mapLocationWormholeClassesAvgOrderByAggregateInput
    _max?: mapLocationWormholeClassesMaxOrderByAggregateInput
    _min?: mapLocationWormholeClassesMinOrderByAggregateInput
    _sum?: mapLocationWormholeClassesSumOrderByAggregateInput
  }

  export type mapLocationWormholeClassesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapLocationWormholeClassesScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapLocationWormholeClassesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapLocationWormholeClassesScalarWhereWithAggregatesInput>
    locationID?: IntWithAggregatesFilter | number
    wormholeClassID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapRegionJumpsWhereInput = {
    AND?: Enumerable<mapRegionJumpsWhereInput>
    OR?: Enumerable<mapRegionJumpsWhereInput>
    NOT?: Enumerable<mapRegionJumpsWhereInput>
    fromRegionID?: IntFilter | number
    toRegionID?: IntFilter | number
  }

  export type mapRegionJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsWhereUniqueInput = {
    fromRegionID_toRegionID?: mapRegionJumpsFromRegionIDToRegionIDCompoundUniqueInput
  }

  export type mapRegionJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
    _count?: mapRegionJumpsCountOrderByAggregateInput
    _avg?: mapRegionJumpsAvgOrderByAggregateInput
    _max?: mapRegionJumpsMaxOrderByAggregateInput
    _min?: mapRegionJumpsMinOrderByAggregateInput
    _sum?: mapRegionJumpsSumOrderByAggregateInput
  }

  export type mapRegionJumpsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapRegionJumpsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapRegionJumpsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapRegionJumpsScalarWhereWithAggregatesInput>
    fromRegionID?: IntWithAggregatesFilter | number
    toRegionID?: IntWithAggregatesFilter | number
  }

  export type mapRegionsWhereInput = {
    AND?: Enumerable<mapRegionsWhereInput>
    OR?: Enumerable<mapRegionsWhereInput>
    NOT?: Enumerable<mapRegionsWhereInput>
    regionID?: IntFilter | number
    regionName?: StringNullableFilter | string | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    xMin?: FloatNullableFilter | number | null
    xMax?: FloatNullableFilter | number | null
    yMin?: FloatNullableFilter | number | null
    yMax?: FloatNullableFilter | number | null
    zMin?: FloatNullableFilter | number | null
    zMax?: FloatNullableFilter | number | null
    factionID?: IntNullableFilter | number | null
    nebula?: IntNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
  }

  export type mapRegionsOrderByWithRelationInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsWhereUniqueInput = {
    regionID?: number
  }

  export type mapRegionsOrderByWithAggregationInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
    _count?: mapRegionsCountOrderByAggregateInput
    _avg?: mapRegionsAvgOrderByAggregateInput
    _max?: mapRegionsMaxOrderByAggregateInput
    _min?: mapRegionsMinOrderByAggregateInput
    _sum?: mapRegionsSumOrderByAggregateInput
  }

  export type mapRegionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapRegionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapRegionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapRegionsScalarWhereWithAggregatesInput>
    regionID?: IntWithAggregatesFilter | number
    regionName?: StringNullableWithAggregatesFilter | string | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    xMin?: FloatNullableWithAggregatesFilter | number | null
    xMax?: FloatNullableWithAggregatesFilter | number | null
    yMin?: FloatNullableWithAggregatesFilter | number | null
    yMax?: FloatNullableWithAggregatesFilter | number | null
    zMin?: FloatNullableWithAggregatesFilter | number | null
    zMax?: FloatNullableWithAggregatesFilter | number | null
    factionID?: IntNullableWithAggregatesFilter | number | null
    nebula?: IntNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
  }

  export type mapSolarSystemJumpsWhereInput = {
    AND?: Enumerable<mapSolarSystemJumpsWhereInput>
    OR?: Enumerable<mapSolarSystemJumpsWhereInput>
    NOT?: Enumerable<mapSolarSystemJumpsWhereInput>
    fromRegionID?: IntNullableFilter | number | null
    fromConstellationID?: IntNullableFilter | number | null
    fromSolarSystemID?: IntFilter | number
    toSolarSystemID?: IntFilter | number
    toConstellationID?: IntNullableFilter | number | null
    toRegionID?: IntNullableFilter | number | null
  }

  export type mapSolarSystemJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsWhereUniqueInput = {
    fromSolarSystemID_toSolarSystemID?: mapSolarSystemJumpsFromSolarSystemIDToSolarSystemIDCompoundUniqueInput
  }

  export type mapSolarSystemJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
    _count?: mapSolarSystemJumpsCountOrderByAggregateInput
    _avg?: mapSolarSystemJumpsAvgOrderByAggregateInput
    _max?: mapSolarSystemJumpsMaxOrderByAggregateInput
    _min?: mapSolarSystemJumpsMinOrderByAggregateInput
    _sum?: mapSolarSystemJumpsSumOrderByAggregateInput
  }

  export type mapSolarSystemJumpsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapSolarSystemJumpsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapSolarSystemJumpsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapSolarSystemJumpsScalarWhereWithAggregatesInput>
    fromRegionID?: IntNullableWithAggregatesFilter | number | null
    fromConstellationID?: IntNullableWithAggregatesFilter | number | null
    fromSolarSystemID?: IntWithAggregatesFilter | number
    toSolarSystemID?: IntWithAggregatesFilter | number
    toConstellationID?: IntNullableWithAggregatesFilter | number | null
    toRegionID?: IntNullableWithAggregatesFilter | number | null
  }

  export type mapSolarSystemsWhereInput = {
    AND?: Enumerable<mapSolarSystemsWhereInput>
    OR?: Enumerable<mapSolarSystemsWhereInput>
    NOT?: Enumerable<mapSolarSystemsWhereInput>
    regionID?: IntNullableFilter | number | null
    constellationID?: IntNullableFilter | number | null
    solarSystemID?: IntFilter | number
    solarSystemName?: StringNullableFilter | string | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    xMin?: FloatNullableFilter | number | null
    xMax?: FloatNullableFilter | number | null
    yMin?: FloatNullableFilter | number | null
    yMax?: FloatNullableFilter | number | null
    zMin?: FloatNullableFilter | number | null
    zMax?: FloatNullableFilter | number | null
    luminosity?: FloatNullableFilter | number | null
    border?: BoolNullableFilter | boolean | null
    fringe?: BoolNullableFilter | boolean | null
    corridor?: BoolNullableFilter | boolean | null
    hub?: BoolNullableFilter | boolean | null
    international?: BoolNullableFilter | boolean | null
    regional?: BoolNullableFilter | boolean | null
    constellation?: BoolNullableFilter | boolean | null
    security?: FloatNullableFilter | number | null
    factionID?: IntNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
    sunTypeID?: IntNullableFilter | number | null
    securityClass?: StringNullableFilter | string | null
  }

  export type mapSolarSystemsOrderByWithRelationInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsWhereUniqueInput = {
    solarSystemID?: number
  }

  export type mapSolarSystemsOrderByWithAggregationInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
    _count?: mapSolarSystemsCountOrderByAggregateInput
    _avg?: mapSolarSystemsAvgOrderByAggregateInput
    _max?: mapSolarSystemsMaxOrderByAggregateInput
    _min?: mapSolarSystemsMinOrderByAggregateInput
    _sum?: mapSolarSystemsSumOrderByAggregateInput
  }

  export type mapSolarSystemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapSolarSystemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapSolarSystemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapSolarSystemsScalarWhereWithAggregatesInput>
    regionID?: IntNullableWithAggregatesFilter | number | null
    constellationID?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntWithAggregatesFilter | number
    solarSystemName?: StringNullableWithAggregatesFilter | string | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    xMin?: FloatNullableWithAggregatesFilter | number | null
    xMax?: FloatNullableWithAggregatesFilter | number | null
    yMin?: FloatNullableWithAggregatesFilter | number | null
    yMax?: FloatNullableWithAggregatesFilter | number | null
    zMin?: FloatNullableWithAggregatesFilter | number | null
    zMax?: FloatNullableWithAggregatesFilter | number | null
    luminosity?: FloatNullableWithAggregatesFilter | number | null
    border?: BoolNullableWithAggregatesFilter | boolean | null
    fringe?: BoolNullableWithAggregatesFilter | boolean | null
    corridor?: BoolNullableWithAggregatesFilter | boolean | null
    hub?: BoolNullableWithAggregatesFilter | boolean | null
    international?: BoolNullableWithAggregatesFilter | boolean | null
    regional?: BoolNullableWithAggregatesFilter | boolean | null
    constellation?: BoolNullableWithAggregatesFilter | boolean | null
    security?: FloatNullableWithAggregatesFilter | number | null
    factionID?: IntNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
    sunTypeID?: IntNullableWithAggregatesFilter | number | null
    securityClass?: StringNullableWithAggregatesFilter | string | null
  }

  export type mapUniverseWhereInput = {
    AND?: Enumerable<mapUniverseWhereInput>
    OR?: Enumerable<mapUniverseWhereInput>
    NOT?: Enumerable<mapUniverseWhereInput>
    universeID?: IntFilter | number
    universeName?: StringNullableFilter | string | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    xMin?: FloatNullableFilter | number | null
    xMax?: FloatNullableFilter | number | null
    yMin?: FloatNullableFilter | number | null
    yMax?: FloatNullableFilter | number | null
    zMin?: FloatNullableFilter | number | null
    zMax?: FloatNullableFilter | number | null
    radius?: FloatNullableFilter | number | null
  }

  export type mapUniverseOrderByWithRelationInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseWhereUniqueInput = {
    universeID?: number
  }

  export type mapUniverseOrderByWithAggregationInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
    _count?: mapUniverseCountOrderByAggregateInput
    _avg?: mapUniverseAvgOrderByAggregateInput
    _max?: mapUniverseMaxOrderByAggregateInput
    _min?: mapUniverseMinOrderByAggregateInput
    _sum?: mapUniverseSumOrderByAggregateInput
  }

  export type mapUniverseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mapUniverseScalarWhereWithAggregatesInput>
    OR?: Enumerable<mapUniverseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mapUniverseScalarWhereWithAggregatesInput>
    universeID?: IntWithAggregatesFilter | number
    universeName?: StringNullableWithAggregatesFilter | string | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    xMin?: FloatNullableWithAggregatesFilter | number | null
    xMax?: FloatNullableWithAggregatesFilter | number | null
    yMin?: FloatNullableWithAggregatesFilter | number | null
    yMax?: FloatNullableWithAggregatesFilter | number | null
    zMin?: FloatNullableWithAggregatesFilter | number | null
    zMax?: FloatNullableWithAggregatesFilter | number | null
    radius?: FloatNullableWithAggregatesFilter | number | null
  }

  export type planetSchematicsWhereInput = {
    AND?: Enumerable<planetSchematicsWhereInput>
    OR?: Enumerable<planetSchematicsWhereInput>
    NOT?: Enumerable<planetSchematicsWhereInput>
    schematicID?: IntFilter | number
    schematicName?: StringNullableFilter | string | null
    cycleTime?: IntNullableFilter | number | null
  }

  export type planetSchematicsOrderByWithRelationInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsWhereUniqueInput = {
    schematicID?: number
  }

  export type planetSchematicsOrderByWithAggregationInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
    _count?: planetSchematicsCountOrderByAggregateInput
    _avg?: planetSchematicsAvgOrderByAggregateInput
    _max?: planetSchematicsMaxOrderByAggregateInput
    _min?: planetSchematicsMinOrderByAggregateInput
    _sum?: planetSchematicsSumOrderByAggregateInput
  }

  export type planetSchematicsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<planetSchematicsScalarWhereWithAggregatesInput>
    OR?: Enumerable<planetSchematicsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<planetSchematicsScalarWhereWithAggregatesInput>
    schematicID?: IntWithAggregatesFilter | number
    schematicName?: StringNullableWithAggregatesFilter | string | null
    cycleTime?: IntNullableWithAggregatesFilter | number | null
  }

  export type planetSchematicsPinMapWhereInput = {
    AND?: Enumerable<planetSchematicsPinMapWhereInput>
    OR?: Enumerable<planetSchematicsPinMapWhereInput>
    NOT?: Enumerable<planetSchematicsPinMapWhereInput>
    schematicID?: IntFilter | number
    pinTypeID?: IntFilter | number
  }

  export type planetSchematicsPinMapOrderByWithRelationInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapWhereUniqueInput = {
    schematicID_pinTypeID?: planetSchematicsPinMapSchematicIDPinTypeIDCompoundUniqueInput
  }

  export type planetSchematicsPinMapOrderByWithAggregationInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
    _count?: planetSchematicsPinMapCountOrderByAggregateInput
    _avg?: planetSchematicsPinMapAvgOrderByAggregateInput
    _max?: planetSchematicsPinMapMaxOrderByAggregateInput
    _min?: planetSchematicsPinMapMinOrderByAggregateInput
    _sum?: planetSchematicsPinMapSumOrderByAggregateInput
  }

  export type planetSchematicsPinMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<planetSchematicsPinMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<planetSchematicsPinMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<planetSchematicsPinMapScalarWhereWithAggregatesInput>
    schematicID?: IntWithAggregatesFilter | number
    pinTypeID?: IntWithAggregatesFilter | number
  }

  export type planetSchematicsTypeMapWhereInput = {
    AND?: Enumerable<planetSchematicsTypeMapWhereInput>
    OR?: Enumerable<planetSchematicsTypeMapWhereInput>
    NOT?: Enumerable<planetSchematicsTypeMapWhereInput>
    schematicID?: IntFilter | number
    typeID?: IntFilter | number
    quantity?: IntNullableFilter | number | null
    isInput?: BoolNullableFilter | boolean | null
  }

  export type planetSchematicsTypeMapOrderByWithRelationInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapWhereUniqueInput = {
    schematicID_typeID?: planetSchematicsTypeMapSchematicIDTypeIDCompoundUniqueInput
  }

  export type planetSchematicsTypeMapOrderByWithAggregationInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
    _count?: planetSchematicsTypeMapCountOrderByAggregateInput
    _avg?: planetSchematicsTypeMapAvgOrderByAggregateInput
    _max?: planetSchematicsTypeMapMaxOrderByAggregateInput
    _min?: planetSchematicsTypeMapMinOrderByAggregateInput
    _sum?: planetSchematicsTypeMapSumOrderByAggregateInput
  }

  export type planetSchematicsTypeMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<planetSchematicsTypeMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<planetSchematicsTypeMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<planetSchematicsTypeMapScalarWhereWithAggregatesInput>
    schematicID?: IntWithAggregatesFilter | number
    typeID?: IntWithAggregatesFilter | number
    quantity?: IntNullableWithAggregatesFilter | number | null
    isInput?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ramActivitiesWhereInput = {
    AND?: Enumerable<ramActivitiesWhereInput>
    OR?: Enumerable<ramActivitiesWhereInput>
    NOT?: Enumerable<ramActivitiesWhereInput>
    activityID?: IntFilter | number
    activityName?: StringNullableFilter | string | null
    iconNo?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    published?: BoolNullableFilter | boolean | null
  }

  export type ramActivitiesOrderByWithRelationInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesWhereUniqueInput = {
    activityID?: number
  }

  export type ramActivitiesOrderByWithAggregationInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
    _count?: ramActivitiesCountOrderByAggregateInput
    _avg?: ramActivitiesAvgOrderByAggregateInput
    _max?: ramActivitiesMaxOrderByAggregateInput
    _min?: ramActivitiesMinOrderByAggregateInput
    _sum?: ramActivitiesSumOrderByAggregateInput
  }

  export type ramActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramActivitiesScalarWhereWithAggregatesInput>
    activityID?: IntWithAggregatesFilter | number
    activityName?: StringNullableWithAggregatesFilter | string | null
    iconNo?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ramAssemblyLineStationsWhereInput = {
    AND?: Enumerable<ramAssemblyLineStationsWhereInput>
    OR?: Enumerable<ramAssemblyLineStationsWhereInput>
    NOT?: Enumerable<ramAssemblyLineStationsWhereInput>
    stationID?: IntFilter | number
    assemblyLineTypeID?: IntFilter | number
    quantity?: IntNullableFilter | number | null
    stationTypeID?: IntNullableFilter | number | null
    ownerID?: IntNullableFilter | number | null
    solarSystemID?: IntNullableFilter | number | null
    regionID?: IntNullableFilter | number | null
  }

  export type ramAssemblyLineStationsOrderByWithRelationInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsWhereUniqueInput = {
    stationID_assemblyLineTypeID?: ramAssemblyLineStationsStationIDAssemblyLineTypeIDCompoundUniqueInput
  }

  export type ramAssemblyLineStationsOrderByWithAggregationInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
    _count?: ramAssemblyLineStationsCountOrderByAggregateInput
    _avg?: ramAssemblyLineStationsAvgOrderByAggregateInput
    _max?: ramAssemblyLineStationsMaxOrderByAggregateInput
    _min?: ramAssemblyLineStationsMinOrderByAggregateInput
    _sum?: ramAssemblyLineStationsSumOrderByAggregateInput
  }

  export type ramAssemblyLineStationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramAssemblyLineStationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramAssemblyLineStationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramAssemblyLineStationsScalarWhereWithAggregatesInput>
    stationID?: IntWithAggregatesFilter | number
    assemblyLineTypeID?: IntWithAggregatesFilter | number
    quantity?: IntNullableWithAggregatesFilter | number | null
    stationTypeID?: IntNullableWithAggregatesFilter | number | null
    ownerID?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    regionID?: IntNullableWithAggregatesFilter | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryWhereInput = {
    AND?: Enumerable<ramAssemblyLineTypeDetailPerCategoryWhereInput>
    OR?: Enumerable<ramAssemblyLineTypeDetailPerCategoryWhereInput>
    NOT?: Enumerable<ramAssemblyLineTypeDetailPerCategoryWhereInput>
    assemblyLineTypeID?: IntFilter | number
    categoryID?: IntFilter | number
    timeMultiplier?: FloatNullableFilter | number | null
    materialMultiplier?: FloatNullableFilter | number | null
    costMultiplier?: FloatNullableFilter | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput = {
    assemblyLineTypeID_categoryID?: ramAssemblyLineTypeDetailPerCategoryAssemblyLineTypeIDCategoryIDCompoundUniqueInput
  }

  export type ramAssemblyLineTypeDetailPerCategoryOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
    _count?: ramAssemblyLineTypeDetailPerCategoryCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypeDetailPerCategoryAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypeDetailPerCategoryMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypeDetailPerCategoryMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypeDetailPerCategorySumOrderByAggregateInput
  }

  export type ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput>
    assemblyLineTypeID?: IntWithAggregatesFilter | number
    categoryID?: IntWithAggregatesFilter | number
    timeMultiplier?: FloatNullableWithAggregatesFilter | number | null
    materialMultiplier?: FloatNullableWithAggregatesFilter | number | null
    costMultiplier?: FloatNullableWithAggregatesFilter | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupWhereInput = {
    AND?: Enumerable<ramAssemblyLineTypeDetailPerGroupWhereInput>
    OR?: Enumerable<ramAssemblyLineTypeDetailPerGroupWhereInput>
    NOT?: Enumerable<ramAssemblyLineTypeDetailPerGroupWhereInput>
    assemblyLineTypeID?: IntFilter | number
    groupID?: IntFilter | number
    timeMultiplier?: FloatNullableFilter | number | null
    materialMultiplier?: FloatNullableFilter | number | null
    costMultiplier?: FloatNullableFilter | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupWhereUniqueInput = {
    assemblyLineTypeID_groupID?: ramAssemblyLineTypeDetailPerGroupAssemblyLineTypeIDGroupIDCompoundUniqueInput
  }

  export type ramAssemblyLineTypeDetailPerGroupOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
    _count?: ramAssemblyLineTypeDetailPerGroupCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypeDetailPerGroupAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypeDetailPerGroupMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypeDetailPerGroupMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypeDetailPerGroupSumOrderByAggregateInput
  }

  export type ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput>
    assemblyLineTypeID?: IntWithAggregatesFilter | number
    groupID?: IntWithAggregatesFilter | number
    timeMultiplier?: FloatNullableWithAggregatesFilter | number | null
    materialMultiplier?: FloatNullableWithAggregatesFilter | number | null
    costMultiplier?: FloatNullableWithAggregatesFilter | number | null
  }

  export type ramAssemblyLineTypesWhereInput = {
    AND?: Enumerable<ramAssemblyLineTypesWhereInput>
    OR?: Enumerable<ramAssemblyLineTypesWhereInput>
    NOT?: Enumerable<ramAssemblyLineTypesWhereInput>
    assemblyLineTypeID?: IntFilter | number
    assemblyLineTypeName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    baseTimeMultiplier?: FloatNullableFilter | number | null
    baseMaterialMultiplier?: FloatNullableFilter | number | null
    baseCostMultiplier?: FloatNullableFilter | number | null
    volume?: FloatNullableFilter | number | null
    activityID?: IntNullableFilter | number | null
    minCostPerHour?: FloatNullableFilter | number | null
  }

  export type ramAssemblyLineTypesOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesWhereUniqueInput = {
    assemblyLineTypeID?: number
  }

  export type ramAssemblyLineTypesOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
    _count?: ramAssemblyLineTypesCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypesAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypesMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypesMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypesSumOrderByAggregateInput
  }

  export type ramAssemblyLineTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramAssemblyLineTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramAssemblyLineTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramAssemblyLineTypesScalarWhereWithAggregatesInput>
    assemblyLineTypeID?: IntWithAggregatesFilter | number
    assemblyLineTypeName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    baseTimeMultiplier?: FloatNullableWithAggregatesFilter | number | null
    baseMaterialMultiplier?: FloatNullableWithAggregatesFilter | number | null
    baseCostMultiplier?: FloatNullableWithAggregatesFilter | number | null
    volume?: FloatNullableWithAggregatesFilter | number | null
    activityID?: IntNullableWithAggregatesFilter | number | null
    minCostPerHour?: FloatNullableWithAggregatesFilter | number | null
  }

  export type ramInstallationTypeContentsWhereInput = {
    AND?: Enumerable<ramInstallationTypeContentsWhereInput>
    OR?: Enumerable<ramInstallationTypeContentsWhereInput>
    NOT?: Enumerable<ramInstallationTypeContentsWhereInput>
    installationTypeID?: IntFilter | number
    assemblyLineTypeID?: IntFilter | number
    quantity?: IntNullableFilter | number | null
  }

  export type ramInstallationTypeContentsOrderByWithRelationInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsWhereUniqueInput = {
    installationTypeID_assemblyLineTypeID?: ramInstallationTypeContentsInstallationTypeIDAssemblyLineTypeIDCompoundUniqueInput
  }

  export type ramInstallationTypeContentsOrderByWithAggregationInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    _count?: ramInstallationTypeContentsCountOrderByAggregateInput
    _avg?: ramInstallationTypeContentsAvgOrderByAggregateInput
    _max?: ramInstallationTypeContentsMaxOrderByAggregateInput
    _min?: ramInstallationTypeContentsMinOrderByAggregateInput
    _sum?: ramInstallationTypeContentsSumOrderByAggregateInput
  }

  export type ramInstallationTypeContentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ramInstallationTypeContentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ramInstallationTypeContentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ramInstallationTypeContentsScalarWhereWithAggregatesInput>
    installationTypeID?: IntWithAggregatesFilter | number
    assemblyLineTypeID?: IntWithAggregatesFilter | number
    quantity?: IntNullableWithAggregatesFilter | number | null
  }

  export type skinLicenseWhereInput = {
    AND?: Enumerable<skinLicenseWhereInput>
    OR?: Enumerable<skinLicenseWhereInput>
    NOT?: Enumerable<skinLicenseWhereInput>
    licenseTypeID?: IntFilter | number
    duration?: IntNullableFilter | number | null
    skinID?: IntNullableFilter | number | null
  }

  export type skinLicenseOrderByWithRelationInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseWhereUniqueInput = {
    licenseTypeID?: number
  }

  export type skinLicenseOrderByWithAggregationInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
    _count?: skinLicenseCountOrderByAggregateInput
    _avg?: skinLicenseAvgOrderByAggregateInput
    _max?: skinLicenseMaxOrderByAggregateInput
    _min?: skinLicenseMinOrderByAggregateInput
    _sum?: skinLicenseSumOrderByAggregateInput
  }

  export type skinLicenseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skinLicenseScalarWhereWithAggregatesInput>
    OR?: Enumerable<skinLicenseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skinLicenseScalarWhereWithAggregatesInput>
    licenseTypeID?: IntWithAggregatesFilter | number
    duration?: IntNullableWithAggregatesFilter | number | null
    skinID?: IntNullableWithAggregatesFilter | number | null
  }

  export type skinMaterialsWhereInput = {
    AND?: Enumerable<skinMaterialsWhereInput>
    OR?: Enumerable<skinMaterialsWhereInput>
    NOT?: Enumerable<skinMaterialsWhereInput>
    skinMaterialID?: IntFilter | number
    displayNameID?: IntNullableFilter | number | null
    materialSetID?: IntNullableFilter | number | null
  }

  export type skinMaterialsOrderByWithRelationInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsWhereUniqueInput = {
    skinMaterialID?: number
  }

  export type skinMaterialsOrderByWithAggregationInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
    _count?: skinMaterialsCountOrderByAggregateInput
    _avg?: skinMaterialsAvgOrderByAggregateInput
    _max?: skinMaterialsMaxOrderByAggregateInput
    _min?: skinMaterialsMinOrderByAggregateInput
    _sum?: skinMaterialsSumOrderByAggregateInput
  }

  export type skinMaterialsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skinMaterialsScalarWhereWithAggregatesInput>
    OR?: Enumerable<skinMaterialsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skinMaterialsScalarWhereWithAggregatesInput>
    skinMaterialID?: IntWithAggregatesFilter | number
    displayNameID?: IntNullableWithAggregatesFilter | number | null
    materialSetID?: IntNullableWithAggregatesFilter | number | null
  }

  export type skinsWhereInput = {
    AND?: Enumerable<skinsWhereInput>
    OR?: Enumerable<skinsWhereInput>
    NOT?: Enumerable<skinsWhereInput>
    skinID?: IntFilter | number
    internalName?: StringNullableFilter | string | null
    skinMaterialID?: IntNullableFilter | number | null
  }

  export type skinsOrderByWithRelationInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsWhereUniqueInput = {
    skinID?: number
  }

  export type skinsOrderByWithAggregationInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
    _count?: skinsCountOrderByAggregateInput
    _avg?: skinsAvgOrderByAggregateInput
    _max?: skinsMaxOrderByAggregateInput
    _min?: skinsMinOrderByAggregateInput
    _sum?: skinsSumOrderByAggregateInput
  }

  export type skinsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skinsScalarWhereWithAggregatesInput>
    OR?: Enumerable<skinsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skinsScalarWhereWithAggregatesInput>
    skinID?: IntWithAggregatesFilter | number
    internalName?: StringNullableWithAggregatesFilter | string | null
    skinMaterialID?: IntNullableWithAggregatesFilter | number | null
  }

  export type staOperationServicesWhereInput = {
    AND?: Enumerable<staOperationServicesWhereInput>
    OR?: Enumerable<staOperationServicesWhereInput>
    NOT?: Enumerable<staOperationServicesWhereInput>
    operationID?: IntFilter | number
    serviceID?: IntFilter | number
  }

  export type staOperationServicesOrderByWithRelationInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesWhereUniqueInput = {
    operationID_serviceID?: staOperationServicesOperationIDServiceIDCompoundUniqueInput
  }

  export type staOperationServicesOrderByWithAggregationInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
    _count?: staOperationServicesCountOrderByAggregateInput
    _avg?: staOperationServicesAvgOrderByAggregateInput
    _max?: staOperationServicesMaxOrderByAggregateInput
    _min?: staOperationServicesMinOrderByAggregateInput
    _sum?: staOperationServicesSumOrderByAggregateInput
  }

  export type staOperationServicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staOperationServicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<staOperationServicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staOperationServicesScalarWhereWithAggregatesInput>
    operationID?: IntWithAggregatesFilter | number
    serviceID?: IntWithAggregatesFilter | number
  }

  export type staOperationsWhereInput = {
    AND?: Enumerable<staOperationsWhereInput>
    OR?: Enumerable<staOperationsWhereInput>
    NOT?: Enumerable<staOperationsWhereInput>
    activityID?: IntNullableFilter | number | null
    operationID?: IntFilter | number
    operationName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    fringe?: IntNullableFilter | number | null
    corridor?: IntNullableFilter | number | null
    hub?: IntNullableFilter | number | null
    border?: IntNullableFilter | number | null
    ratio?: IntNullableFilter | number | null
    caldariStationTypeID?: IntNullableFilter | number | null
    minmatarStationTypeID?: IntNullableFilter | number | null
    amarrStationTypeID?: IntNullableFilter | number | null
    gallenteStationTypeID?: IntNullableFilter | number | null
    joveStationTypeID?: IntNullableFilter | number | null
  }

  export type staOperationsOrderByWithRelationInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsWhereUniqueInput = {
    operationID?: number
  }

  export type staOperationsOrderByWithAggregationInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
    _count?: staOperationsCountOrderByAggregateInput
    _avg?: staOperationsAvgOrderByAggregateInput
    _max?: staOperationsMaxOrderByAggregateInput
    _min?: staOperationsMinOrderByAggregateInput
    _sum?: staOperationsSumOrderByAggregateInput
  }

  export type staOperationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staOperationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<staOperationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staOperationsScalarWhereWithAggregatesInput>
    activityID?: IntNullableWithAggregatesFilter | number | null
    operationID?: IntWithAggregatesFilter | number
    operationName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    fringe?: IntNullableWithAggregatesFilter | number | null
    corridor?: IntNullableWithAggregatesFilter | number | null
    hub?: IntNullableWithAggregatesFilter | number | null
    border?: IntNullableWithAggregatesFilter | number | null
    ratio?: IntNullableWithAggregatesFilter | number | null
    caldariStationTypeID?: IntNullableWithAggregatesFilter | number | null
    minmatarStationTypeID?: IntNullableWithAggregatesFilter | number | null
    amarrStationTypeID?: IntNullableWithAggregatesFilter | number | null
    gallenteStationTypeID?: IntNullableWithAggregatesFilter | number | null
    joveStationTypeID?: IntNullableWithAggregatesFilter | number | null
  }

  export type staServicesWhereInput = {
    AND?: Enumerable<staServicesWhereInput>
    OR?: Enumerable<staServicesWhereInput>
    NOT?: Enumerable<staServicesWhereInput>
    serviceID?: IntFilter | number
    serviceName?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type staServicesOrderByWithRelationInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesWhereUniqueInput = {
    serviceID?: number
  }

  export type staServicesOrderByWithAggregationInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
    _count?: staServicesCountOrderByAggregateInput
    _avg?: staServicesAvgOrderByAggregateInput
    _max?: staServicesMaxOrderByAggregateInput
    _min?: staServicesMinOrderByAggregateInput
    _sum?: staServicesSumOrderByAggregateInput
  }

  export type staServicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staServicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<staServicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staServicesScalarWhereWithAggregatesInput>
    serviceID?: IntWithAggregatesFilter | number
    serviceName?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type staStationTypesWhereInput = {
    AND?: Enumerable<staStationTypesWhereInput>
    OR?: Enumerable<staStationTypesWhereInput>
    NOT?: Enumerable<staStationTypesWhereInput>
    stationTypeID?: IntFilter | number
    dockEntryX?: FloatNullableFilter | number | null
    dockEntryY?: FloatNullableFilter | number | null
    dockEntryZ?: FloatNullableFilter | number | null
    dockOrientationX?: FloatNullableFilter | number | null
    dockOrientationY?: FloatNullableFilter | number | null
    dockOrientationZ?: FloatNullableFilter | number | null
    operationID?: IntNullableFilter | number | null
    officeSlots?: IntNullableFilter | number | null
    reprocessingEfficiency?: FloatNullableFilter | number | null
    conquerable?: BoolNullableFilter | boolean | null
  }

  export type staStationTypesOrderByWithRelationInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesWhereUniqueInput = {
    stationTypeID?: number
  }

  export type staStationTypesOrderByWithAggregationInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
    _count?: staStationTypesCountOrderByAggregateInput
    _avg?: staStationTypesAvgOrderByAggregateInput
    _max?: staStationTypesMaxOrderByAggregateInput
    _min?: staStationTypesMinOrderByAggregateInput
    _sum?: staStationTypesSumOrderByAggregateInput
  }

  export type staStationTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staStationTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<staStationTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staStationTypesScalarWhereWithAggregatesInput>
    stationTypeID?: IntWithAggregatesFilter | number
    dockEntryX?: FloatNullableWithAggregatesFilter | number | null
    dockEntryY?: FloatNullableWithAggregatesFilter | number | null
    dockEntryZ?: FloatNullableWithAggregatesFilter | number | null
    dockOrientationX?: FloatNullableWithAggregatesFilter | number | null
    dockOrientationY?: FloatNullableWithAggregatesFilter | number | null
    dockOrientationZ?: FloatNullableWithAggregatesFilter | number | null
    operationID?: IntNullableWithAggregatesFilter | number | null
    officeSlots?: IntNullableWithAggregatesFilter | number | null
    reprocessingEfficiency?: FloatNullableWithAggregatesFilter | number | null
    conquerable?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type staStationsWhereInput = {
    AND?: Enumerable<staStationsWhereInput>
    OR?: Enumerable<staStationsWhereInput>
    NOT?: Enumerable<staStationsWhereInput>
    stationID?: BigIntFilter | bigint | number
    security?: FloatNullableFilter | number | null
    dockingCostPerVolume?: FloatNullableFilter | number | null
    maxShipVolumeDockable?: FloatNullableFilter | number | null
    officeRentalCost?: IntNullableFilter | number | null
    operationID?: IntNullableFilter | number | null
    stationTypeID?: IntNullableFilter | number | null
    corporationID?: IntNullableFilter | number | null
    solarSystemID?: IntNullableFilter | number | null
    constellationID?: IntNullableFilter | number | null
    regionID?: IntNullableFilter | number | null
    stationName?: StringNullableFilter | string | null
    x?: FloatNullableFilter | number | null
    y?: FloatNullableFilter | number | null
    z?: FloatNullableFilter | number | null
    reprocessingEfficiency?: FloatNullableFilter | number | null
    reprocessingStationsTake?: FloatNullableFilter | number | null
    reprocessingHangarFlag?: IntNullableFilter | number | null
  }

  export type staStationsOrderByWithRelationInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsWhereUniqueInput = {
    stationID?: bigint | number
  }

  export type staStationsOrderByWithAggregationInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
    _count?: staStationsCountOrderByAggregateInput
    _avg?: staStationsAvgOrderByAggregateInput
    _max?: staStationsMaxOrderByAggregateInput
    _min?: staStationsMinOrderByAggregateInput
    _sum?: staStationsSumOrderByAggregateInput
  }

  export type staStationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staStationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<staStationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staStationsScalarWhereWithAggregatesInput>
    stationID?: BigIntWithAggregatesFilter | bigint | number
    security?: FloatNullableWithAggregatesFilter | number | null
    dockingCostPerVolume?: FloatNullableWithAggregatesFilter | number | null
    maxShipVolumeDockable?: FloatNullableWithAggregatesFilter | number | null
    officeRentalCost?: IntNullableWithAggregatesFilter | number | null
    operationID?: IntNullableWithAggregatesFilter | number | null
    stationTypeID?: IntNullableWithAggregatesFilter | number | null
    corporationID?: IntNullableWithAggregatesFilter | number | null
    solarSystemID?: IntNullableWithAggregatesFilter | number | null
    constellationID?: IntNullableWithAggregatesFilter | number | null
    regionID?: IntNullableWithAggregatesFilter | number | null
    stationName?: StringNullableWithAggregatesFilter | string | null
    x?: FloatNullableWithAggregatesFilter | number | null
    y?: FloatNullableWithAggregatesFilter | number | null
    z?: FloatNullableWithAggregatesFilter | number | null
    reprocessingEfficiency?: FloatNullableWithAggregatesFilter | number | null
    reprocessingStationsTake?: FloatNullableWithAggregatesFilter | number | null
    reprocessingHangarFlag?: IntNullableWithAggregatesFilter | number | null
  }

  export type translationTablesWhereInput = {
    AND?: Enumerable<translationTablesWhereInput>
    OR?: Enumerable<translationTablesWhereInput>
    NOT?: Enumerable<translationTablesWhereInput>
    sourceTable?: StringFilter | string
    destinationTable?: StringNullableFilter | string | null
    translatedKey?: StringFilter | string
    tcGroupID?: IntNullableFilter | number | null
    tcID?: IntNullableFilter | number | null
  }

  export type translationTablesOrderByWithRelationInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesWhereUniqueInput = {
    sourceTable_translatedKey?: translationTablesSourceTableTranslatedKeyCompoundUniqueInput
  }

  export type translationTablesOrderByWithAggregationInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
    _count?: translationTablesCountOrderByAggregateInput
    _avg?: translationTablesAvgOrderByAggregateInput
    _max?: translationTablesMaxOrderByAggregateInput
    _min?: translationTablesMinOrderByAggregateInput
    _sum?: translationTablesSumOrderByAggregateInput
  }

  export type translationTablesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<translationTablesScalarWhereWithAggregatesInput>
    OR?: Enumerable<translationTablesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<translationTablesScalarWhereWithAggregatesInput>
    sourceTable?: StringWithAggregatesFilter | string
    destinationTable?: StringNullableWithAggregatesFilter | string | null
    translatedKey?: StringWithAggregatesFilter | string
    tcGroupID?: IntNullableWithAggregatesFilter | number | null
    tcID?: IntNullableWithAggregatesFilter | number | null
  }

  export type trnTranslationColumnsWhereInput = {
    AND?: Enumerable<trnTranslationColumnsWhereInput>
    OR?: Enumerable<trnTranslationColumnsWhereInput>
    NOT?: Enumerable<trnTranslationColumnsWhereInput>
    tcGroupID?: IntNullableFilter | number | null
    tcID?: IntFilter | number
    tableName?: StringFilter | string
    columnName?: StringFilter | string
    masterID?: StringNullableFilter | string | null
  }

  export type trnTranslationColumnsOrderByWithRelationInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsWhereUniqueInput = {
    tcID?: number
  }

  export type trnTranslationColumnsOrderByWithAggregationInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
    _count?: trnTranslationColumnsCountOrderByAggregateInput
    _avg?: trnTranslationColumnsAvgOrderByAggregateInput
    _max?: trnTranslationColumnsMaxOrderByAggregateInput
    _min?: trnTranslationColumnsMinOrderByAggregateInput
    _sum?: trnTranslationColumnsSumOrderByAggregateInput
  }

  export type trnTranslationColumnsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<trnTranslationColumnsScalarWhereWithAggregatesInput>
    OR?: Enumerable<trnTranslationColumnsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<trnTranslationColumnsScalarWhereWithAggregatesInput>
    tcGroupID?: IntNullableWithAggregatesFilter | number | null
    tcID?: IntWithAggregatesFilter | number
    tableName?: StringWithAggregatesFilter | string
    columnName?: StringWithAggregatesFilter | string
    masterID?: StringNullableWithAggregatesFilter | string | null
  }

  export type trnTranslationLanguagesWhereInput = {
    AND?: Enumerable<trnTranslationLanguagesWhereInput>
    OR?: Enumerable<trnTranslationLanguagesWhereInput>
    NOT?: Enumerable<trnTranslationLanguagesWhereInput>
    numericLanguageID?: IntFilter | number
    languageID?: StringNullableFilter | string | null
    languageName?: StringNullableFilter | string | null
  }

  export type trnTranslationLanguagesOrderByWithRelationInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesWhereUniqueInput = {
    numericLanguageID?: number
  }

  export type trnTranslationLanguagesOrderByWithAggregationInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
    _count?: trnTranslationLanguagesCountOrderByAggregateInput
    _avg?: trnTranslationLanguagesAvgOrderByAggregateInput
    _max?: trnTranslationLanguagesMaxOrderByAggregateInput
    _min?: trnTranslationLanguagesMinOrderByAggregateInput
    _sum?: trnTranslationLanguagesSumOrderByAggregateInput
  }

  export type trnTranslationLanguagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<trnTranslationLanguagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<trnTranslationLanguagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<trnTranslationLanguagesScalarWhereWithAggregatesInput>
    numericLanguageID?: IntWithAggregatesFilter | number
    languageID?: StringNullableWithAggregatesFilter | string | null
    languageName?: StringNullableWithAggregatesFilter | string | null
  }

  export type trnTranslationsWhereInput = {
    AND?: Enumerable<trnTranslationsWhereInput>
    OR?: Enumerable<trnTranslationsWhereInput>
    NOT?: Enumerable<trnTranslationsWhereInput>
    tcID?: IntFilter | number
    keyID?: IntFilter | number
    languageID?: StringFilter | string
    text?: StringFilter | string
  }

  export type trnTranslationsOrderByWithRelationInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsWhereUniqueInput = {
    tcID_keyID_languageID?: trnTranslationsTcIDKeyIDLanguageIDCompoundUniqueInput
  }

  export type trnTranslationsOrderByWithAggregationInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
    _count?: trnTranslationsCountOrderByAggregateInput
    _avg?: trnTranslationsAvgOrderByAggregateInput
    _max?: trnTranslationsMaxOrderByAggregateInput
    _min?: trnTranslationsMinOrderByAggregateInput
    _sum?: trnTranslationsSumOrderByAggregateInput
  }

  export type trnTranslationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<trnTranslationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<trnTranslationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<trnTranslationsScalarWhereWithAggregatesInput>
    tcID?: IntWithAggregatesFilter | number
    keyID?: IntWithAggregatesFilter | number
    languageID?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
  }

  export type warCombatZoneSystemsWhereInput = {
    AND?: Enumerable<warCombatZoneSystemsWhereInput>
    OR?: Enumerable<warCombatZoneSystemsWhereInput>
    NOT?: Enumerable<warCombatZoneSystemsWhereInput>
    solarSystemID?: IntFilter | number
    combatZoneID?: IntNullableFilter | number | null
  }

  export type warCombatZoneSystemsOrderByWithRelationInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsWhereUniqueInput = {
    solarSystemID?: number
  }

  export type warCombatZoneSystemsOrderByWithAggregationInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
    _count?: warCombatZoneSystemsCountOrderByAggregateInput
    _avg?: warCombatZoneSystemsAvgOrderByAggregateInput
    _max?: warCombatZoneSystemsMaxOrderByAggregateInput
    _min?: warCombatZoneSystemsMinOrderByAggregateInput
    _sum?: warCombatZoneSystemsSumOrderByAggregateInput
  }

  export type warCombatZoneSystemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<warCombatZoneSystemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<warCombatZoneSystemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<warCombatZoneSystemsScalarWhereWithAggregatesInput>
    solarSystemID?: IntWithAggregatesFilter | number
    combatZoneID?: IntNullableWithAggregatesFilter | number | null
  }

  export type warCombatZonesWhereInput = {
    AND?: Enumerable<warCombatZonesWhereInput>
    OR?: Enumerable<warCombatZonesWhereInput>
    NOT?: Enumerable<warCombatZonesWhereInput>
    combatZoneID?: IntFilter | number
    combatZoneName?: StringNullableFilter | string | null
    factionID?: IntNullableFilter | number | null
    centerSystemID?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
  }

  export type warCombatZonesOrderByWithRelationInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesWhereUniqueInput = {
    combatZoneID?: number
  }

  export type warCombatZonesOrderByWithAggregationInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
    _count?: warCombatZonesCountOrderByAggregateInput
    _avg?: warCombatZonesAvgOrderByAggregateInput
    _max?: warCombatZonesMaxOrderByAggregateInput
    _min?: warCombatZonesMinOrderByAggregateInput
    _sum?: warCombatZonesSumOrderByAggregateInput
  }

  export type warCombatZonesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<warCombatZonesScalarWhereWithAggregatesInput>
    OR?: Enumerable<warCombatZonesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<warCombatZonesScalarWhereWithAggregatesInput>
    combatZoneID?: IntWithAggregatesFilter | number
    combatZoneName?: StringNullableWithAggregatesFilter | string | null
    factionID?: IntNullableWithAggregatesFilter | number | null
    centerSystemID?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCreateInput = {
    username: string
    email: string
    status?: UserStatus
    characters?: CharacterCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    status?: UserStatus
    characters?: CharacterUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    characters?: CharacterUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    characters?: CharacterUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    status?: UserStatus
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
  }

  export type CharacterCreateInput = {
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    owner: UserCreateNestedOneWithoutCharactersInput
    corporation: CorporationCreateNestedOneWithoutCharacterInput
    alliance?: AllianceCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CharacterUpdateInput = {
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    owner?: UserUpdateOneRequiredWithoutCharactersNestedInput
    corporation?: CorporationUpdateOneRequiredWithoutCharacterNestedInput
    alliance?: AllianceUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterCreateManyInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CharacterUpdateManyMutationInput = {
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type AllianceCreateInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Corporation?: CorporationCreateNestedManyWithoutAllianceInput
    Character?: CharacterCreateNestedManyWithoutAllianceInput
  }

  export type AllianceUncheckedCreateInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Corporation?: CorporationUncheckedCreateNestedManyWithoutAllianceInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAllianceInput
  }

  export type AllianceUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Corporation?: CorporationUpdateManyWithoutAllianceNestedInput
    Character?: CharacterUpdateManyWithoutAllianceNestedInput
  }

  export type AllianceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Corporation?: CorporationUncheckedUpdateManyWithoutAllianceNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAllianceNestedInput
  }

  export type AllianceCreateManyInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
  }

  export type AllianceUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type AllianceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type CorporationCreateInput = {
    id: number
    alliance?: AllianceCreateNestedOneWithoutCorporationInput
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
    Character?: CharacterCreateNestedManyWithoutCorporationInput
  }

  export type CorporationUncheckedCreateInput = {
    id: number
    allianceId?: number | null
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
    Character?: CharacterUncheckedCreateNestedManyWithoutCorporationInput
  }

  export type CorporationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alliance?: AllianceUpdateOneWithoutCorporationNestedInput
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
    Character?: CharacterUpdateManyWithoutCorporationNestedInput
  }

  export type CorporationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
    Character?: CharacterUncheckedUpdateManyWithoutCorporationNestedInput
  }

  export type CorporationCreateManyInput = {
    id: number
    allianceId?: number | null
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
  }

  export type CorporationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CorporationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type agtAgentTypesCreateInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUncheckedCreateInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUpdateInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesUncheckedUpdateInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesCreateManyInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUpdateManyMutationInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesUncheckedUpdateManyInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentsCreateInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUncheckedCreateInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsCreateManyInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsInSpaceCreateInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUncheckedCreateInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceCreateManyInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtResearchAgentsCreateInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUncheckedCreateInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsCreateManyInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type certCertsCreateInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUncheckedCreateInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUpdateInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsUncheckedUpdateInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsCreateManyInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUpdateManyMutationInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsUncheckedUpdateManyInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesCreateInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUncheckedCreateInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUpdateInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesUncheckedUpdateInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesCreateManyInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUpdateManyMutationInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesUncheckedUpdateManyInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUncheckedCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesUncheckedUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesCreateManyInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUpdateManyMutationInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesUncheckedUpdateManyInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesCreateInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUncheckedCreateInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUpdateInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesUncheckedUpdateInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesCreateManyInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUpdateManyMutationInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesUncheckedUpdateManyInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrFactionsCreateInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUncheckedCreateInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsUncheckedUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsCreateManyInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUpdateManyMutationInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsUncheckedUpdateManyInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrRacesCreateInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUncheckedCreateInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUpdateInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesUncheckedUpdateInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesCreateManyInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUpdateManyMutationInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesUncheckedUpdateManyInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesCreateInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUncheckedCreateInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesUncheckedUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesCreateManyInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUpdateManyMutationInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesUncheckedUpdateManyInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCCorporationDivisionsCreateInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUncheckedCreateInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsCreateManyInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationResearchFieldsCreateInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUncheckedCreateInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUpdateInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsUncheckedUpdateInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsCreateManyInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUpdateManyMutationInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsUncheckedUpdateManyInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesCreateInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUncheckedCreateInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesCreateManyInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationsCreateInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUncheckedCreateInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsCreateManyInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCDivisionsCreateInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUncheckedCreateInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUpdateInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsUncheckedUpdateInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsCreateManyInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUpdateManyMutationInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsUncheckedUpdateManyInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesCreateInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUncheckedCreateInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesUncheckedUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesCreateManyInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUpdateManyMutationInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesUncheckedUpdateManyInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeTypesCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUncheckedCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesUncheckedUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesCreateManyInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUpdateManyMutationInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesUncheckedUpdateManyInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmEffectsCreateInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUncheckedCreateInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUpdateInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsUncheckedUpdateInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsCreateManyInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUpdateManyMutationInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsUncheckedUpdateManyInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmExpressionsCreateInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUncheckedCreateInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUpdateInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsUncheckedUpdateInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsCreateManyInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUpdateManyMutationInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsUncheckedUpdateManyInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesCreateInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUncheckedCreateInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesCreateManyInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeEffectsCreateInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUncheckedCreateInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsCreateManyInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eveGraphicsCreateInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUncheckedCreateInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUpdateInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsUncheckedUpdateInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsCreateManyInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUpdateManyMutationInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsUncheckedUpdateManyInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsCreateInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUncheckedCreateInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUpdateInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsUncheckedUpdateInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsCreateManyInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUpdateManyMutationInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsUncheckedUpdateManyInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsCreateInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUncheckedCreateInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUpdateInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsUncheckedUpdateInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsCreateManyInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUpdateManyMutationInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsUncheckedUpdateManyInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type industryActivityCreateInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUncheckedCreateInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityCreateManyInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsCreateInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUncheckedCreateInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsCreateManyInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invCategoriesCreateInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUncheckedCreateInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesUncheckedUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesCreateManyInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUpdateManyMutationInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesUncheckedUpdateManyInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invContrabandTypesCreateInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUncheckedCreateInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesUncheckedUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesCreateManyInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUpdateManyMutationInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesUncheckedUpdateManyInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcePurposesCreateInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUncheckedCreateInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUpdateInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesUncheckedUpdateInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesCreateManyInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUpdateManyMutationInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesUncheckedUpdateManyInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcesCreateInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUncheckedCreateInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUpdateInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesUncheckedUpdateInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesCreateManyInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUpdateManyMutationInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesUncheckedUpdateManyInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsCreateInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUncheckedCreateInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUpdateInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsUncheckedUpdateInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsCreateManyInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUpdateManyMutationInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsUncheckedUpdateManyInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invGroupsCreateInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUncheckedCreateInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUpdateInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsUncheckedUpdateInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsCreateManyInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUpdateManyMutationInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsUncheckedUpdateManyInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invItemsCreateInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUncheckedCreateInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsCreateManyInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invMarketGroupsCreateInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUncheckedCreateInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUpdateInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsUncheckedUpdateInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsCreateManyInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUpdateManyMutationInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsUncheckedUpdateManyInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMetaGroupsCreateInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUncheckedCreateInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUpdateInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsUncheckedUpdateInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsCreateManyInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUpdateManyMutationInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsUncheckedUpdateManyInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesCreateInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUncheckedCreateInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesCreateManyInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invNamesCreateInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUncheckedCreateInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesCreateManyInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invPositionsCreateInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUncheckedCreateInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsCreateManyInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invTraitsCreateInput = {
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUncheckedCreateInput = {
    traitID?: number
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUpdateInput = {
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsUncheckedUpdateInput = {
    traitID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsCreateManyInput = {
    traitID?: number
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUpdateManyMutationInput = {
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsUncheckedUpdateManyInput = {
    traitID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeMaterialsCreateInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUncheckedCreateInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsCreateManyInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeReactionsCreateInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUncheckedCreateInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUpdateInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsUncheckedUpdateInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsCreateManyInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUpdateManyMutationInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsUncheckedUpdateManyInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesCreateInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUncheckedCreateInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesCreateManyInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesCreateInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUncheckedCreateInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesCreateManyInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesCreateInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUncheckedCreateInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesCreateManyInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialGraphicsCreateInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUncheckedCreateInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsUncheckedUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsCreateManyInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUpdateManyMutationInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsUncheckedUpdateManyInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialStatisticsCreateInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUncheckedCreateInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsUncheckedUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsCreateManyInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUpdateManyMutationInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsUncheckedUpdateManyInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsCreateInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUncheckedCreateInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsUncheckedUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsCreateManyInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUpdateManyMutationInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsUncheckedUpdateManyInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsCreateInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUncheckedCreateInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsUncheckedUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsCreateManyInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUpdateManyMutationInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsUncheckedUpdateManyInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeCreateInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUncheckedCreateInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeCreateManyInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsCreateInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUncheckedCreateInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUpdateInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsUncheckedUpdateInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsCreateManyInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUpdateManyMutationInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsUncheckedUpdateManyInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksCreateInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUncheckedCreateInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUpdateInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksUncheckedUpdateInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksCreateManyInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUpdateManyMutationInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksUncheckedUpdateManyInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesCreateInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUncheckedCreateInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesUncheckedUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesCreateManyInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUpdateManyMutationInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesUncheckedUpdateManyInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesCreateInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUncheckedCreateInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesUncheckedUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesCreateManyInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUpdateManyMutationInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesUncheckedUpdateManyInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapRegionJumpsCreateInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUncheckedCreateInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUpdateInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsUncheckedUpdateInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsCreateManyInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUpdateManyMutationInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsUncheckedUpdateManyInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionsCreateInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUncheckedCreateInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsUncheckedUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsCreateManyInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUpdateManyMutationInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsUncheckedUpdateManyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsCreateInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUncheckedCreateInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsUncheckedUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsCreateManyInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUpdateManyMutationInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsUncheckedUpdateManyInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemsCreateInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUncheckedCreateInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsUncheckedUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsCreateManyInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUpdateManyMutationInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsUncheckedUpdateManyInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapUniverseCreateInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUncheckedCreateInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUpdateInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseUncheckedUpdateInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseCreateManyInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUpdateManyMutationInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseUncheckedUpdateManyInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsCreateInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUncheckedCreateInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsCreateManyInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsPinMapCreateInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUncheckedCreateInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapCreateManyInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsTypeMapCreateInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUncheckedCreateInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapCreateManyInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesCreateInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUncheckedCreateInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesUncheckedUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesCreateManyInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUpdateManyMutationInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesUncheckedUpdateManyInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramAssemblyLineStationsCreateInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUncheckedCreateInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUpdateInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsUncheckedUpdateInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsCreateManyInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUpdateManyMutationInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsUncheckedUpdateManyInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryCreateInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryCreateManyInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupCreateInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupCreateManyInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesCreateInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUncheckedCreateInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesCreateManyInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsCreateInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUncheckedCreateInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUpdateInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsUncheckedUpdateInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsCreateManyInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUpdateManyMutationInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsUncheckedUpdateManyInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseCreateInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUncheckedCreateInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUpdateInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseUncheckedUpdateInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseCreateManyInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUpdateManyMutationInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseUncheckedUpdateManyInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsCreateInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUncheckedCreateInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUpdateInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsUncheckedUpdateInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsCreateManyInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUpdateManyMutationInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsUncheckedUpdateManyInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsCreateInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUncheckedCreateInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUpdateInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsUncheckedUpdateInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsCreateManyInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUpdateManyMutationInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsUncheckedUpdateManyInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationServicesCreateInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUncheckedCreateInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUpdateInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesUncheckedUpdateInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesCreateManyInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUpdateManyMutationInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesUncheckedUpdateManyInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationsCreateInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUncheckedCreateInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUpdateInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsUncheckedUpdateInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsCreateManyInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUpdateManyMutationInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsUncheckedUpdateManyInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staServicesCreateInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUncheckedCreateInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUpdateInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesUncheckedUpdateInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesCreateManyInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUpdateManyMutationInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesUncheckedUpdateManyInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staStationTypesCreateInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUncheckedCreateInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUpdateInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesUncheckedUpdateInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesCreateManyInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUpdateManyMutationInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesUncheckedUpdateManyInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationsCreateInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUncheckedCreateInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUpdateInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsUncheckedUpdateInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsCreateManyInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUpdateManyMutationInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsUncheckedUpdateManyInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesCreateInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUncheckedCreateInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUpdateInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesUncheckedUpdateInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesCreateManyInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUpdateManyMutationInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesUncheckedUpdateManyInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type trnTranslationColumnsCreateInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUncheckedCreateInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUpdateInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsUncheckedUpdateInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsCreateManyInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUpdateManyMutationInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsUncheckedUpdateManyInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesCreateInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUncheckedCreateInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUpdateInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesUncheckedUpdateInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesCreateManyInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUpdateManyMutationInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesUncheckedUpdateManyInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationsCreateInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUncheckedCreateInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUpdateInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsUncheckedUpdateInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsCreateManyInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUpdateManyMutationInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsUncheckedUpdateManyInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type warCombatZoneSystemsCreateInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUncheckedCreateInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUpdateInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsUncheckedUpdateInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsCreateManyInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUpdateManyMutationInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsUncheckedUpdateManyInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZonesCreateInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUncheckedCreateInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUpdateInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesUncheckedUpdateInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesCreateManyInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUpdateManyMutationInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesUncheckedUpdateManyInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CorporationRelationFilter = {
    is?: CorporationWhereInput
    isNot?: CorporationWhereInput
  }

  export type AllianceRelationFilter = {
    is?: AllianceWhereInput | null
    isNot?: AllianceWhereInput | null
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    esiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    birthday?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    gender?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    scopes?: SortOrder
    securityStatus?: SortOrder
    title?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    id?: SortOrder
    esiId?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    factionId?: SortOrder
    raceId?: SortOrder
    securityStatus?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    esiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    birthday?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    gender?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    scopes?: SortOrder
    securityStatus?: SortOrder
    title?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    esiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    birthday?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    gender?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    scopes?: SortOrder
    securityStatus?: SortOrder
    title?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    id?: SortOrder
    esiId?: SortOrder
    tokenExpiresAt?: SortOrder
    allianceId?: SortOrder
    ancestryId?: SortOrder
    bloodlineId?: SortOrder
    corporationId?: SortOrder
    factionId?: SortOrder
    raceId?: SortOrder
    securityStatus?: SortOrder
    totalSp?: SortOrder
    ownerId?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type CorporationListRelationFilter = {
    every?: CorporationWhereInput
    some?: CorporationWhereInput
    none?: CorporationWhereInput
  }

  export type CorporationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllianceCountOrderByAggregateInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    dateFounded?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
    ticker?: SortOrder
  }

  export type AllianceAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
  }

  export type AllianceMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    dateFounded?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
    ticker?: SortOrder
  }

  export type AllianceMinOrderByAggregateInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    dateFounded?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
    ticker?: SortOrder
  }

  export type AllianceSumOrderByAggregateInput = {
    id?: SortOrder
    creatorCorporationId?: SortOrder
    creatorId?: SortOrder
    executorCorporationId?: SortOrder
    factionId?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type CorporationCountOrderByAggregateInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    dateFounded?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    name?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
    ticker?: SortOrder
    url?: SortOrder
    warEligible?: SortOrder
  }

  export type CorporationAvgOrderByAggregateInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
  }

  export type CorporationMaxOrderByAggregateInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    dateFounded?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    name?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
    ticker?: SortOrder
    url?: SortOrder
    warEligible?: SortOrder
  }

  export type CorporationMinOrderByAggregateInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    dateFounded?: SortOrder
    description?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    name?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
    ticker?: SortOrder
    url?: SortOrder
    warEligible?: SortOrder
  }

  export type CorporationSumOrderByAggregateInput = {
    id?: SortOrder
    allianceId?: SortOrder
    ceoId?: SortOrder
    creatorId?: SortOrder
    factionId?: SortOrder
    homeStationId?: SortOrder
    memberCount?: SortOrder
    shares?: SortOrder
    taxRate?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type agtAgentTypesCountOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesAvgOrderByAggregateInput = {
    agentTypeID?: SortOrder
  }

  export type agtAgentTypesMaxOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesMinOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesSumOrderByAggregateInput = {
    agentTypeID?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type agtAgentsCountOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsAvgOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
  }

  export type agtAgentsMaxOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsMinOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsSumOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type agtAgentsInSpaceCountOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceAvgOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceMaxOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceMinOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceSumOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsAgentIDTypeIDCompoundUniqueInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsCountOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsAvgOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsMaxOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsMinOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsSumOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type certCertsCountOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsAvgOrderByAggregateInput = {
    certID?: SortOrder
    groupID?: SortOrder
  }

  export type certCertsMaxOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsMinOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsSumOrderByAggregateInput = {
    certID?: SortOrder
    groupID?: SortOrder
  }

  export type chrAncestriesCountOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesAvgOrderByAggregateInput = {
    ancestryID?: SortOrder
    bloodlineID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrAncestriesMaxOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesMinOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesSumOrderByAggregateInput = {
    ancestryID?: SortOrder
    bloodlineID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrAttributesCountOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesAvgOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
  }

  export type chrAttributesMaxOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesMinOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesSumOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
  }

  export type chrBloodlinesCountOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesAvgOrderByAggregateInput = {
    bloodlineID?: SortOrder
    raceID?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrBloodlinesMaxOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesMinOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesSumOrderByAggregateInput = {
    bloodlineID?: SortOrder
    raceID?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type chrFactionsCountOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsAvgOrderByAggregateInput = {
    factionID?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsMaxOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsMinOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsSumOrderByAggregateInput = {
    factionID?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type chrRacesCountOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesAvgOrderByAggregateInput = {
    raceID?: SortOrder
    iconID?: SortOrder
  }

  export type chrRacesMaxOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesMinOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesSumOrderByAggregateInput = {
    raceID?: SortOrder
    iconID?: SortOrder
  }

  export type crpActivitiesCountOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesAvgOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type crpActivitiesMaxOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesMinOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesSumOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type crpNPCCorporationDivisionsCorporationIDDivisionIDCompoundUniqueInput = {
    corporationID: number
    divisionID: number
  }

  export type crpNPCCorporationDivisionsCountOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsMinOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsSumOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsSkillIDCorporationIDCompoundUniqueInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsCountOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsAvgOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsMaxOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsMinOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsSumOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationTradesCorporationIDTypeIDCompoundUniqueInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesCountOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesMinOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesSumOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationsCountOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsMinOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsSumOrderByAggregateInput = {
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCDivisionsCountOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsAvgOrderByAggregateInput = {
    divisionID?: SortOrder
  }

  export type crpNPCDivisionsMaxOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsMinOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsSumOrderByAggregateInput = {
    divisionID?: SortOrder
  }

  export type dgmAttributeCategoriesCountOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesAvgOrderByAggregateInput = {
    categoryID?: SortOrder
  }

  export type dgmAttributeCategoriesMaxOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesMinOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesSumOrderByAggregateInput = {
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesCountOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesAvgOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    unitID?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesMaxOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesMinOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesSumOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    unitID?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmEffectsCountOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsAvgOrderByAggregateInput = {
    effectID?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    iconID?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    distribution?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
  }

  export type dgmEffectsMaxOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsMinOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsSumOrderByAggregateInput = {
    effectID?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    iconID?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    distribution?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
  }

  export type dgmExpressionsCountOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsAvgOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsMaxOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsMinOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsSumOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmTypeAttributesTypeIDAttributeIDCompoundUniqueInput = {
    typeID: number
    attributeID: number
  }

  export type dgmTypeAttributesCountOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesMinOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesSumOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeEffectsTypeIDEffectIDCompoundUniqueInput = {
    typeID: number
    effectID: number
  }

  export type dgmTypeEffectsCountOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
  }

  export type dgmTypeEffectsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsMinOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsSumOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
  }

  export type eveGraphicsCountOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsAvgOrderByAggregateInput = {
    graphicID?: SortOrder
  }

  export type eveGraphicsMaxOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsMinOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsSumOrderByAggregateInput = {
    graphicID?: SortOrder
  }

  export type eveIconsCountOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsAvgOrderByAggregateInput = {
    iconID?: SortOrder
  }

  export type eveIconsMaxOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsMinOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsSumOrderByAggregateInput = {
    iconID?: SortOrder
  }

  export type eveUnitsCountOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsAvgOrderByAggregateInput = {
    unitID?: SortOrder
  }

  export type eveUnitsMaxOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsMinOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsSumOrderByAggregateInput = {
    unitID?: SortOrder
  }

  export type industryActivityTypeIDActivityIDCompoundUniqueInput = {
    typeID: number
    activityID: number
  }

  export type industryActivityCountOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityAvgOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityMaxOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityMinOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivitySumOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryBlueprintsCountOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsMinOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsSumOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type invCategoriesCountOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesAvgOrderByAggregateInput = {
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invCategoriesMaxOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesMinOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesSumOrderByAggregateInput = {
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invContrabandTypesFactionIDTypeIDCompoundUniqueInput = {
    factionID: number
    typeID: number
  }

  export type invContrabandTypesCountOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesAvgOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesMaxOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesMinOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesSumOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invControlTowerResourcePurposesCountOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesAvgOrderByAggregateInput = {
    purpose?: SortOrder
  }

  export type invControlTowerResourcePurposesMaxOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesMinOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesSumOrderByAggregateInput = {
    purpose?: SortOrder
  }

  export type invControlTowerResourcesControlTowerTypeIDResourceTypeIDCompoundUniqueInput = {
    controlTowerTypeID: number
    resourceTypeID: number
  }

  export type invControlTowerResourcesCountOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesAvgOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesMaxOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesMinOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesSumOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invFlagsCountOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsAvgOrderByAggregateInput = {
    flagID?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsMaxOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsMinOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsSumOrderByAggregateInput = {
    flagID?: SortOrder
    orderID?: SortOrder
  }

  export type invGroupsCountOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsAvgOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invGroupsMaxOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsMinOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsSumOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invItemsCountOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsAvgOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsMaxOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsMinOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsSumOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invMarketGroupsCountOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsAvgOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMarketGroupsMaxOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsMinOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsSumOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsCountOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsAvgOrderByAggregateInput = {
    metaGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsMaxOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsMinOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsSumOrderByAggregateInput = {
    metaGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaTypesCountOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesMinOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesSumOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invNamesCountOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesAvgOrderByAggregateInput = {
    itemID?: SortOrder
  }

  export type invNamesMaxOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesMinOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesSumOrderByAggregateInput = {
    itemID?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type invPositionsCountOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsAvgOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsMaxOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsMinOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsSumOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type invTraitsCountOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsAvgOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsMaxOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsMinOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsSumOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    unitID?: SortOrder
  }

  export type invTypeMaterialsTypeIDMaterialTypeIDCompoundUniqueInput = {
    typeID: number
    materialTypeID: number
  }

  export type invTypeMaterialsCountOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsMinOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsSumOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsReactionTypeIDInputTypeIDCompoundUniqueInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
  }

  export type invTypeReactionsCountOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsAvgOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsMaxOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsMinOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsSumOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypesCountOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesMinOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesSumOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invUniqueNamesCountOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesAvgOrderByAggregateInput = {
    itemID?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesMaxOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesMinOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesSumOrderByAggregateInput = {
    itemID?: SortOrder
    groupID?: SortOrder
  }

  export type invVolumesCountOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesMinOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesSumOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type mapCelestialGraphicsCountOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsAvgOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
  }

  export type mapCelestialGraphicsMaxOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsMinOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsSumOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
  }

  export type mapCelestialStatisticsCountOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsAvgOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsMaxOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsMinOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsSumOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapConstellationJumpsFromConstellationIDToConstellationIDCompoundUniqueInput = {
    fromConstellationID: number
    toConstellationID: number
  }

  export type mapConstellationJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationsCountOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsMinOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsSumOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapDenormalizeCountOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeAvgOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeMaxOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeMinOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeSumOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapJumpsCountOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsAvgOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsMaxOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsMinOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsSumOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapLandmarksCountOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksAvgOrderByAggregateInput = {
    landmarkID?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksMaxOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksMinOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksSumOrderByAggregateInput = {
    landmarkID?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLocationScenesCountOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesAvgOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesMaxOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesMinOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesSumOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationWormholeClassesCountOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesAvgOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesMaxOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesMinOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesSumOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapRegionJumpsFromRegionIDToRegionIDCompoundUniqueInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionsCountOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsMinOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsSumOrderByAggregateInput = {
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapSolarSystemJumpsFromSolarSystemIDToSolarSystemIDCompoundUniqueInput = {
    fromSolarSystemID: number
    toSolarSystemID: number
  }

  export type mapSolarSystemJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemsCountOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
  }

  export type mapSolarSystemsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsMinOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsSumOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
  }

  export type mapUniverseCountOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseAvgOrderByAggregateInput = {
    universeID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseMaxOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseMinOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseSumOrderByAggregateInput = {
    universeID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type planetSchematicsCountOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsMinOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsSumOrderByAggregateInput = {
    schematicID?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsPinMapSchematicIDPinTypeIDCompoundUniqueInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapCountOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapMinOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapSumOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsTypeMapSchematicIDTypeIDCompoundUniqueInput = {
    schematicID: number
    typeID: number
  }

  export type planetSchematicsTypeMapCountOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type planetSchematicsTypeMapMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapMinOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapSumOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramActivitiesCountOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesAvgOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type ramActivitiesMaxOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesMinOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesSumOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type ramAssemblyLineStationsStationIDAssemblyLineTypeIDCompoundUniqueInput = {
    stationID: number
    assemblyLineTypeID: number
  }

  export type ramAssemblyLineStationsCountOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsAvgOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsMaxOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsMinOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsSumOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryAssemblyLineTypeIDCategoryIDCompoundUniqueInput = {
    assemblyLineTypeID: number
    categoryID: number
  }

  export type ramAssemblyLineTypeDetailPerCategoryCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategorySumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupAssemblyLineTypeIDGroupIDCompoundUniqueInput = {
    assemblyLineTypeID: number
    groupID: number
  }

  export type ramAssemblyLineTypeDetailPerGroupCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupSumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypesCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesSumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramInstallationTypeContentsInstallationTypeIDAssemblyLineTypeIDCompoundUniqueInput = {
    installationTypeID: number
    assemblyLineTypeID: number
  }

  export type ramInstallationTypeContentsCountOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsAvgOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsMaxOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsMinOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsSumOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type skinLicenseCountOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseAvgOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseMaxOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseMinOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseSumOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinMaterialsCountOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsAvgOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsMaxOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsMinOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsSumOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinsCountOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsAvgOrderByAggregateInput = {
    skinID?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsMaxOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsMinOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsSumOrderByAggregateInput = {
    skinID?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type staOperationServicesOperationIDServiceIDCompoundUniqueInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesCountOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesAvgOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesMaxOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesMinOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesSumOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationsCountOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsAvgOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsMaxOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsMinOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsSumOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staServicesCountOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesAvgOrderByAggregateInput = {
    serviceID?: SortOrder
  }

  export type staServicesMaxOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesMinOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesSumOrderByAggregateInput = {
    serviceID?: SortOrder
  }

  export type staStationTypesCountOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesAvgOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
  }

  export type staStationTypesMaxOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesMinOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesSumOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
  }

  export type staStationsCountOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsAvgOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsMaxOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsMinOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsSumOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type translationTablesSourceTableTranslatedKeyCompoundUniqueInput = {
    sourceTable: string
    translatedKey: string
  }

  export type translationTablesCountOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesAvgOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesMaxOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesMinOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesSumOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationColumnsCountOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsAvgOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationColumnsMaxOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsMinOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsSumOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationLanguagesCountOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesAvgOrderByAggregateInput = {
    numericLanguageID?: SortOrder
  }

  export type trnTranslationLanguagesMaxOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesMinOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesSumOrderByAggregateInput = {
    numericLanguageID?: SortOrder
  }

  export type trnTranslationsTcIDKeyIDLanguageIDCompoundUniqueInput = {
    tcID: number
    keyID: number
    languageID: string
  }

  export type trnTranslationsCountOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsAvgOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
  }

  export type trnTranslationsMaxOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsMinOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsSumOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
  }

  export type warCombatZoneSystemsCountOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsAvgOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsMaxOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsMinOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsSumOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZonesCountOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesAvgOrderByAggregateInput = {
    combatZoneID?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
  }

  export type warCombatZonesMaxOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesMinOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesSumOrderByAggregateInput = {
    combatZoneID?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
  }

  export type CharacterCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutOwnerInput>, Enumerable<CharacterUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutOwnerInput>
    createMany?: CharacterCreateManyOwnerInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type CharacterUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutOwnerInput>, Enumerable<CharacterUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutOwnerInput>
    createMany?: CharacterCreateManyOwnerInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: UserStatus
  }

  export type CharacterUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutOwnerInput>, Enumerable<CharacterUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: CharacterCreateManyOwnerInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CharacterUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutOwnerInput>, Enumerable<CharacterUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: CharacterCreateManyOwnerInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCharactersInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type CorporationCreateNestedOneWithoutCharacterInput = {
    create?: XOR<CorporationCreateWithoutCharacterInput, CorporationUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CorporationCreateOrConnectWithoutCharacterInput
    connect?: CorporationWhereUniqueInput
  }

  export type AllianceCreateNestedOneWithoutCharacterInput = {
    create?: XOR<AllianceCreateWithoutCharacterInput, AllianceUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AllianceCreateOrConnectWithoutCharacterInput
    connect?: AllianceWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    upsert?: UserUpsertWithoutCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type CorporationUpdateOneRequiredWithoutCharacterNestedInput = {
    create?: XOR<CorporationCreateWithoutCharacterInput, CorporationUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CorporationCreateOrConnectWithoutCharacterInput
    upsert?: CorporationUpsertWithoutCharacterInput
    connect?: CorporationWhereUniqueInput
    update?: XOR<CorporationUpdateWithoutCharacterInput, CorporationUncheckedUpdateWithoutCharacterInput>
  }

  export type AllianceUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<AllianceCreateWithoutCharacterInput, AllianceUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AllianceCreateOrConnectWithoutCharacterInput
    upsert?: AllianceUpsertWithoutCharacterInput
    disconnect?: boolean
    delete?: boolean
    connect?: AllianceWhereUniqueInput
    update?: XOR<AllianceUpdateWithoutCharacterInput, AllianceUncheckedUpdateWithoutCharacterInput>
  }

  export type CorporationCreateNestedManyWithoutAllianceInput = {
    create?: XOR<Enumerable<CorporationCreateWithoutAllianceInput>, Enumerable<CorporationUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CorporationCreateOrConnectWithoutAllianceInput>
    createMany?: CorporationCreateManyAllianceInputEnvelope
    connect?: Enumerable<CorporationWhereUniqueInput>
  }

  export type CharacterCreateNestedManyWithoutAllianceInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutAllianceInput>, Enumerable<CharacterUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutAllianceInput>
    createMany?: CharacterCreateManyAllianceInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type CorporationUncheckedCreateNestedManyWithoutAllianceInput = {
    create?: XOR<Enumerable<CorporationCreateWithoutAllianceInput>, Enumerable<CorporationUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CorporationCreateOrConnectWithoutAllianceInput>
    createMany?: CorporationCreateManyAllianceInputEnvelope
    connect?: Enumerable<CorporationWhereUniqueInput>
  }

  export type CharacterUncheckedCreateNestedManyWithoutAllianceInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutAllianceInput>, Enumerable<CharacterUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutAllianceInput>
    createMany?: CharacterCreateManyAllianceInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type CorporationUpdateManyWithoutAllianceNestedInput = {
    create?: XOR<Enumerable<CorporationCreateWithoutAllianceInput>, Enumerable<CorporationUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CorporationCreateOrConnectWithoutAllianceInput>
    upsert?: Enumerable<CorporationUpsertWithWhereUniqueWithoutAllianceInput>
    createMany?: CorporationCreateManyAllianceInputEnvelope
    set?: Enumerable<CorporationWhereUniqueInput>
    disconnect?: Enumerable<CorporationWhereUniqueInput>
    delete?: Enumerable<CorporationWhereUniqueInput>
    connect?: Enumerable<CorporationWhereUniqueInput>
    update?: Enumerable<CorporationUpdateWithWhereUniqueWithoutAllianceInput>
    updateMany?: Enumerable<CorporationUpdateManyWithWhereWithoutAllianceInput>
    deleteMany?: Enumerable<CorporationScalarWhereInput>
  }

  export type CharacterUpdateManyWithoutAllianceNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutAllianceInput>, Enumerable<CharacterUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutAllianceInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutAllianceInput>
    createMany?: CharacterCreateManyAllianceInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutAllianceInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutAllianceInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type CorporationUncheckedUpdateManyWithoutAllianceNestedInput = {
    create?: XOR<Enumerable<CorporationCreateWithoutAllianceInput>, Enumerable<CorporationUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CorporationCreateOrConnectWithoutAllianceInput>
    upsert?: Enumerable<CorporationUpsertWithWhereUniqueWithoutAllianceInput>
    createMany?: CorporationCreateManyAllianceInputEnvelope
    set?: Enumerable<CorporationWhereUniqueInput>
    disconnect?: Enumerable<CorporationWhereUniqueInput>
    delete?: Enumerable<CorporationWhereUniqueInput>
    connect?: Enumerable<CorporationWhereUniqueInput>
    update?: Enumerable<CorporationUpdateWithWhereUniqueWithoutAllianceInput>
    updateMany?: Enumerable<CorporationUpdateManyWithWhereWithoutAllianceInput>
    deleteMany?: Enumerable<CorporationScalarWhereInput>
  }

  export type CharacterUncheckedUpdateManyWithoutAllianceNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutAllianceInput>, Enumerable<CharacterUncheckedCreateWithoutAllianceInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutAllianceInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutAllianceInput>
    createMany?: CharacterCreateManyAllianceInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutAllianceInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutAllianceInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type AllianceCreateNestedOneWithoutCorporationInput = {
    create?: XOR<AllianceCreateWithoutCorporationInput, AllianceUncheckedCreateWithoutCorporationInput>
    connectOrCreate?: AllianceCreateOrConnectWithoutCorporationInput
    connect?: AllianceWhereUniqueInput
  }

  export type CharacterCreateNestedManyWithoutCorporationInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutCorporationInput>, Enumerable<CharacterUncheckedCreateWithoutCorporationInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutCorporationInput>
    createMany?: CharacterCreateManyCorporationInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type CharacterUncheckedCreateNestedManyWithoutCorporationInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutCorporationInput>, Enumerable<CharacterUncheckedCreateWithoutCorporationInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutCorporationInput>
    createMany?: CharacterCreateManyCorporationInputEnvelope
    connect?: Enumerable<CharacterWhereUniqueInput>
  }

  export type AllianceUpdateOneWithoutCorporationNestedInput = {
    create?: XOR<AllianceCreateWithoutCorporationInput, AllianceUncheckedCreateWithoutCorporationInput>
    connectOrCreate?: AllianceCreateOrConnectWithoutCorporationInput
    upsert?: AllianceUpsertWithoutCorporationInput
    disconnect?: boolean
    delete?: boolean
    connect?: AllianceWhereUniqueInput
    update?: XOR<AllianceUpdateWithoutCorporationInput, AllianceUncheckedUpdateWithoutCorporationInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CharacterUpdateManyWithoutCorporationNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutCorporationInput>, Enumerable<CharacterUncheckedCreateWithoutCorporationInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutCorporationInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutCorporationInput>
    createMany?: CharacterCreateManyCorporationInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutCorporationInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutCorporationInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type CharacterUncheckedUpdateManyWithoutCorporationNestedInput = {
    create?: XOR<Enumerable<CharacterCreateWithoutCorporationInput>, Enumerable<CharacterUncheckedCreateWithoutCorporationInput>>
    connectOrCreate?: Enumerable<CharacterCreateOrConnectWithoutCorporationInput>
    upsert?: Enumerable<CharacterUpsertWithWhereUniqueWithoutCorporationInput>
    createMany?: CharacterCreateManyCorporationInputEnvelope
    set?: Enumerable<CharacterWhereUniqueInput>
    disconnect?: Enumerable<CharacterWhereUniqueInput>
    delete?: Enumerable<CharacterWhereUniqueInput>
    connect?: Enumerable<CharacterWhereUniqueInput>
    update?: Enumerable<CharacterUpdateWithWhereUniqueWithoutCorporationInput>
    updateMany?: Enumerable<CharacterUpdateManyWithWhereWithoutCorporationInput>
    deleteMany?: Enumerable<CharacterScalarWhereInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type CharacterCreateWithoutOwnerInput = {
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    corporation: CorporationCreateNestedOneWithoutCharacterInput
    alliance?: AllianceCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutOwnerInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
  }

  export type CharacterCreateOrConnectWithoutOwnerInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutOwnerInput, CharacterUncheckedCreateWithoutOwnerInput>
  }

  export type CharacterCreateManyOwnerInputEnvelope = {
    data: Enumerable<CharacterCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutOwnerInput, CharacterUncheckedUpdateWithoutOwnerInput>
    create: XOR<CharacterCreateWithoutOwnerInput, CharacterUncheckedCreateWithoutOwnerInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutOwnerInput, CharacterUncheckedUpdateWithoutOwnerInput>
  }

  export type CharacterUpdateManyWithWhereWithoutOwnerInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutCharactersInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: Enumerable<CharacterScalarWhereInput>
    OR?: Enumerable<CharacterScalarWhereInput>
    NOT?: Enumerable<CharacterScalarWhereInput>
    id?: IntFilter | number
    esiId?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    accessToken?: StringFilter | string
    refreshToken?: StringFilter | string
    tokenExpiresAt?: IntFilter | number
    allianceId?: IntNullableFilter | number | null
    ancestryId?: IntNullableFilter | number | null
    birthday?: DateTimeFilter | Date | string
    bloodlineId?: IntFilter | number
    corporationId?: IntFilter | number
    description?: StringNullableFilter | string | null
    factionId?: IntNullableFilter | number | null
    gender?: StringFilter | string
    name?: StringFilter | string
    raceId?: IntFilter | number
    scopes?: StringFilter | string
    securityStatus?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    title?: StringNullableFilter | string | null
    totalSp?: BigIntNullableFilter | bigint | number | null
    ownerId?: IntFilter | number
  }

  export type UserCreateWithoutCharactersInput = {
    username: string
    email: string
    status?: UserStatus
  }

  export type UserUncheckedCreateWithoutCharactersInput = {
    id?: number
    username: string
    email: string
    status?: UserStatus
  }

  export type UserCreateOrConnectWithoutCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
  }

  export type CorporationCreateWithoutCharacterInput = {
    id: number
    alliance?: AllianceCreateNestedOneWithoutCorporationInput
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
  }

  export type CorporationUncheckedCreateWithoutCharacterInput = {
    id: number
    allianceId?: number | null
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
  }

  export type CorporationCreateOrConnectWithoutCharacterInput = {
    where: CorporationWhereUniqueInput
    create: XOR<CorporationCreateWithoutCharacterInput, CorporationUncheckedCreateWithoutCharacterInput>
  }

  export type AllianceCreateWithoutCharacterInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Corporation?: CorporationCreateNestedManyWithoutAllianceInput
  }

  export type AllianceUncheckedCreateWithoutCharacterInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Corporation?: CorporationUncheckedCreateNestedManyWithoutAllianceInput
  }

  export type AllianceCreateOrConnectWithoutCharacterInput = {
    where: AllianceWhereUniqueInput
    create: XOR<AllianceCreateWithoutCharacterInput, AllianceUncheckedCreateWithoutCharacterInput>
  }

  export type UserUpsertWithoutCharactersInput = {
    update: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
  }

  export type UserUpdateWithoutCharactersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
  }

  export type UserUncheckedUpdateWithoutCharactersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
  }

  export type CorporationUpsertWithoutCharacterInput = {
    update: XOR<CorporationUpdateWithoutCharacterInput, CorporationUncheckedUpdateWithoutCharacterInput>
    create: XOR<CorporationCreateWithoutCharacterInput, CorporationUncheckedCreateWithoutCharacterInput>
  }

  export type CorporationUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    alliance?: AllianceUpdateOneWithoutCorporationNestedInput
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CorporationUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AllianceUpsertWithoutCharacterInput = {
    update: XOR<AllianceUpdateWithoutCharacterInput, AllianceUncheckedUpdateWithoutCharacterInput>
    create: XOR<AllianceCreateWithoutCharacterInput, AllianceUncheckedCreateWithoutCharacterInput>
  }

  export type AllianceUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Corporation?: CorporationUpdateManyWithoutAllianceNestedInput
  }

  export type AllianceUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Corporation?: CorporationUncheckedUpdateManyWithoutAllianceNestedInput
  }

  export type CorporationCreateWithoutAllianceInput = {
    id: number
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
    Character?: CharacterCreateNestedManyWithoutCorporationInput
  }

  export type CorporationUncheckedCreateWithoutAllianceInput = {
    id: number
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
    Character?: CharacterUncheckedCreateNestedManyWithoutCorporationInput
  }

  export type CorporationCreateOrConnectWithoutAllianceInput = {
    where: CorporationWhereUniqueInput
    create: XOR<CorporationCreateWithoutAllianceInput, CorporationUncheckedCreateWithoutAllianceInput>
  }

  export type CorporationCreateManyAllianceInputEnvelope = {
    data: Enumerable<CorporationCreateManyAllianceInput>
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutAllianceInput = {
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    owner: UserCreateNestedOneWithoutCharactersInput
    corporation: CorporationCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAllianceInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CharacterCreateOrConnectWithoutAllianceInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAllianceInput, CharacterUncheckedCreateWithoutAllianceInput>
  }

  export type CharacterCreateManyAllianceInputEnvelope = {
    data: Enumerable<CharacterCreateManyAllianceInput>
    skipDuplicates?: boolean
  }

  export type CorporationUpsertWithWhereUniqueWithoutAllianceInput = {
    where: CorporationWhereUniqueInput
    update: XOR<CorporationUpdateWithoutAllianceInput, CorporationUncheckedUpdateWithoutAllianceInput>
    create: XOR<CorporationCreateWithoutAllianceInput, CorporationUncheckedCreateWithoutAllianceInput>
  }

  export type CorporationUpdateWithWhereUniqueWithoutAllianceInput = {
    where: CorporationWhereUniqueInput
    data: XOR<CorporationUpdateWithoutAllianceInput, CorporationUncheckedUpdateWithoutAllianceInput>
  }

  export type CorporationUpdateManyWithWhereWithoutAllianceInput = {
    where: CorporationScalarWhereInput
    data: XOR<CorporationUpdateManyMutationInput, CorporationUncheckedUpdateManyWithoutCorporationInput>
  }

  export type CorporationScalarWhereInput = {
    AND?: Enumerable<CorporationScalarWhereInput>
    OR?: Enumerable<CorporationScalarWhereInput>
    NOT?: Enumerable<CorporationScalarWhereInput>
    id?: IntFilter | number
    allianceId?: IntNullableFilter | number | null
    ceoId?: IntFilter | number
    creatorId?: IntFilter | number
    dateFounded?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    factionId?: IntNullableFilter | number | null
    homeStationId?: IntNullableFilter | number | null
    memberCount?: IntFilter | number
    name?: StringFilter | string
    shares?: IntNullableFilter | number | null
    taxRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    ticker?: StringFilter | string
    url?: StringNullableFilter | string | null
    warEligible?: BoolFilter | boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutAllianceInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutAllianceInput, CharacterUncheckedUpdateWithoutAllianceInput>
    create: XOR<CharacterCreateWithoutAllianceInput, CharacterUncheckedCreateWithoutAllianceInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutAllianceInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutAllianceInput, CharacterUncheckedUpdateWithoutAllianceInput>
  }

  export type CharacterUpdateManyWithWhereWithoutAllianceInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutCharacterInput>
  }

  export type AllianceCreateWithoutCorporationInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Character?: CharacterCreateNestedManyWithoutAllianceInput
  }

  export type AllianceUncheckedCreateWithoutCorporationInput = {
    id: number
    creatorCorporationId: number
    creatorId: number
    name: string
    dateFounded: Date | string
    executorCorporationId?: number | null
    factionId?: number | null
    ticker: string
    Character?: CharacterUncheckedCreateNestedManyWithoutAllianceInput
  }

  export type AllianceCreateOrConnectWithoutCorporationInput = {
    where: AllianceWhereUniqueInput
    create: XOR<AllianceCreateWithoutCorporationInput, AllianceUncheckedCreateWithoutCorporationInput>
  }

  export type CharacterCreateWithoutCorporationInput = {
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    owner: UserCreateNestedOneWithoutCharactersInput
    alliance?: AllianceCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCorporationInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CharacterCreateOrConnectWithoutCorporationInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCorporationInput, CharacterUncheckedCreateWithoutCorporationInput>
  }

  export type CharacterCreateManyCorporationInputEnvelope = {
    data: Enumerable<CharacterCreateManyCorporationInput>
    skipDuplicates?: boolean
  }

  export type AllianceUpsertWithoutCorporationInput = {
    update: XOR<AllianceUpdateWithoutCorporationInput, AllianceUncheckedUpdateWithoutCorporationInput>
    create: XOR<AllianceCreateWithoutCorporationInput, AllianceUncheckedCreateWithoutCorporationInput>
  }

  export type AllianceUpdateWithoutCorporationInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Character?: CharacterUpdateManyWithoutAllianceNestedInput
  }

  export type AllianceUncheckedUpdateWithoutCorporationInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorCorporationId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dateFounded?: DateTimeFieldUpdateOperationsInput | Date | string
    executorCorporationId?: NullableIntFieldUpdateOperationsInput | number | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    ticker?: StringFieldUpdateOperationsInput | string
    Character?: CharacterUncheckedUpdateManyWithoutAllianceNestedInput
  }

  export type CharacterUpsertWithWhereUniqueWithoutCorporationInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutCorporationInput, CharacterUncheckedUpdateWithoutCorporationInput>
    create: XOR<CharacterCreateWithoutCorporationInput, CharacterUncheckedCreateWithoutCorporationInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutCorporationInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutCorporationInput, CharacterUncheckedUpdateWithoutCorporationInput>
  }

  export type CharacterUpdateManyWithWhereWithoutCorporationInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterCreateManyOwnerInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
  }

  export type CharacterUpdateWithoutOwnerInput = {
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    corporation?: CorporationUpdateOneRequiredWithoutCharacterNestedInput
    alliance?: AllianceUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CharacterUncheckedUpdateManyWithoutCharactersInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CorporationCreateManyAllianceInput = {
    id: number
    ceoId: number
    creatorId: number
    dateFounded?: Date | string | null
    description?: string | null
    factionId?: number | null
    homeStationId?: number | null
    memberCount: number
    name: string
    shares?: number | null
    taxRate: Decimal | DecimalJsLike | number | string
    ticker: string
    url?: string | null
    warEligible: boolean
  }

  export type CharacterCreateManyAllianceInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    corporationId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CorporationUpdateWithoutAllianceInput = {
    id?: IntFieldUpdateOperationsInput | number
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
    Character?: CharacterUpdateManyWithoutCorporationNestedInput
  }

  export type CorporationUncheckedUpdateWithoutAllianceInput = {
    id?: IntFieldUpdateOperationsInput | number
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
    Character?: CharacterUncheckedUpdateManyWithoutCorporationNestedInput
  }

  export type CorporationUncheckedUpdateManyWithoutCorporationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ceoId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    dateFounded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    homeStationId?: NullableIntFieldUpdateOperationsInput | number | null
    memberCount?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shares?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ticker?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    warEligible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterUpdateWithoutAllianceInput = {
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    owner?: UserUpdateOneRequiredWithoutCharactersNestedInput
    corporation?: CorporationUpdateOneRequiredWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAllianceInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterUncheckedUpdateManyWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    corporationId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterCreateManyCorporationInput = {
    id?: number
    esiId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessToken: string
    refreshToken: string
    tokenExpiresAt: number
    allianceId?: number | null
    ancestryId?: number | null
    birthday: Date | string
    bloodlineId: number
    description?: string | null
    factionId?: number | null
    gender: string
    name: string
    raceId: number
    scopes: string
    securityStatus?: Decimal | DecimalJsLike | number | string | null
    title?: string | null
    totalSp?: bigint | number | null
    ownerId: number
  }

  export type CharacterUpdateWithoutCorporationInput = {
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    owner?: UserUpdateOneRequiredWithoutCharactersNestedInput
    alliance?: AllianceUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCorporationInput = {
    id?: IntFieldUpdateOperationsInput | number
    esiId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    tokenExpiresAt?: IntFieldUpdateOperationsInput | number
    allianceId?: NullableIntFieldUpdateOperationsInput | number | null
    ancestryId?: NullableIntFieldUpdateOperationsInput | number | null
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodlineId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    factionId?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    scopes?: StringFieldUpdateOperationsInput | string
    securityStatus?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    totalSp?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ownerId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}